{!Wrapper uses FHIRBase, FHIRBase_Wrapper, FHIRTypes, FHIRTypes_Wrapper}

unit FHIRComponents;

{
  Copyright (c) 2011-2013, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

interface

// FHIR v0.11 generated Wed, Oct 2, 2013 07:37+1000

uses
  SysUtils, Classes, StringSupport, DecimalSupport, AdvBuffers, MSSEWrap, FHIRBase, FHIRTypes;

Type
  TFhirAdverseReactionSymptom = class;
  TFhirAdverseReactionSymptomList = class;
  TFhirAdverseReactionExposure = class;
  TFhirAdverseReactionExposureList = class;
  TFhirCarePlanParticipant = class;
  TFhirCarePlanParticipantList = class;
  TFhirCarePlanGoal = class;
  TFhirCarePlanGoalList = class;
  TFhirCarePlanActivity = class;
  TFhirCarePlanActivityList = class;
  TFhirConditionStage = class;
  TFhirConditionStageList = class;
  TFhirConditionEvidence = class;
  TFhirConditionEvidenceList = class;
  TFhirConditionLocation = class;
  TFhirConditionLocationList = class;
  TFhirConditionRelatedItem = class;
  TFhirConditionRelatedItemList = class;
  TFhirConformanceSoftware = class;
  TFhirConformanceSoftwareList = class;
  TFhirConformanceImplementation = class;
  TFhirConformanceImplementationList = class;
  TFhirConformanceRest = class;
  TFhirConformanceRestList = class;
  TFhirConformanceRestSecurity = class;
  TFhirConformanceRestSecurityList = class;
  TFhirConformanceRestSecurityCertificate = class;
  TFhirConformanceRestSecurityCertificateList = class;
  TFhirConformanceRestResource = class;
  TFhirConformanceRestResourceList = class;
  TFhirConformanceRestResourceOperation = class;
  TFhirConformanceRestResourceOperationList = class;
  TFhirConformanceRestResourceSearchParam = class;
  TFhirConformanceRestResourceSearchParamList = class;
  TFhirConformanceRestQuery = class;
  TFhirConformanceRestQueryList = class;
  TFhirConformanceMessaging = class;
  TFhirConformanceMessagingList = class;
  TFhirConformanceMessagingEvent = class;
  TFhirConformanceMessagingEventList = class;
  TFhirConformanceDocument = class;
  TFhirConformanceDocumentList = class;
  TFhirCoverageSubscriber = class;
  TFhirCoverageSubscriberList = class;
  TFhirDeviceIdentity = class;
  TFhirDeviceIdentityList = class;
  TFhirDeviceCapabilitiesVirtualDevice = class;
  TFhirDeviceCapabilitiesVirtualDeviceList = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannel = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannelList = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetric = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet = class;
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList = class;
  TFhirDeviceLogItem = class;
  TFhirDeviceLogItemList = class;
  TFhirDiagnosticOrderEvent = class;
  TFhirDiagnosticOrderEventList = class;
  TFhirDiagnosticOrderItem = class;
  TFhirDiagnosticOrderItemList = class;
  TFhirDiagnosticReportRequestDetail = class;
  TFhirDiagnosticReportRequestDetailList = class;
  TFhirDiagnosticReportResults = class;
  TFhirDiagnosticReportResultsList = class;
  TFhirDocumentAttester = class;
  TFhirDocumentAttesterList = class;
  TFhirDocumentEvent = class;
  TFhirDocumentEventList = class;
  TFhirDocumentSection = class;
  TFhirDocumentSectionList = class;
  TFhirDocumentReferenceService = class;
  TFhirDocumentReferenceServiceList = class;
  TFhirDocumentReferenceServiceParameter = class;
  TFhirDocumentReferenceServiceParameterList = class;
  TFhirDocumentReferenceContext = class;
  TFhirDocumentReferenceContextList = class;
  TFhirEncounterParticipant = class;
  TFhirEncounterParticipantList = class;
  TFhirEncounterHospitalization = class;
  TFhirEncounterHospitalizationList = class;
  TFhirEncounterHospitalizationAccomodation = class;
  TFhirEncounterHospitalizationAccomodationList = class;
  TFhirEncounterLocation = class;
  TFhirEncounterLocationList = class;
  TFhirFamilyHistoryRelation = class;
  TFhirFamilyHistoryRelationList = class;
  TFhirFamilyHistoryRelationCondition = class;
  TFhirFamilyHistoryRelationConditionList = class;
  TFhirGroupCharacteristic = class;
  TFhirGroupCharacteristicList = class;
  TFhirImagingStudySeries = class;
  TFhirImagingStudySeriesList = class;
  TFhirImagingStudySeriesInstance = class;
  TFhirImagingStudySeriesInstanceList = class;
  TFhirImmunizationExplanation = class;
  TFhirImmunizationExplanationList = class;
  TFhirImmunizationReaction = class;
  TFhirImmunizationReactionList = class;
  TFhirImmunizationVaccinationProtocol = class;
  TFhirImmunizationVaccinationProtocolList = class;
  TFhirImmunizationProfileRecommendation = class;
  TFhirImmunizationProfileRecommendationList = class;
  TFhirImmunizationProfileRecommendationDateCriterion = class;
  TFhirImmunizationProfileRecommendationDateCriterionList = class;
  TFhirImmunizationProfileRecommendationProtocol = class;
  TFhirImmunizationProfileRecommendationProtocolList = class;
  TFhirImmunizationProfileRecommendationSupportingAdverseEventReport = class;
  TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList = class;
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirLocationPosition = class;
  TFhirLocationPositionList = class;
  TFhirMedicationProduct = class;
  TFhirMedicationProductList = class;
  TFhirMedicationProductIngredient = class;
  TFhirMedicationProductIngredientList = class;
  TFhirMedicationPackage = class;
  TFhirMedicationPackageList = class;
  TFhirMedicationPackageContent = class;
  TFhirMedicationPackageContentList = class;
  TFhirMedicationAdministrationDosage = class;
  TFhirMedicationAdministrationDosageList = class;
  TFhirMedicationDispenseDispense = class;
  TFhirMedicationDispenseDispenseList = class;
  TFhirMedicationDispenseDispenseDosage = class;
  TFhirMedicationDispenseDispenseDosageList = class;
  TFhirMedicationDispenseSubstitution = class;
  TFhirMedicationDispenseSubstitutionList = class;
  TFhirMedicationPrescriptionDosageInstruction = class;
  TFhirMedicationPrescriptionDosageInstructionList = class;
  TFhirMedicationPrescriptionDispense = class;
  TFhirMedicationPrescriptionDispenseList = class;
  TFhirMedicationPrescriptionSubstitution = class;
  TFhirMedicationPrescriptionSubstitutionList = class;
  TFhirMedicationStatementDosage = class;
  TFhirMedicationStatementDosageList = class;
  TFhirMessageResponse = class;
  TFhirMessageResponseList = class;
  TFhirMessageSource = class;
  TFhirMessageSourceList = class;
  TFhirMessageDestination = class;
  TFhirMessageDestinationList = class;
  TFhirObservationReferenceRange = class;
  TFhirObservationReferenceRangeList = class;
  TFhirObservationComponent = class;
  TFhirObservationComponentList = class;
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOrderWhen = class;
  TFhirOrderWhenList = class;
  TFhirOrganizationContact = class;
  TFhirOrganizationContactList = class;
  TFhirPatientContact = class;
  TFhirPatientContactList = class;
  TFhirPatientAnimal = class;
  TFhirPatientAnimalList = class;
  TFhirPractitionerQualification = class;
  TFhirPractitionerQualificationList = class;
  TFhirProcedurePerformer = class;
  TFhirProcedurePerformerList = class;
  TFhirProcedureRelatedItem = class;
  TFhirProcedureRelatedItemList = class;
  TFhirProfileStructure = class;
  TFhirProfileStructureList = class;
  TFhirProfileStructureElement = class;
  TFhirProfileStructureElementList = class;
  TFhirProfileStructureElementSlicing = class;
  TFhirProfileStructureElementSlicingList = class;
  TFhirProfileStructureElementDefinition = class;
  TFhirProfileStructureElementDefinitionList = class;
  TFhirProfileStructureElementDefinitionType = class;
  TFhirProfileStructureElementDefinitionTypeList = class;
  TFhirProfileStructureElementDefinitionConstraint = class;
  TFhirProfileStructureElementDefinitionConstraintList = class;
  TFhirProfileStructureElementDefinitionMapping = class;
  TFhirProfileStructureElementDefinitionMappingList = class;
  TFhirProfileExtensionDefn = class;
  TFhirProfileExtensionDefnList = class;
  TFhirProfileBinding = class;
  TFhirProfileBindingList = class;
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirQueryResponse = class;
  TFhirQueryResponseList = class;
  TFhirQuestionnaireQuestion = class;
  TFhirQuestionnaireQuestionList = class;
  TFhirQuestionnaireGroup = class;
  TFhirQuestionnaireGroupList = class;
  TFhirSecurityEventEvent = class;
  TFhirSecurityEventEventList = class;
  TFhirSecurityEventParticipant = class;
  TFhirSecurityEventParticipantList = class;
  TFhirSecurityEventParticipantNetwork = class;
  TFhirSecurityEventParticipantNetworkList = class;
  TFhirSecurityEventSource = class;
  TFhirSecurityEventSourceList = class;
  TFhirSecurityEventObject = class;
  TFhirSecurityEventObjectList = class;
  TFhirSecurityEventObjectDetail = class;
  TFhirSecurityEventObjectDetailList = class;
  TFhirSpecimenSource = class;
  TFhirSpecimenSourceList = class;
  TFhirSpecimenCollection = class;
  TFhirSpecimenCollectionList = class;
  TFhirSpecimenTreatment = class;
  TFhirSpecimenTreatmentList = class;
  TFhirSpecimenContainer = class;
  TFhirSpecimenContainerList = class;
  TFhirSupplyDispense = class;
  TFhirSupplyDispenseList = class;
  TFhirValueSetDefine = class;
  TFhirValueSetDefineList = class;
  TFhirValueSetDefineConcept = class;
  TFhirValueSetDefineConceptList = class;
  TFhirValueSetCompose = class;
  TFhirValueSetComposeList = class;
  TFhirValueSetComposeInclude = class;
  TFhirValueSetComposeIncludeList = class;
  TFhirValueSetComposeIncludeFilter = class;
  TFhirValueSetComposeIncludeFilterList = class;
  TFhirValueSetExpansion = class;
  TFhirValueSetExpansionList = class;
  TFhirValueSetExpansionContains = class;
  TFhirValueSetExpansionContainsList = class;

  {@Class TFhirAdverseReactionSymptom : TFhirElement
    The signs and symptoms that were observed as part of the reaction.
  }
  {!.Net HL7Connect.Fhir.AdverseReactionSymptom}
  TFhirAdverseReactionSymptom = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FSeverity : TFhirEnum;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirReactionSeverity;
    Procedure SetSeverityST(value : TFhirReactionSeverity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirAdverseReactionSymptom; overload;
    function Clone : TFhirAdverseReactionSymptom; overload;
    {!script show}
  published
    {@member code
      Indicates the specific sign or symptom that was observed.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member severity
      The severity of the sign or symptom.
    }
    property severity : TFhirEnum read FSeverity write SetSeverity;
    {@member severityST
      Typed access to The severity of the sign or symptom.
    }
    property severityST : TFhirReactionSeverity read GetSeverityST write SetSeverityST;

  end;


  {@Class TFhirAdverseReactionSymptomList
    A list of FhirAdverseReactionSymptom
  }
  {!.Net HL7Connect.Fhir.AdverseReactionSymptomList}
  TFhirAdverseReactionSymptomList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseReactionSymptom;
    procedure SetItemN(index : Integer; value : TFhirAdverseReactionSymptom);
  public
    {!script hide}
    function Link : TFhirAdverseReactionSymptomList; Overload;
    function Clone : TFhirAdverseReactionSymptomList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirAdverseReactionSymptom to the end of the list.
    }
    function Append : TFhirAdverseReactionSymptom;

    
    {@member AddItem
      Add an already existing FhirAdverseReactionSymptom to the end of the list.
    }
    procedure AddItem(value : TFhirAdverseReactionSymptom);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirAdverseReactionSymptom) : Integer;
    

    {@member Insert
      Insert FhirAdverseReactionSymptom before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirAdverseReactionSymptom;
    

    {@member InsertItem
       Insert an existing FhirAdverseReactionSymptom before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirAdverseReactionSymptom);
    
    {@member Item
       Get the iIndexth FhirAdverseReactionSymptom. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirAdverseReactionSymptom. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseReactionSymptom);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirAdverseReactionSymptom;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirAdverseReactionSymptoms[index : Integer] : TFhirAdverseReactionSymptom read GetItemN write SetItemN; default;
  End;


  {@Class TFhirAdverseReactionExposure : TFhirElement
    An exposure to a substance that preceded a reaction occurrence.
  }
  {!.Net HL7Connect.Fhir.AdverseReactionExposure}
  TFhirAdverseReactionExposure = class (TFhirElement)
  private
    FExposureDate : TFhirDateTime;
    FExposureType : TFhirEnum;
    FCausalityExpectation : TFhirEnum;
    FSubstance : TFhirResourceReference{TFhirSubstance};
    Procedure SetExposureDate(value : TFhirDateTime);
    Function GetExposureDateST : TDateAndTime;
    Procedure SetExposureDateST(value : TDateAndTime);
    Procedure SetExposureType(value : TFhirEnum);
    Function GetExposureTypeST : TFhirExposureType;
    Procedure SetExposureTypeST(value : TFhirExposureType);
    Procedure SetCausalityExpectation(value : TFhirEnum);
    Function GetCausalityExpectationST : TFhirCausalityExpectation;
    Procedure SetCausalityExpectationST(value : TFhirCausalityExpectation);
    Procedure SetSubstance(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirAdverseReactionExposure; overload;
    function Clone : TFhirAdverseReactionExposure; overload;
    {!script show}
  published
    {@member exposureDate
      When the exposure occurred.
    }
    property exposureDate : TFhirDateTime read FExposureDate write SetExposureDate;
    {@member exposureDateST
      Typed access to When the exposure occurred.
    }
    property exposureDateST : TDateAndTime read GetExposureDateST write SetExposureDateST;

    {@member exposureType
      Drug Administration, Immunization, Coincidental.
    }
    property exposureType : TFhirEnum read FExposureType write SetExposureType;
    {@member exposureTypeST
      Typed access to Drug Administration, Immunization, Coincidental.
    }
    property exposureTypeST : TFhirExposureType read GetExposureTypeST write SetExposureTypeST;

    {@member causalityExpectation
      A statement of how confident that the recorder was that this exposure caused the reaction.
    }
    property causalityExpectation : TFhirEnum read FCausalityExpectation write SetCausalityExpectation;
    {@member causalityExpectationST
      Typed access to A statement of how confident that the recorder was that this exposure caused the reaction.
    }
    property causalityExpectationST : TFhirCausalityExpectation read GetCausalityExpectationST write SetCausalityExpectationST;

    {@member substance
      Substance(s) that is presumed to have caused the adverse reaction.
    }
    property substance : TFhirResourceReference{TFhirSubstance} read FSubstance write SetSubstance;

  end;


  {@Class TFhirAdverseReactionExposureList
    A list of FhirAdverseReactionExposure
  }
  {!.Net HL7Connect.Fhir.AdverseReactionExposureList}
  TFhirAdverseReactionExposureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseReactionExposure;
    procedure SetItemN(index : Integer; value : TFhirAdverseReactionExposure);
  public
    {!script hide}
    function Link : TFhirAdverseReactionExposureList; Overload;
    function Clone : TFhirAdverseReactionExposureList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirAdverseReactionExposure to the end of the list.
    }
    function Append : TFhirAdverseReactionExposure;

    
    {@member AddItem
      Add an already existing FhirAdverseReactionExposure to the end of the list.
    }
    procedure AddItem(value : TFhirAdverseReactionExposure);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirAdverseReactionExposure) : Integer;
    

    {@member Insert
      Insert FhirAdverseReactionExposure before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirAdverseReactionExposure;
    

    {@member InsertItem
       Insert an existing FhirAdverseReactionExposure before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirAdverseReactionExposure);
    
    {@member Item
       Get the iIndexth FhirAdverseReactionExposure. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirAdverseReactionExposure. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseReactionExposure);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirAdverseReactionExposure;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirAdverseReactionExposures[index : Integer] : TFhirAdverseReactionExposure read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanParticipant : TFhirElement
    Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
  }
  {!.Net HL7Connect.Fhir.CarePlanParticipant}
  TFhirCarePlanParticipant = class (TFhirElement)
  private
    FRole : TFhirCodeableConcept;
    FMember : TFhirResourceReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetMember(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanParticipant; overload;
    function Clone : TFhirCarePlanParticipant; overload;
    {!script show}
  published
    {@member role
      Indicates specific responsibility of an individual within the care plan.  E.g. "Primary physician", "Team coordinator", "Caregiver", etc.
    }
    property role : TFhirCodeableConcept read FRole write SetRole;

    {@member member
      The specific person or organization who is participating/expected to participate in the care plan.
    }
    property member : TFhirResourceReference{Resource} read FMember write SetMember;

  end;


  {@Class TFhirCarePlanParticipantList
    A list of FhirCarePlanParticipant
  }
  {!.Net HL7Connect.Fhir.CarePlanParticipantList}
  TFhirCarePlanParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanParticipant;
    procedure SetItemN(index : Integer; value : TFhirCarePlanParticipant);
  public
    {!script hide}
    function Link : TFhirCarePlanParticipantList; Overload;
    function Clone : TFhirCarePlanParticipantList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanParticipant to the end of the list.
    }
    function Append : TFhirCarePlanParticipant;

    
    {@member AddItem
      Add an already existing FhirCarePlanParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanParticipant);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanParticipant) : Integer;
    

    {@member Insert
      Insert FhirCarePlanParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanParticipant;
    

    {@member InsertItem
       Insert an existing FhirCarePlanParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanParticipant);
    
    {@member Item
       Get the iIndexth FhirCarePlanParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanParticipants[index : Integer] : TFhirCarePlanParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanGoal : TFhirElement
    Describes the intended objective(s) of carrying out the Care Plan.
  }
  {!.Net HL7Connect.Fhir.CarePlanGoal}
  TFhirCarePlanGoal = class (TFhirElement)
  private
    FDescription : TFhirString;
    FStatus : TFhirEnum;
    FNotes : TFhirString;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanGoalStatus;
    Procedure SetStatusST(value : TFhirCarePlanGoalStatus);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanGoal; overload;
    function Clone : TFhirCarePlanGoal; overload;
    {!script show}
  published
    {@member description
      Human readable description of a specific desired objective of the care plan.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Human readable description of a specific desired objective of the care plan.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member status
      Indicates whether the goal has been reached and is still considered relevant.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to Indicates whether the goal has been reached and is still considered relevant.
    }
    property statusST : TFhirCarePlanGoalStatus read GetStatusST write SetStatusST;

    {@member notes
      Any comments related to the goal.
    }
    property notes : TFhirString read FNotes write SetNotes;
    {@member notesST
      Typed access to Any comments related to the goal.
    }
    property notesST : String read GetNotesST write SetNotesST;

  end;


  {@Class TFhirCarePlanGoalList
    A list of FhirCarePlanGoal
  }
  {!.Net HL7Connect.Fhir.CarePlanGoalList}
  TFhirCarePlanGoalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanGoal;
    procedure SetItemN(index : Integer; value : TFhirCarePlanGoal);
  public
    {!script hide}
    function Link : TFhirCarePlanGoalList; Overload;
    function Clone : TFhirCarePlanGoalList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanGoal to the end of the list.
    }
    function Append : TFhirCarePlanGoal;

    
    {@member AddItem
      Add an already existing FhirCarePlanGoal to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanGoal);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanGoal) : Integer;
    

    {@member Insert
      Insert FhirCarePlanGoal before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanGoal;
    

    {@member InsertItem
       Insert an existing FhirCarePlanGoal before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanGoal);
    
    {@member Item
       Get the iIndexth FhirCarePlanGoal. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanGoal. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanGoal);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanGoal;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanGoals[index : Integer] : TFhirCarePlanGoal read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanActivity : TFhirElement
    Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
  }
  {!.Net HL7Connect.Fhir.CarePlanActivity}
  TFhirCarePlanActivity = class (TFhirElement)
  private
    FCategory : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FProhibited : TFhirBoolean;
    FTiming : TFhirType;
    FLocation : TFhirResourceReference{TFhirLocation};
    FperformerList : TFhirResourceReferenceList{Resource};
    FProduct : TFhirResourceReference{Resource};
    FDailyAmount : TFhirQuantity;
    FQuantity : TFhirQuantity;
    FDetails : TFhirString;
    FactionTakenList : TFhirResourceReferenceList{Resource};
    FNotes : TFhirString;
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirCarePlanActivityCategory;
    Procedure SetCategoryST(value : TFhirCarePlanActivityCategory);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanActivityStatus;
    Procedure SetStatusST(value : TFhirCarePlanActivityStatus);
    Procedure SetProhibited(value : TFhirBoolean);
    Function GetProhibitedST : String;
    Procedure SetProhibitedST(value : String);
    Procedure SetTiming(value : TFhirType);
    Procedure SetLocation(value : TFhirResourceReference{TFhirLocation});
    Procedure SetProduct(value : TFhirResourceReference{Resource});
    Procedure SetDailyAmount(value : TFhirQuantity);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetDetails(value : TFhirString);
    Function GetDetailsST : String;
    Procedure SetDetailsST(value : String);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanActivity; overload;
    function Clone : TFhirCarePlanActivity; overload;
    {!script show}
  published
    {@member category
      High-level categorization of the type of activity in a care plan.
    }
    property category : TFhirEnum read FCategory write SetCategory;
    {@member categoryST
      Typed access to High-level categorization of the type of activity in a care plan.
    }
    property categoryST : TFhirCarePlanActivityCategory read GetCategoryST write SetCategoryST;

    {@member code
      Detailed description of the type of activity.  E.g. What lab test, what procedure, what kind of encounter.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member status
      Identifies what progress is being made for the specific activity.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to Identifies what progress is being made for the specific activity.
    }
    property statusST : TFhirCarePlanActivityStatus read GetStatusST write SetStatusST;

    {@member prohibited
      If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    }
    property prohibited : TFhirBoolean read FProhibited write SetProhibited;
    {@member prohibitedST
      Typed access to If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    }
    property prohibitedST : String read GetProhibitedST write SetProhibitedST;

    {@member timing
      The period, timing or frequency upon which the described activity is to occur.
    }
    property timing : TFhirType read FTiming write SetTiming;

    {@member location
      Identifies the facility where the activity will occur.  E.g. home, hospital, specific clinic, etc.
    }
    property location : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;

    {@member performerList
      Identifies who's expected to be involved in the activity.
    }
    property performerList : TFhirResourceReferenceList{Resource} read FPerformerList;

    {@member product
      Identifies the food, drug or other product being consumed or supplied in the activity.
    }
    property product : TFhirResourceReference{Resource} read FProduct write SetProduct;

    {@member dailyAmount
      Identifies the quantity expected to be consumed in a given day.
    }
    property dailyAmount : TFhirQuantity read FDailyAmount write SetDailyAmount;

    {@member quantity
      Identifies the quantity expected to be supplied.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member details
      This provides a textual description of constraints on the activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    }
    property details : TFhirString read FDetails write SetDetails;
    {@member detailsST
      Typed access to This provides a textual description of constraints on the activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    }
    property detailsST : String read GetDetailsST write SetDetailsST;

    {@member actionTakenList
      Resources that describe follow-on actions resulting from the plan, such as drug prescriptions, encounter records, appointments, etc.
    }
    property actionTakenList : TFhirResourceReferenceList{Resource} read FActionTakenList;

    {@member notes
      Notes about the execution of the activity.
    }
    property notes : TFhirString read FNotes write SetNotes;
    {@member notesST
      Typed access to Notes about the execution of the activity.
    }
    property notesST : String read GetNotesST write SetNotesST;

  end;


  {@Class TFhirCarePlanActivityList
    A list of FhirCarePlanActivity
  }
  {!.Net HL7Connect.Fhir.CarePlanActivityList}
  TFhirCarePlanActivityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivity;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivity);
  public
    {!script hide}
    function Link : TFhirCarePlanActivityList; Overload;
    function Clone : TFhirCarePlanActivityList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanActivity to the end of the list.
    }
    function Append : TFhirCarePlanActivity;

    
    {@member AddItem
      Add an already existing FhirCarePlanActivity to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanActivity);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanActivity) : Integer;
    

    {@member Insert
      Insert FhirCarePlanActivity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanActivity;
    

    {@member InsertItem
       Insert an existing FhirCarePlanActivity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivity);
    
    {@member Item
       Get the iIndexth FhirCarePlanActivity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanActivity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanActivity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanActivities[index : Integer] : TFhirCarePlanActivity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionStage : TFhirElement
    Clinical stage or grade of a condition. May include formal severity assessments.
  }
  {!.Net HL7Connect.Fhir.ConditionStage}
  TFhirConditionStage = class (TFhirElement)
  private
    FSummary : TFhirCodeableConcept;
    FassessmentList : TFhirResourceReferenceList{Resource};
    Procedure SetSummary(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionStage; overload;
    function Clone : TFhirConditionStage; overload;
    {!script show}
  published
    {@member summary
      A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    }
    property summary : TFhirCodeableConcept read FSummary write SetSummary;

    {@member assessmentList
      Reference to a formal record of the evidence on which the staging assessment is based.
    }
    property assessmentList : TFhirResourceReferenceList{Resource} read FAssessmentList;

  end;


  {@Class TFhirConditionStageList
    A list of FhirConditionStage
  }
  {!.Net HL7Connect.Fhir.ConditionStageList}
  TFhirConditionStageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionStage;
    procedure SetItemN(index : Integer; value : TFhirConditionStage);
  public
    {!script hide}
    function Link : TFhirConditionStageList; Overload;
    function Clone : TFhirConditionStageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionStage to the end of the list.
    }
    function Append : TFhirConditionStage;

    
    {@member AddItem
      Add an already existing FhirConditionStage to the end of the list.
    }
    procedure AddItem(value : TFhirConditionStage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionStage) : Integer;
    

    {@member Insert
      Insert FhirConditionStage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionStage;
    

    {@member InsertItem
       Insert an existing FhirConditionStage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionStage);
    
    {@member Item
       Get the iIndexth FhirConditionStage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionStage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionStage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionStage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionStages[index : Integer] : TFhirConditionStage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionEvidence : TFhirElement
    Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
  }
  {!.Net HL7Connect.Fhir.ConditionEvidence}
  TFhirConditionEvidence = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FdetailList : TFhirResourceReferenceList{Resource};
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionEvidence; overload;
    function Clone : TFhirConditionEvidence; overload;
    {!script show}
  published
    {@member code
      A manifestation or symptom that led to the recording of this condition.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member detailList
      Links to other relevant information, including pathology reports.
    }
    property detailList : TFhirResourceReferenceList{Resource} read FDetailList;

  end;


  {@Class TFhirConditionEvidenceList
    A list of FhirConditionEvidence
  }
  {!.Net HL7Connect.Fhir.ConditionEvidenceList}
  TFhirConditionEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionEvidence;
    procedure SetItemN(index : Integer; value : TFhirConditionEvidence);
  public
    {!script hide}
    function Link : TFhirConditionEvidenceList; Overload;
    function Clone : TFhirConditionEvidenceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionEvidence to the end of the list.
    }
    function Append : TFhirConditionEvidence;

    
    {@member AddItem
      Add an already existing FhirConditionEvidence to the end of the list.
    }
    procedure AddItem(value : TFhirConditionEvidence);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionEvidence) : Integer;
    

    {@member Insert
      Insert FhirConditionEvidence before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionEvidence;
    

    {@member InsertItem
       Insert an existing FhirConditionEvidence before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionEvidence);
    
    {@member Item
       Get the iIndexth FhirConditionEvidence. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionEvidence. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionEvidence);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionEvidence;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionEvidences[index : Integer] : TFhirConditionEvidence read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionLocation : TFhirElement
    The anatomical location where this condition manifests itself.
  }
  {!.Net HL7Connect.Fhir.ConditionLocation}
  TFhirConditionLocation = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FDetail : TFhirString;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDetail(value : TFhirString);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionLocation; overload;
    function Clone : TFhirConditionLocation; overload;
    {!script show}
  published
    {@member code
      Code that identifies the structural location.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member detail
      Detailed anatomical location information.
    }
    property detail : TFhirString read FDetail write SetDetail;
    {@member detailST
      Typed access to Detailed anatomical location information.
    }
    property detailST : String read GetDetailST write SetDetailST;

  end;


  {@Class TFhirConditionLocationList
    A list of FhirConditionLocation
  }
  {!.Net HL7Connect.Fhir.ConditionLocationList}
  TFhirConditionLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionLocation;
    procedure SetItemN(index : Integer; value : TFhirConditionLocation);
  public
    {!script hide}
    function Link : TFhirConditionLocationList; Overload;
    function Clone : TFhirConditionLocationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionLocation to the end of the list.
    }
    function Append : TFhirConditionLocation;

    
    {@member AddItem
      Add an already existing FhirConditionLocation to the end of the list.
    }
    procedure AddItem(value : TFhirConditionLocation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionLocation) : Integer;
    

    {@member Insert
      Insert FhirConditionLocation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionLocation;
    

    {@member InsertItem
       Insert an existing FhirConditionLocation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionLocation);
    
    {@member Item
       Get the iIndexth FhirConditionLocation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionLocation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionLocation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionLocation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionLocations[index : Integer] : TFhirConditionLocation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionRelatedItem : TFhirElement
    Further conditions, problems, diagnoses, procedures or events that are related in some way to this condition, or the substance that caused/triggered this Condition.
  }
  {!.Net HL7Connect.Fhir.ConditionRelatedItem}
  TFhirConditionRelatedItem = class (TFhirElement)
  private
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FTarget : TFhirResourceReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirConditionRelationshipType;
    Procedure SetType_ST(value : TFhirConditionRelationshipType);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTarget(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionRelatedItem; overload;
    function Clone : TFhirConditionRelatedItem; overload;
    {!script show}
  published
    {@member type_
      The type of relationship that this condition has to the related item.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The type of relationship that this condition has to the related item.
    }
    property type_ST : TFhirConditionRelationshipType read GetType_ST write SetType_ST;

    {@member code
      Code that identifies the target of this relationship. The code takes the place of a detailed instance target.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member target
      Target of the relationship.
    }
    property target : TFhirResourceReference{Resource} read FTarget write SetTarget;

  end;


  {@Class TFhirConditionRelatedItemList
    A list of FhirConditionRelatedItem
  }
  {!.Net HL7Connect.Fhir.ConditionRelatedItemList}
  TFhirConditionRelatedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionRelatedItem;
    procedure SetItemN(index : Integer; value : TFhirConditionRelatedItem);
  public
    {!script hide}
    function Link : TFhirConditionRelatedItemList; Overload;
    function Clone : TFhirConditionRelatedItemList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionRelatedItem to the end of the list.
    }
    function Append : TFhirConditionRelatedItem;

    
    {@member AddItem
      Add an already existing FhirConditionRelatedItem to the end of the list.
    }
    procedure AddItem(value : TFhirConditionRelatedItem);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionRelatedItem) : Integer;
    

    {@member Insert
      Insert FhirConditionRelatedItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionRelatedItem;
    

    {@member InsertItem
       Insert an existing FhirConditionRelatedItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionRelatedItem);
    
    {@member Item
       Get the iIndexth FhirConditionRelatedItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionRelatedItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionRelatedItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionRelatedItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionRelatedItems[index : Integer] : TFhirConditionRelatedItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceSoftware : TFhirElement
    Describes the software that is covered by this conformance statement.  Used when the profile describes the capabilities of a particular software version, independent of an installation.
  }
  {!.Net HL7Connect.Fhir.ConformanceSoftware}
  TFhirConformanceSoftware = class (TFhirElement)
  private
    FName : TFhirString;
    FVersion : TFhirString;
    FReleaseDate : TFhirDateTime;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetReleaseDate(value : TFhirDateTime);
    Function GetReleaseDateST : TDateAndTime;
    Procedure SetReleaseDateST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceSoftware; overload;
    function Clone : TFhirConformanceSoftware; overload;
    {!script show}
  published
    {@member name
      Name software is known by.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Name software is known by.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member version
      Version covered by this statement.
    }
    property version : TFhirString read FVersion write SetVersion;
    {@member versionST
      Typed access to Version covered by this statement.
    }
    property versionST : String read GetVersionST write SetVersionST;

    {@member releaseDate
      Date this version of the software released.
    }
    property releaseDate : TFhirDateTime read FReleaseDate write SetReleaseDate;
    {@member releaseDateST
      Typed access to Date this version of the software released.
    }
    property releaseDateST : TDateAndTime read GetReleaseDateST write SetReleaseDateST;

  end;


  {@Class TFhirConformanceSoftwareList
    A list of FhirConformanceSoftware
  }
  {!.Net HL7Connect.Fhir.ConformanceSoftwareList}
  TFhirConformanceSoftwareList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceSoftware;
    procedure SetItemN(index : Integer; value : TFhirConformanceSoftware);
  public
    {!script hide}
    function Link : TFhirConformanceSoftwareList; Overload;
    function Clone : TFhirConformanceSoftwareList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceSoftware to the end of the list.
    }
    function Append : TFhirConformanceSoftware;

    
    {@member AddItem
      Add an already existing FhirConformanceSoftware to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceSoftware);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceSoftware) : Integer;
    

    {@member Insert
      Insert FhirConformanceSoftware before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceSoftware;
    

    {@member InsertItem
       Insert an existing FhirConformanceSoftware before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceSoftware);
    
    {@member Item
       Get the iIndexth FhirConformanceSoftware. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceSoftware. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceSoftware);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceSoftware;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceSoftwares[index : Integer] : TFhirConformanceSoftware read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceImplementation : TFhirElement
    Used when the statement describes the capabilities of a specific implementation instance - i.e. a particular installation, rather than the capabilities of a software program.
  }
  {!.Net HL7Connect.Fhir.ConformanceImplementation}
  TFhirConformanceImplementation = class (TFhirElement)
  private
    FDescription : TFhirString;
    FUrl : TFhirUri;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceImplementation; overload;
    function Clone : TFhirConformanceImplementation; overload;
    {!script show}
  published
    {@member description
      Information about the specific installation that this conformance statement relates to.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Information about the specific installation that this conformance statement relates to.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member url
      The base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    }
    property url : TFhirUri read FUrl write SetUrl;
    {@member urlST
      Typed access to The base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    }
    property urlST : String read GetUrlST write SetUrlST;

  end;


  {@Class TFhirConformanceImplementationList
    A list of FhirConformanceImplementation
  }
  {!.Net HL7Connect.Fhir.ConformanceImplementationList}
  TFhirConformanceImplementationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceImplementation;
    procedure SetItemN(index : Integer; value : TFhirConformanceImplementation);
  public
    {!script hide}
    function Link : TFhirConformanceImplementationList; Overload;
    function Clone : TFhirConformanceImplementationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceImplementation to the end of the list.
    }
    function Append : TFhirConformanceImplementation;

    
    {@member AddItem
      Add an already existing FhirConformanceImplementation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceImplementation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceImplementation) : Integer;
    

    {@member Insert
      Insert FhirConformanceImplementation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceImplementation;
    

    {@member InsertItem
       Insert an existing FhirConformanceImplementation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceImplementation);
    
    {@member Item
       Get the iIndexth FhirConformanceImplementation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceImplementation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceImplementation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceImplementation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceImplementations[index : Integer] : TFhirConformanceImplementation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRest : TFhirElement
    Defines the restful capabilities of the solution, if any.
  }
  {!.Net HL7Connect.Fhir.ConformanceRest}
  TFhirConformanceRest = class (TFhirElement)
  private
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FSecurity : TFhirConformanceRestSecurity;
    FresourceList : TFhirConformanceRestResourceList;
    FBatch : TFhirBoolean;
    FHistory : TFhirBoolean;
    FqueryList : TFhirConformanceRestQueryList;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirRestfulConformanceMode;
    Procedure SetModeST(value : TFhirRestfulConformanceMode);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetSecurity(value : TFhirConformanceRestSecurity);
    Procedure SetBatch(value : TFhirBoolean);
    Function GetBatchST : String;
    Procedure SetBatchST(value : String);
    Procedure SetHistory(value : TFhirBoolean);
    Function GetHistoryST : String;
    Procedure SetHistoryST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRest; overload;
    function Clone : TFhirConformanceRest; overload;
    {!script show}
  published
    {@member mode
      Identifies whether this portion of the statement is describing ability to initiate or receive restful operations.
    }
    property mode : TFhirEnum read FMode write SetMode;
    {@member modeST
      Typed access to Identifies whether this portion of the statement is describing ability to initiate or receive restful operations.
    }
    property modeST : TFhirRestfulConformanceMode read GetModeST write SetModeST;

    {@member documentation
      Provides documentation about the system's restful capabilities that apply across all applications, such as security.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Provides documentation about the system's restful capabilities that apply across all applications, such as security.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member security
      Information about security of implementation.
    }
    property security : TFhirConformanceRestSecurity read FSecurity write SetSecurity;

    {@member resourceList
      Identifies the restful capabilities of the solution for a specific resource type.
    }
    property resourceList : TFhirConformanceRestResourceList read FResourceList;

    {@member batch
      If batches are supported.
    }
    property batch : TFhirBoolean read FBatch write SetBatch;
    {@member batchST
      Typed access to If batches are supported.
    }
    property batchST : String read GetBatchST write SetBatchST;

    {@member history
      If a system wide history list is supported.
    }
    property history : TFhirBoolean read FHistory write SetHistory;
    {@member historyST
      Typed access to If a system wide history list is supported.
    }
    property historyST : String read GetHistoryST write SetHistoryST;

    {@member queryList
      Definition of a named query and its parameters and their meaning.
    }
    property queryList : TFhirConformanceRestQueryList read FQueryList;

  end;


  {@Class TFhirConformanceRestList
    A list of FhirConformanceRest
  }
  {!.Net HL7Connect.Fhir.ConformanceRestList}
  TFhirConformanceRestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRest;
    procedure SetItemN(index : Integer; value : TFhirConformanceRest);
  public
    {!script hide}
    function Link : TFhirConformanceRestList; Overload;
    function Clone : TFhirConformanceRestList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRest to the end of the list.
    }
    function Append : TFhirConformanceRest;

    
    {@member AddItem
      Add an already existing FhirConformanceRest to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRest);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRest) : Integer;
    

    {@member Insert
      Insert FhirConformanceRest before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRest;
    

    {@member InsertItem
       Insert an existing FhirConformanceRest before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRest);
    
    {@member Item
       Get the iIndexth FhirConformanceRest. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRest. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRest);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRest;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRests[index : Integer] : TFhirConformanceRest read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestSecurity : TFhirElement
    Information about security of implementation.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurity}
  TFhirConformanceRestSecurity = class (TFhirElement)
  private
    FserviceList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FcertificateList : TFhirConformanceRestSecurityCertificateList;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestSecurity; overload;
    function Clone : TFhirConformanceRestSecurity; overload;
    {!script show}
  published
    {@member serviceList
      What type of security services are supported/required.
    }
    property serviceList : TFhirCodeableConceptList read FServiceList;

    {@member description
      General description of how security works.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to General description of how security works.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member certificateList
      Certificates associated with security profiles.
    }
    property certificateList : TFhirConformanceRestSecurityCertificateList read FCertificateList;

  end;


  {@Class TFhirConformanceRestSecurityList
    A list of FhirConformanceRestSecurity
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityList}
  TFhirConformanceRestSecurityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestSecurity;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurity);
  public
    {!script hide}
    function Link : TFhirConformanceRestSecurityList; Overload;
    function Clone : TFhirConformanceRestSecurityList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestSecurity to the end of the list.
    }
    function Append : TFhirConformanceRestSecurity;

    
    {@member AddItem
      Add an already existing FhirConformanceRestSecurity to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestSecurity);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestSecurity) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestSecurity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestSecurity;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestSecurity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurity);
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestSecurity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestSecurities[index : Integer] : TFhirConformanceRestSecurity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestSecurityCertificate : TFhirElement
    Certificates associated with security profiles.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityCertificate}
  TFhirConformanceRestSecurityCertificate = class (TFhirElement)
  private
    FType_ : TFhirCode;
    FBlob : TFhirBase64Binary;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetBlob(value : TFhirBase64Binary);
    Function GetBlobST : String;
    Procedure SetBlobST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestSecurityCertificate; overload;
    function Clone : TFhirConformanceRestSecurityCertificate; overload;
    {!script show}
  published
    {@member type_
      Mime type for certificate.
    }
    property type_ : TFhirCode read FType_ write SetType_;
    {@member type_ST
      Typed access to Mime type for certificate.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member blob
      Actual certificate.
    }
    property blob : TFhirBase64Binary read FBlob write SetBlob;
    {@member blobST
      Typed access to Actual certificate.
    }
    property blobST : String read GetBlobST write SetBlobST;

  end;


  {@Class TFhirConformanceRestSecurityCertificateList
    A list of FhirConformanceRestSecurityCertificate
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityCertificateList}
  TFhirConformanceRestSecurityCertificateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestSecurityCertificate;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurityCertificate);
  public
    {!script hide}
    function Link : TFhirConformanceRestSecurityCertificateList; Overload;
    function Clone : TFhirConformanceRestSecurityCertificateList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestSecurityCertificate to the end of the list.
    }
    function Append : TFhirConformanceRestSecurityCertificate;

    
    {@member AddItem
      Add an already existing FhirConformanceRestSecurityCertificate to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestSecurityCertificate);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestSecurityCertificate) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestSecurityCertificate;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurityCertificate. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurityCertificate. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestSecurityCertificate;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestSecurityCertificates[index : Integer] : TFhirConformanceRestSecurityCertificate read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResource : TFhirElement
    Identifies the restful capabilities of the solution for a specific resource type.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResource}
  TFhirConformanceRestResource = class (TFhirElement)
  private
    FType_ : TFhirCode;
    FProfile : TFhirResourceReference{TFhirProfile};
    FoperationList : TFhirConformanceRestResourceOperationList;
    FReadHistory : TFhirBoolean;
    FsearchIncludeList : TFhirStringList;
    FsearchParamList : TFhirConformanceRestResourceSearchParamList;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetProfile(value : TFhirResourceReference{TFhirProfile});
    Procedure SetReadHistory(value : TFhirBoolean);
    Function GetReadHistoryST : String;
    Procedure SetReadHistoryST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResource; overload;
    function Clone : TFhirConformanceRestResource; overload;
    {!script show}
  published
    {@member type_
      Identifies the resource exposed via the restful interface.
    }
    property type_ : TFhirCode read FType_ write SetType_;
    {@member type_ST
      Typed access to Identifies the resource exposed via the restful interface.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member profile
      Identifies the profile that describes the solution's support for the resource, including any constraints on cardinality, bindings, lengths or other limitations.
    }
    property profile : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;

    {@member operationList
      Identifies a restful operation supported by the solution.
    }
    property operationList : TFhirConformanceRestResourceOperationList read FOperationList;

    {@member readHistory
      A flag for whether the server is able to return past versions as part of the vRead operation.
    }
    property readHistory : TFhirBoolean read FReadHistory write SetReadHistory;
    {@member readHistoryST
      Typed access to A flag for whether the server is able to return past versions as part of the vRead operation.
    }
    property readHistoryST : String read GetReadHistoryST write SetReadHistoryST;

    {@member searchIncludeList
      _include values supported by the server.
    }
    property searchIncludeList : TFhirStringList read FSearchIncludeList;

    {@member searchParamList
      Defines additional search parameters for implementations to support and/or make use of.
    }
    property searchParamList : TFhirConformanceRestResourceSearchParamList read FSearchParamList;

  end;


  {@Class TFhirConformanceRestResourceList
    A list of FhirConformanceRestResource
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceList}
  TFhirConformanceRestResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResource;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResource);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceList; Overload;
    function Clone : TFhirConformanceRestResourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResource to the end of the list.
    }
    function Append : TFhirConformanceRestResource;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResource to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResource) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResource;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResource);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResources[index : Integer] : TFhirConformanceRestResource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResourceOperation : TFhirElement
    Identifies a restful operation supported by the solution.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceOperation}
  TFhirConformanceRestResourceOperation = class (TFhirElement)
  private
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirRestfulOperation;
    Procedure SetCodeST(value : TFhirRestfulOperation);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResourceOperation; overload;
    function Clone : TFhirConformanceRestResourceOperation; overload;
    {!script show}
  published
    {@member code
      Identifies which operation is supported.
    }
    property code : TFhirEnum read FCode write SetCode;
    {@member codeST
      Typed access to Identifies which operation is supported.
    }
    property codeST : TFhirRestfulOperation read GetCodeST write SetCodeST;

    {@member documentation
      Provides guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Provides guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

  end;


  {@Class TFhirConformanceRestResourceOperationList
    A list of FhirConformanceRestResourceOperation
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceOperationList}
  TFhirConformanceRestResourceOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResourceOperation;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceOperation);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceOperationList; Overload;
    function Clone : TFhirConformanceRestResourceOperationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResourceOperation to the end of the list.
    }
    function Append : TFhirConformanceRestResourceOperation;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResourceOperation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResourceOperation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResourceOperation) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResourceOperation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResourceOperation;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResourceOperation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceOperation);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceOperation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceOperation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceOperation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResourceOperation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResourceOperations[index : Integer] : TFhirConformanceRestResourceOperation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResourceSearchParam : TFhirElement
    Defines additional search parameters for implementations to support and/or make use of.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceSearchParam}
  TFhirConformanceRestResourceSearchParam = class (TFhirElement)
  private
    FName : TFhirString;
    FSource : TFhirUri;
    FType_ : TFhirEnum;
    FDocumentation : TFhirString;
    FXpath : TFhirString;
    FtargetList : TFhirCodeList;
    FchainList : TFhirStringList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSource(value : TFhirUri);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamType;
    Procedure SetType_ST(value : TFhirSearchParamType);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResourceSearchParam; overload;
    function Clone : TFhirConformanceRestResourceSearchParam; overload;
    {!script show}
  published
    {@member name
      Corresponds to the name of the standard or custom search parameter.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Corresponds to the name of the standard or custom search parameter.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member source
      A formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter.
    }
    property source : TFhirUri read FSource write SetSource;
    {@member sourceST
      Typed access to A formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter.
    }
    property sourceST : String read GetSourceST write SetSourceST;

    {@member type_
      The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ST : TFhirSearchParamType read GetType_ST write SetType_ST;

    {@member documentation
      For standard parameters, provides additional information on how the parameter is used in this solution.  For custom parameters, provides a description of what the parameter does.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to For standard parameters, provides additional information on how the parameter is used in this solution.  For custom parameters, provides a description of what the parameter does.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member xpath
      An XPath expression that extracts the set of elements that contain values that a search parameter matches.
    }
    property xpath : TFhirString read FXpath write SetXpath;
    {@member xpathST
      Typed access to An XPath expression that extracts the set of elements that contain values that a search parameter matches.
    }
    property xpathST : String read GetXpathST write SetXpathST;

    {@member targetList
      Types of resource (if a resource reference).
    }
    property targetList : TFhirCodeList read FTargetList;

    {@member chainList
      Chained names supported.
    }
    property chainList : TFhirStringList read FChainList;

  end;


  {@Class TFhirConformanceRestResourceSearchParamList
    A list of FhirConformanceRestResourceSearchParam
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceSearchParamList}
  TFhirConformanceRestResourceSearchParamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResourceSearchParam;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceSearchParam);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceSearchParamList; Overload;
    function Clone : TFhirConformanceRestResourceSearchParamList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResourceSearchParam to the end of the list.
    }
    function Append : TFhirConformanceRestResourceSearchParam;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResourceSearchParam to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResourceSearchParam);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResourceSearchParam) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResourceSearchParam;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceSearchParam. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceSearchParam. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResourceSearchParam;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResourceSearchParams[index : Integer] : TFhirConformanceRestResourceSearchParam read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestQuery : TFhirElement
    Definition of a named query and its parameters and their meaning.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestQuery}
  TFhirConformanceRestQuery = class (TFhirElement)
  private
    FName : TFhirString;
    FDocumentation : TFhirString;
    FparameterList : TFhirConformanceRestResourceSearchParamList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestQuery; overload;
    function Clone : TFhirConformanceRestQuery; overload;
    {!script show}
  published
    {@member name
      The name of this query, which is used in the _query parameter when the query is used.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of this query, which is used in the _query parameter when the query is used.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member documentation
      Description of the query - the functionality it offers, and considerations about how it functions and to use it.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Description of the query - the functionality it offers, and considerations about how it functions and to use it.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member parameterList
      Parameter for the named query.
    }
    property parameterList : TFhirConformanceRestResourceSearchParamList read FParameterList;

  end;


  {@Class TFhirConformanceRestQueryList
    A list of FhirConformanceRestQuery
  }
  {!.Net HL7Connect.Fhir.ConformanceRestQueryList}
  TFhirConformanceRestQueryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestQuery;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestQuery);
  public
    {!script hide}
    function Link : TFhirConformanceRestQueryList; Overload;
    function Clone : TFhirConformanceRestQueryList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestQuery to the end of the list.
    }
    function Append : TFhirConformanceRestQuery;

    
    {@member AddItem
      Add an already existing FhirConformanceRestQuery to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestQuery);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestQuery) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestQuery before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestQuery;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestQuery before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestQuery);
    
    {@member Item
       Get the iIndexth FhirConformanceRestQuery. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestQuery. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestQuery);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestQuery;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestQueries[index : Integer] : TFhirConformanceRestQuery read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceMessaging : TFhirElement
    Describes the messaging capabilities of the solution.
  }
  {!.Net HL7Connect.Fhir.ConformanceMessaging}
  TFhirConformanceMessaging = class (TFhirElement)
  private
    FEndpoint : TFhirUri;
    FReliableCache : TFhirInteger;
    FDocumentation : TFhirString;
    FeventList : TFhirConformanceMessagingEventList;
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
    Procedure SetReliableCache(value : TFhirInteger);
    Function GetReliableCacheST : String;
    Procedure SetReliableCacheST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceMessaging; overload;
    function Clone : TFhirConformanceMessaging; overload;
    {!script show}
  published
    {@member endpoint
      The address to which messages and/or replies are to be sent.
    }
    property endpoint : TFhirUri read FEndpoint write SetEndpoint;
    {@member endpointST
      Typed access to The address to which messages and/or replies are to be sent.
    }
    property endpointST : String read GetEndpointST write SetEndpointST;

    {@member reliableCache
      The length if the receiver's reliable messaging cache length (if a receiver) or how long the cache length on the receiver should be (if a sender).
    }
    property reliableCache : TFhirInteger read FReliableCache write SetReliableCache;
    {@member reliableCacheST
      Typed access to The length if the receiver's reliable messaging cache length (if a receiver) or how long the cache length on the receiver should be (if a sender).
    }
    property reliableCacheST : String read GetReliableCacheST write SetReliableCacheST;

    {@member documentation
      Provides documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Provides documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member eventList
      Describes the solution's support for an event at this end point.
    }
    property eventList : TFhirConformanceMessagingEventList read FEventList;

  end;


  {@Class TFhirConformanceMessagingList
    A list of FhirConformanceMessaging
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingList}
  TFhirConformanceMessagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceMessaging;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessaging);
  public
    {!script hide}
    function Link : TFhirConformanceMessagingList; Overload;
    function Clone : TFhirConformanceMessagingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceMessaging to the end of the list.
    }
    function Append : TFhirConformanceMessaging;

    
    {@member AddItem
      Add an already existing FhirConformanceMessaging to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceMessaging);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceMessaging) : Integer;
    

    {@member Insert
      Insert FhirConformanceMessaging before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceMessaging;
    

    {@member InsertItem
       Insert an existing FhirConformanceMessaging before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceMessaging);
    
    {@member Item
       Get the iIndexth FhirConformanceMessaging. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceMessaging. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessaging);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceMessaging;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceMessagings[index : Integer] : TFhirConformanceMessaging read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceMessagingEvent : TFhirElement
    Describes the solution's support for an event at this end point.
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingEvent}
  TFhirConformanceMessagingEvent = class (TFhirElement)
  private
    FCode : TFhirCode;
    FMode : TFhirEnum;
    FprotocolList : TFhirCodingList;
    FFocus : TFhirCode;
    FRequest : TFhirResourceReference{TFhirProfile};
    FResponse : TFhirResourceReference{TFhirProfile};
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirMessageConformanceEventMode;
    Procedure SetModeST(value : TFhirMessageConformanceEventMode);
    Procedure SetFocus(value : TFhirCode);
    Function GetFocusST : String;
    Procedure SetFocusST(value : String);
    Procedure SetRequest(value : TFhirResourceReference{TFhirProfile});
    Procedure SetResponse(value : TFhirResourceReference{TFhirProfile});
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceMessagingEvent; overload;
    function Clone : TFhirConformanceMessagingEvent; overload;
    {!script show}
  published
    {@member code
      Identifies the supported messaging event.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Identifies the supported messaging event.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member mode
      The mode of this event declaration - whether application is sender or receiver.
    }
    property mode : TFhirEnum read FMode write SetMode;
    {@member modeST
      Typed access to The mode of this event declaration - whether application is sender or receiver.
    }
    property modeST : TFhirMessageConformanceEventMode read GetModeST write SetModeST;

    {@member protocolList
      Identifies the messaging transport protocol(s) supported by this endpoint.
    }
    property protocolList : TFhirCodingList read FProtocolList;

    {@member focus
      Identifies the resource associated with the event.  This is the resource that defines the event.
    }
    property focus : TFhirCode read FFocus write SetFocus;
    {@member focusST
      Typed access to Identifies the resource associated with the event.  This is the resource that defines the event.
    }
    property focusST : String read GetFocusST write SetFocusST;

    {@member request
      Information about the request for this event.
    }
    property request : TFhirResourceReference{TFhirProfile} read FRequest write SetRequest;

    {@member response
      Information about the response for this event.
    }
    property response : TFhirResourceReference{TFhirProfile} read FResponse write SetResponse;

    {@member documentation
      Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

  end;


  {@Class TFhirConformanceMessagingEventList
    A list of FhirConformanceMessagingEvent
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingEventList}
  TFhirConformanceMessagingEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceMessagingEvent;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessagingEvent);
  public
    {!script hide}
    function Link : TFhirConformanceMessagingEventList; Overload;
    function Clone : TFhirConformanceMessagingEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceMessagingEvent to the end of the list.
    }
    function Append : TFhirConformanceMessagingEvent;

    
    {@member AddItem
      Add an already existing FhirConformanceMessagingEvent to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceMessagingEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceMessagingEvent) : Integer;
    

    {@member Insert
      Insert FhirConformanceMessagingEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceMessagingEvent;
    

    {@member InsertItem
       Insert an existing FhirConformanceMessagingEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceMessagingEvent);
    
    {@member Item
       Get the iIndexth FhirConformanceMessagingEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceMessagingEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessagingEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceMessagingEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceMessagingEvents[index : Integer] : TFhirConformanceMessagingEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceDocument : TFhirElement
    A document definition.
  }
  {!.Net HL7Connect.Fhir.ConformanceDocument}
  TFhirConformanceDocument = class (TFhirElement)
  private
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FProfile : TFhirResourceReference{TFhirProfile};
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirDocumentMode;
    Procedure SetModeST(value : TFhirDocumentMode);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetProfile(value : TFhirResourceReference{TFhirProfile});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceDocument; overload;
    function Clone : TFhirConformanceDocument; overload;
    {!script show}
  published
    {@member mode
      The mode of this event declaration - whether application is sender or receiver.
    }
    property mode : TFhirEnum read FMode write SetMode;
    {@member modeST
      Typed access to The mode of this event declaration - whether application is sender or receiver.
    }
    property modeST : TFhirDocumentMode read GetModeST write SetModeST;

    {@member documentation
      Describes how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Describes how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member profile
      Constraint on a resource used in the document.
    }
    property profile : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;

  end;


  {@Class TFhirConformanceDocumentList
    A list of FhirConformanceDocument
  }
  {!.Net HL7Connect.Fhir.ConformanceDocumentList}
  TFhirConformanceDocumentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceDocument;
    procedure SetItemN(index : Integer; value : TFhirConformanceDocument);
  public
    {!script hide}
    function Link : TFhirConformanceDocumentList; Overload;
    function Clone : TFhirConformanceDocumentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceDocument to the end of the list.
    }
    function Append : TFhirConformanceDocument;

    
    {@member AddItem
      Add an already existing FhirConformanceDocument to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceDocument);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceDocument) : Integer;
    

    {@member Insert
      Insert FhirConformanceDocument before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceDocument;
    

    {@member InsertItem
       Insert an existing FhirConformanceDocument before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceDocument);
    
    {@member Item
       Get the iIndexth FhirConformanceDocument. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceDocument. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceDocument);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceDocument;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceDocuments[index : Integer] : TFhirConformanceDocument read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCoverageSubscriber : TFhirElement
    Planholder information.
  }
  {!.Net HL7Connect.Fhir.CoverageSubscriber}
  TFhirCoverageSubscriber = class (TFhirElement)
  private
    FName : TFhirHumanName;
    FAddress : TFhirAddress;
    FBirthdate : TFhirDate;
    Procedure SetName(value : TFhirHumanName);
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetBirthdate(value : TFhirDate);
    Function GetBirthdateST : TDateAndTime;
    Procedure SetBirthdateST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCoverageSubscriber; overload;
    function Clone : TFhirCoverageSubscriber; overload;
    {!script show}
  published
    {@member name
      The name of the PolicyHolder.
    }
    property name : TFhirHumanName read FName write SetName;

    {@member address
      The mailing address, typically home, of the PolicyHolder.
    }
    property address : TFhirAddress read FAddress write SetAddress;

    {@member birthdate
      The date of birth of the PolicyHolder.
    }
    property birthdate : TFhirDate read FBirthdate write SetBirthdate;
    {@member birthdateST
      Typed access to The date of birth of the PolicyHolder.
    }
    property birthdateST : TDateAndTime read GetBirthdateST write SetBirthdateST;

  end;


  {@Class TFhirCoverageSubscriberList
    A list of FhirCoverageSubscriber
  }
  {!.Net HL7Connect.Fhir.CoverageSubscriberList}
  TFhirCoverageSubscriberList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageSubscriber;
    procedure SetItemN(index : Integer; value : TFhirCoverageSubscriber);
  public
    {!script hide}
    function Link : TFhirCoverageSubscriberList; Overload;
    function Clone : TFhirCoverageSubscriberList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCoverageSubscriber to the end of the list.
    }
    function Append : TFhirCoverageSubscriber;

    
    {@member AddItem
      Add an already existing FhirCoverageSubscriber to the end of the list.
    }
    procedure AddItem(value : TFhirCoverageSubscriber);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCoverageSubscriber) : Integer;
    

    {@member Insert
      Insert FhirCoverageSubscriber before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCoverageSubscriber;
    

    {@member InsertItem
       Insert an existing FhirCoverageSubscriber before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCoverageSubscriber);
    
    {@member Item
       Get the iIndexth FhirCoverageSubscriber. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCoverageSubscriber. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageSubscriber);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCoverageSubscriber;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCoverageSubscribers[index : Integer] : TFhirCoverageSubscriber read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceIdentity : TFhirElement
    Universal Device Id fields.
  }
  {!.Net HL7Connect.Fhir.DeviceIdentity}
  TFhirDeviceIdentity = class (TFhirElement)
  private
    FGtin : TFhirString;
    FLot : TFhirString;
    FSerialNumber : TFhirString;
    Procedure SetGtin(value : TFhirString);
    Function GetGtinST : String;
    Procedure SetGtinST(value : String);
    Procedure SetLot(value : TFhirString);
    Function GetLotST : String;
    Procedure SetLotST(value : String);
    Procedure SetSerialNumber(value : TFhirString);
    Function GetSerialNumberST : String;
    Procedure SetSerialNumberST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceIdentity; overload;
    function Clone : TFhirDeviceIdentity; overload;
    {!script show}
  published
    {@member gtin
      The number assigned to this device by an authorised issuer of Device GTINs, based on the standards set by GS1.
    }
    property gtin : TFhirString read FGtin write SetGtin;
    {@member gtinST
      Typed access to The number assigned to this device by an authorised issuer of Device GTINs, based on the standards set by GS1.
    }
    property gtinST : String read GetGtinST write SetGtinST;

    {@member lot
      Lot number of manufacture.
    }
    property lot : TFhirString read FLot write SetLot;
    {@member lotST
      Typed access to Lot number of manufacture.
    }
    property lotST : String read GetLotST write SetLotST;

    {@member serialNumber
      The serial number assigned by the organization when the device was manufactured.
    }
    property serialNumber : TFhirString read FSerialNumber write SetSerialNumber;
    {@member serialNumberST
      Typed access to The serial number assigned by the organization when the device was manufactured.
    }
    property serialNumberST : String read GetSerialNumberST write SetSerialNumberST;

  end;


  {@Class TFhirDeviceIdentityList
    A list of FhirDeviceIdentity
  }
  {!.Net HL7Connect.Fhir.DeviceIdentityList}
  TFhirDeviceIdentityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceIdentity;
    procedure SetItemN(index : Integer; value : TFhirDeviceIdentity);
  public
    {!script hide}
    function Link : TFhirDeviceIdentityList; Overload;
    function Clone : TFhirDeviceIdentityList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceIdentity to the end of the list.
    }
    function Append : TFhirDeviceIdentity;

    
    {@member AddItem
      Add an already existing FhirDeviceIdentity to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceIdentity);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceIdentity) : Integer;
    

    {@member Insert
      Insert FhirDeviceIdentity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceIdentity;
    

    {@member InsertItem
       Insert an existing FhirDeviceIdentity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceIdentity);
    
    {@member Item
       Get the iIndexth FhirDeviceIdentity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceIdentity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceIdentity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceIdentity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceIdentities[index : Integer] : TFhirDeviceIdentity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceCapabilitiesVirtualDevice : TFhirElement
    A medical-related subsystem of a medical device.
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDevice}
  TFhirDeviceCapabilitiesVirtualDevice = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FchannelList : TFhirDeviceCapabilitiesVirtualDeviceChannelList;
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceCapabilitiesVirtualDevice; overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDevice; overload;
    {!script show}
  published
    {@member code
      Describes the compartment.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member channelList
      Groups together physiological measurement data and derived data.
    }
    property channelList : TFhirDeviceCapabilitiesVirtualDeviceChannelList read FChannelList;

  end;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceList
    A list of FhirDeviceCapabilitiesVirtualDevice
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceList}
  TFhirDeviceCapabilitiesVirtualDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceCapabilitiesVirtualDevice;
    procedure SetItemN(index : Integer; value : TFhirDeviceCapabilitiesVirtualDevice);
  public
    {!script hide}
    function Link : TFhirDeviceCapabilitiesVirtualDeviceList; Overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceCapabilitiesVirtualDevice to the end of the list.
    }
    function Append : TFhirDeviceCapabilitiesVirtualDevice;

    
    {@member AddItem
      Add an already existing FhirDeviceCapabilitiesVirtualDevice to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceCapabilitiesVirtualDevice);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceCapabilitiesVirtualDevice) : Integer;
    

    {@member Insert
      Insert FhirDeviceCapabilitiesVirtualDevice before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceCapabilitiesVirtualDevice;
    

    {@member InsertItem
       Insert an existing FhirDeviceCapabilitiesVirtualDevice before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceCapabilitiesVirtualDevice);
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDevice. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDevice. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceCapabilitiesVirtualDevice);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceCapabilitiesVirtualDevice;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceCapabilitiesVirtualDevices[index : Integer] : TFhirDeviceCapabilitiesVirtualDevice read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannel : TFhirElement
    Groups together physiological measurement data and derived data.
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannel}
  TFhirDeviceCapabilitiesVirtualDeviceChannel = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FmetricList : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList;
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannel; overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannel; overload;
    {!script show}
  published
    {@member code
      Describes the channel.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member metricList
      A piece of measured or derived data that will be reported by the machine.
    }
    property metricList : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList read FMetricList;

  end;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannelList
    A list of FhirDeviceCapabilitiesVirtualDeviceChannel
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannelList}
  TFhirDeviceCapabilitiesVirtualDeviceChannelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannel;
    procedure SetItemN(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannel);
  public
    {!script hide}
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannelList; Overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceCapabilitiesVirtualDeviceChannel to the end of the list.
    }
    function Append : TFhirDeviceCapabilitiesVirtualDeviceChannel;

    
    {@member AddItem
      Add an already existing FhirDeviceCapabilitiesVirtualDeviceChannel to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceCapabilitiesVirtualDeviceChannel);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceCapabilitiesVirtualDeviceChannel) : Integer;
    

    {@member Insert
      Insert FhirDeviceCapabilitiesVirtualDeviceChannel before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannel;
    

    {@member InsertItem
       Insert an existing FhirDeviceCapabilitiesVirtualDeviceChannel before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannel);
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannel. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannel. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannel);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannel;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceCapabilitiesVirtualDeviceChannels[index : Integer] : TFhirDeviceCapabilitiesVirtualDeviceChannel read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannelMetric : TFhirElement
    A piece of measured or derived data that will be reported by the machine.
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannelMetric}
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetric = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FKey : TFhirString;
    FInfo : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
    FfacetList : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetKey(value : TFhirString);
    Function GetKeyST : String;
    Procedure SetKeyST(value : String);
    Procedure SetInfo(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric; overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric; overload;
    {!script show}
  published
    {@member code
      Describes the metrics.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member key
      Used to link to data in device log.
    }
    property key : TFhirString read FKey write SetKey;
    {@member keyST
      Typed access to Used to link to data in device log.
    }
    property keyST : String read GetKeyST write SetKeyST;

    {@member info
      How to interpret this metric value.
    }
    property info : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo read FInfo write SetInfo;

    {@member facetList
      Additional data that qualifies the metric, or contributes to its assessment.
    }
    property facetList : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList read FFacetList;

  end;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList
    A list of FhirDeviceCapabilitiesVirtualDeviceChannelMetric
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannelMetricList}
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
    procedure SetItemN(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
  public
    {!script hide}
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList; Overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceCapabilitiesVirtualDeviceChannelMetric to the end of the list.
    }
    function Append : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;

    
    {@member AddItem
      Add an already existing FhirDeviceCapabilitiesVirtualDeviceChannelMetric to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric) : Integer;
    

    {@member Insert
      Insert FhirDeviceCapabilitiesVirtualDeviceChannelMetric before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
    

    {@member InsertItem
       Insert an existing FhirDeviceCapabilitiesVirtualDeviceChannelMetric before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannelMetric. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannelMetric. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceCapabilitiesVirtualDeviceChannelMetrics[index : Integer] : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo : TFhirElement
    How to interpret this metric value.
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannelMetricInfo}
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo = class (TFhirElement)
  private
    FType_ : TFhirEnum;
    FUnits : TFhirString;
    FUcum : TFhirCode;
    FTemplate : TFhirSampledData;
    FSystem : TFhirUri;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirDeviceDataType;
    Procedure SetType_ST(value : TFhirDeviceDataType);
    Procedure SetUnits(value : TFhirString);
    Function GetUnitsST : String;
    Procedure SetUnitsST(value : String);
    Procedure SetUcum(value : TFhirCode);
    Function GetUcumST : String;
    Procedure SetUcumST(value : String);
    Procedure SetTemplate(value : TFhirSampledData);
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo; overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo; overload;
    {!script show}
  published
    {@member type_
      Type of data for this metric.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to Type of data for this metric.
    }
    property type_ST : TFhirDeviceDataType read GetType_ST write SetType_ST;

    {@member units
      Units for this data item (if a quantity or a range).
    }
    property units : TFhirString read FUnits write SetUnits;
    {@member unitsST
      Typed access to Units for this data item (if a quantity or a range).
    }
    property unitsST : String read GetUnitsST write SetUnitsST;

    {@member ucum
      UCUM units (if a quantity or a range).
    }
    property ucum : TFhirCode read FUcum write SetUcum;
    {@member ucumST
      Typed access to UCUM units (if a quantity or a range).
    }
    property ucumST : String read GetUcumST write SetUcumST;

    {@member template
      A template containing the fixed values for an array output (all the values but the data).
    }
    property template : TFhirSampledData read FTemplate write SetTemplate;

    {@member system
      System of the codes, if the type is a Coding.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to System of the codes, if the type is a Coding.
    }
    property systemST : String read GetSystemST write SetSystemST;

  end;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList
    A list of FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannelMetricInfoList}
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
    procedure SetItemN(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
  public
    {!script hide}
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList; Overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo to the end of the list.
    }
    function Append : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;

    
    {@member AddItem
      Add an already existing FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo) : Integer;
    

    {@member Insert
      Insert FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
    

    {@member InsertItem
       Insert an existing FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfos[index : Integer] : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet : TFhirElement
    Additional data that qualifies the metric, or contributes to its assessment.
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannelMetricFacet}
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FScale : TFhirDecimal;
    FKey : TFhirString;
    FInfo : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetScale(value : TFhirDecimal);
    Function GetScaleST : String;
    Procedure SetScaleST(value : String);
    Procedure SetKey(value : TFhirString);
    Function GetKeyST : String;
    Procedure SetKeyST(value : String);
    Procedure SetInfo(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet; overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet; overload;
    {!script show}
  published
    {@member code
      Describes the facet.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member scale
      The factor to apply to the raw values to get the correct value.
    }
    property scale : TFhirDecimal read FScale write SetScale;
    {@member scaleST
      Typed access to The factor to apply to the raw values to get the correct value.
    }
    property scaleST : String read GetScaleST write SetScaleST;

    {@member key
      Used to link to data in device log.
    }
    property key : TFhirString read FKey write SetKey;
    {@member keyST
      Typed access to Used to link to data in device log.
    }
    property keyST : String read GetKeyST write SetKeyST;

    {@member info
      How to interpret this facet value.
    }
    property info : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo read FInfo write SetInfo;

  end;


  {@Class TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList
    A list of FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet
  }
  {!.Net HL7Connect.Fhir.DeviceCapabilitiesVirtualDeviceChannelMetricFacetList}
  TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
    procedure SetItemN(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
  public
    {!script hide}
    function Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList; Overload;
    function Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet to the end of the list.
    }
    function Append : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;

    
    {@member AddItem
      Add an already existing FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet) : Integer;
    

    {@member Insert
      Insert FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
    

    {@member InsertItem
       Insert an existing FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacets[index : Integer] : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceLogItem : TFhirElement
    An item of data that the device produces.
  }
  {!.Net HL7Connect.Fhir.DeviceLogItem}
  TFhirDeviceLogItem = class (TFhirElement)
  private
    FKey : TFhirString;
    FValue : TFhirString;
    FFlag : TFhirEnumList;
    Procedure SetKey(value : TFhirString);
    Function GetKeyST : String;
    Procedure SetKeyST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Function GetFlagST : TFhirDeviceValueFlagList;
    Procedure SetFlagST(value : TFhirDeviceValueFlagList);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceLogItem; overload;
    function Clone : TFhirDeviceLogItem; overload;
    {!script show}
  published
    {@member key
      Reference to a device capabilities declaration.
    }
    property key : TFhirString read FKey write SetKey;
    {@member keyST
      Typed access to Reference to a device capabilities declaration.
    }
    property keyST : String read GetKeyST write SetKeyST;

    {@member value
      The value of the data item, if available. Irrespective of the logical format of the data item, the value is always represented as a string.
    }
    property value : TFhirString read FValue write SetValue;
    {@member valueST
      Typed access to The value of the data item, if available. Irrespective of the logical format of the data item, the value is always represented as a string.
    }
    property valueST : String read GetValueST write SetValueST;

    {@member flag
      Information about the quality of the data etc.
    }
    property flag : TFhirEnumList read FFlag;
    {@member flagST
      Typed access to Information about the quality of the data etc.
    }
    property flagST : TFhirDeviceValueFlagList read GetFlagST write SetFlagST;
  end;


  {@Class TFhirDeviceLogItemList
    A list of FhirDeviceLogItem
  }
  {!.Net HL7Connect.Fhir.DeviceLogItemList}
  TFhirDeviceLogItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceLogItem;
    procedure SetItemN(index : Integer; value : TFhirDeviceLogItem);
  public
    {!script hide}
    function Link : TFhirDeviceLogItemList; Overload;
    function Clone : TFhirDeviceLogItemList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceLogItem to the end of the list.
    }
    function Append : TFhirDeviceLogItem;

    
    {@member AddItem
      Add an already existing FhirDeviceLogItem to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceLogItem);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceLogItem) : Integer;
    

    {@member Insert
      Insert FhirDeviceLogItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceLogItem;
    

    {@member InsertItem
       Insert an existing FhirDeviceLogItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceLogItem);
    
    {@member Item
       Get the iIndexth FhirDeviceLogItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceLogItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceLogItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceLogItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceLogItems[index : Integer] : TFhirDeviceLogItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticOrderEvent : TFhirElement
    A summary of the events of interest that have occurred as the request is processed.
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderEvent}
  TFhirDiagnosticOrderEvent = class (TFhirElement)
  private
    FStatus : TFhirEnum;
    FDate : TFhirDateTime;
    FActor : TFhirResourceReference{Resource};
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatus;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatus);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateAndTime;
    Procedure SetDateST(value : TDateAndTime);
    Procedure SetActor(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticOrderEvent; overload;
    function Clone : TFhirDiagnosticOrderEvent; overload;
    {!script show}
  published
    {@member status
      The status for the event.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to The status for the event.
    }
    property statusST : TFhirDiagnosticOrderStatus read GetStatusST write SetStatusST;

    {@member date
      The date/time at which the event occurred.
    }
    property date : TFhirDateTime read FDate write SetDate;
    {@member dateST
      Typed access to The date/time at which the event occurred.
    }
    property dateST : TDateAndTime read GetDateST write SetDateST;

    {@member actor
      The person who was responsible for performing or recording the action.
    }
    property actor : TFhirResourceReference{Resource} read FActor write SetActor;

  end;


  {@Class TFhirDiagnosticOrderEventList
    A list of FhirDiagnosticOrderEvent
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderEventList}
  TFhirDiagnosticOrderEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticOrderEvent;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderEvent);
  public
    {!script hide}
    function Link : TFhirDiagnosticOrderEventList; Overload;
    function Clone : TFhirDiagnosticOrderEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticOrderEvent to the end of the list.
    }
    function Append : TFhirDiagnosticOrderEvent;

    
    {@member AddItem
      Add an already existing FhirDiagnosticOrderEvent to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticOrderEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticOrderEvent) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticOrderEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticOrderEvent;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticOrderEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderEvent);
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticOrderEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticOrderEvents[index : Integer] : TFhirDiagnosticOrderEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticOrderItem : TFhirElement
    The specific diagnostic investigations that are requested as part of this request. Sometimes, there can only be one item per request, but in most contexts, more than one investigation can be requested.
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderItem}
  TFhirDiagnosticOrderItem = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FspecimenList : TFhirResourceReferenceList{TFhirSpecimen};
    FBodySite : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FeventList : TFhirDiagnosticOrderEventList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatus;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatus);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticOrderItem; overload;
    function Clone : TFhirDiagnosticOrderItem; overload;
    {!script show}
  published
    {@member code
      A code that identifies a particular diagnostic investigation that has been requested.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member specimenList
      If the item is related to a specific speciment.
    }
    property specimenList : TFhirResourceReferenceList{TFhirSpecimen} read FSpecimenList;

    {@member bodySite
      Anatomical location where the request test should be performed.
    }
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;

    {@member status
      The status of this individual item within the order.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to The status of this individual item within the order.
    }
    property statusST : TFhirDiagnosticOrderStatus read GetStatusST write SetStatusST;

    {@member eventList
      A summary of the events of interest that have occurred as this item of the request is processed.
    }
    property eventList : TFhirDiagnosticOrderEventList read FEventList;

  end;


  {@Class TFhirDiagnosticOrderItemList
    A list of FhirDiagnosticOrderItem
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderItemList}
  TFhirDiagnosticOrderItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticOrderItem;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderItem);
  public
    {!script hide}
    function Link : TFhirDiagnosticOrderItemList; Overload;
    function Clone : TFhirDiagnosticOrderItemList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticOrderItem to the end of the list.
    }
    function Append : TFhirDiagnosticOrderItem;

    
    {@member AddItem
      Add an already existing FhirDiagnosticOrderItem to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticOrderItem);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticOrderItem) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticOrderItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticOrderItem;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticOrderItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderItem);
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticOrderItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticOrderItems[index : Integer] : TFhirDiagnosticOrderItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticReportRequestDetail : TFhirElement
    Details concerning a single pathology test requested.
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportRequestDetail}
  TFhirDiagnosticReportRequestDetail = class (TFhirElement)
  private
    FEncounter : TFhirResourceReference{TFhirEncounter};
    FRequestOrderId : TFhirIdentifier;
    FReceiverOrderId : TFhirIdentifier;
    FrequestTestList : TFhirCodeableConceptList;
    FBodySite : TFhirCodeableConcept;
    FRequester : TFhirResourceReference{Resource};
    FClinicalInfo : TFhirString;
    Procedure SetEncounter(value : TFhirResourceReference{TFhirEncounter});
    Procedure SetRequestOrderId(value : TFhirIdentifier);
    Procedure SetReceiverOrderId(value : TFhirIdentifier);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetRequester(value : TFhirResourceReference{Resource});
    Procedure SetClinicalInfo(value : TFhirString);
    Function GetClinicalInfoST : String;
    Procedure SetClinicalInfoST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticReportRequestDetail; overload;
    function Clone : TFhirDiagnosticReportRequestDetail; overload;
    {!script show}
  published
    {@member encounter
      The encounter that this diagnostic investigation is associated with.
    }
    property encounter : TFhirResourceReference{TFhirEncounter} read FEncounter write SetEncounter;

    {@member requestOrderId
      The local ID assigned to the order by the order requester.
    }
    property requestOrderId : TFhirIdentifier read FRequestOrderId write SetRequestOrderId;

    {@member receiverOrderId
      The local ID assigned to the test order by the diagnostic service provider.
    }
    property receiverOrderId : TFhirIdentifier read FReceiverOrderId write SetReceiverOrderId;

    {@member requestTestList
      Identification of pathology test requested,.
    }
    property requestTestList : TFhirCodeableConceptList read FRequestTestList;

    {@member bodySite
      Anatomical location where the request test should be performed.
    }
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;

    {@member requester
      Details of the clinician or organization requesting the diagnostic service.
    }
    property requester : TFhirResourceReference{Resource} read FRequester write SetRequester;

    {@member clinicalInfo
      Details of the clinical information provided to the diagnostic service along with the original request.
    }
    property clinicalInfo : TFhirString read FClinicalInfo write SetClinicalInfo;
    {@member clinicalInfoST
      Typed access to Details of the clinical information provided to the diagnostic service along with the original request.
    }
    property clinicalInfoST : String read GetClinicalInfoST write SetClinicalInfoST;

  end;


  {@Class TFhirDiagnosticReportRequestDetailList
    A list of FhirDiagnosticReportRequestDetail
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportRequestDetailList}
  TFhirDiagnosticReportRequestDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReportRequestDetail;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportRequestDetail);
  public
    {!script hide}
    function Link : TFhirDiagnosticReportRequestDetailList; Overload;
    function Clone : TFhirDiagnosticReportRequestDetailList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticReportRequestDetail to the end of the list.
    }
    function Append : TFhirDiagnosticReportRequestDetail;

    
    {@member AddItem
      Add an already existing FhirDiagnosticReportRequestDetail to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticReportRequestDetail);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticReportRequestDetail) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticReportRequestDetail before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticReportRequestDetail;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticReportRequestDetail before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportRequestDetail);
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportRequestDetail. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportRequestDetail. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportRequestDetail);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticReportRequestDetail;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticReportRequestDetails[index : Integer] : TFhirDiagnosticReportRequestDetail read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticReportResults : TFhirElement
    A group of results. Results may be grouped by specimen, or by some value in DiagnosticReport.resultGroup.name to describe what binds all the results together.
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportResults}
  TFhirDiagnosticReportResults = class (TFhirElement)
  private
    FName : TFhirCodeableConcept;
    FSpecimen : TFhirResourceReference{TFhirSpecimen};
    FgroupList : TFhirDiagnosticReportResultsList;
    FresultList : TFhirResourceReferenceList{TFhirObservation};
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetSpecimen(value : TFhirResourceReference{TFhirSpecimen});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticReportResults; overload;
    function Clone : TFhirDiagnosticReportResults; overload;
    {!script show}
  published
    {@member name
      A code or name that describes this group of results. For the base group, this is the report name.
    }
    property name : TFhirCodeableConcept read FName write SetName;

    {@member specimen
      Details about the individual specimen to which these 'Result group' test results refer.
    }
    property specimen : TFhirResourceReference{TFhirSpecimen} read FSpecimen write SetSpecimen;

    {@member groupList
      A sub-group in a report group. Sub groups can be grouped in arbitrary ways. The group.name defines the purpose and interpretation of the grouping.
    }
    property groupList : TFhirDiagnosticReportResultsList read FGroupList;

    {@member resultList
      Specific detailed result, including both the value of the result item and additional information that may be useful for clinical interpretation. Results include whatever specific data items pathology labs report as part of the clinical service; it is not confined to measurements.
    }
    property resultList : TFhirResourceReferenceList{TFhirObservation} read FResultList;

  end;


  {@Class TFhirDiagnosticReportResultsList
    A list of FhirDiagnosticReportResults
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportResultsList}
  TFhirDiagnosticReportResultsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReportResults;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportResults);
  public
    {!script hide}
    function Link : TFhirDiagnosticReportResultsList; Overload;
    function Clone : TFhirDiagnosticReportResultsList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticReportResults to the end of the list.
    }
    function Append : TFhirDiagnosticReportResults;

    
    {@member AddItem
      Add an already existing FhirDiagnosticReportResults to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticReportResults);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticReportResults) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticReportResults before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticReportResults;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticReportResults before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportResults);
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportResults. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportResults. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportResults);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticReportResults;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticReportResults[index : Integer] : TFhirDiagnosticReportResults read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentAttester : TFhirElement
    A participant who has attested to the accuracy of the document.
  }
  {!.Net HL7Connect.Fhir.DocumentAttester}
  TFhirDocumentAttester = class (TFhirElement)
  private
    FMode : TFhirEnum;
    FTime : TFhirDateTime;
    FParty : TFhirResourceReference{Resource};
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirDocumentAttestationMode;
    Procedure SetModeST(value : TFhirDocumentAttestationMode);
    Procedure SetTime(value : TFhirDateTime);
    Function GetTimeST : TDateAndTime;
    Procedure SetTimeST(value : TDateAndTime);
    Procedure SetParty(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentAttester; overload;
    function Clone : TFhirDocumentAttester; overload;
    {!script show}
  published
    {@member mode
      The type of attestation the authenticator offers.
    }
    property mode : TFhirEnum read FMode write SetMode;
    {@member modeST
      Typed access to The type of attestation the authenticator offers.
    }
    property modeST : TFhirDocumentAttestationMode read GetModeST write SetModeST;

    {@member time
      When document was attested by the party.
    }
    property time : TFhirDateTime read FTime write SetTime;
    {@member timeST
      Typed access to When document was attested by the party.
    }
    property timeST : TDateAndTime read GetTimeST write SetTimeST;

    {@member party
      Who attested the document in the specified way.
    }
    property party : TFhirResourceReference{Resource} read FParty write SetParty;

  end;


  {@Class TFhirDocumentAttesterList
    A list of FhirDocumentAttester
  }
  {!.Net HL7Connect.Fhir.DocumentAttesterList}
  TFhirDocumentAttesterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentAttester;
    procedure SetItemN(index : Integer; value : TFhirDocumentAttester);
  public
    {!script hide}
    function Link : TFhirDocumentAttesterList; Overload;
    function Clone : TFhirDocumentAttesterList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentAttester to the end of the list.
    }
    function Append : TFhirDocumentAttester;

    
    {@member AddItem
      Add an already existing FhirDocumentAttester to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentAttester);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentAttester) : Integer;
    

    {@member Insert
      Insert FhirDocumentAttester before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentAttester;
    

    {@member InsertItem
       Insert an existing FhirDocumentAttester before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentAttester);
    
    {@member Item
       Get the iIndexth FhirDocumentAttester. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentAttester. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentAttester);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentAttester;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentAttesters[index : Integer] : TFhirDocumentAttester read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentEvent : TFhirElement
    The main event/act/item, such as a colonoscopy or an appendectomy, being documented.
  }
  {!.Net HL7Connect.Fhir.DocumentEvent}
  TFhirDocumentEvent = class (TFhirElement)
  private
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FdetailList : TFhirResourceReferenceList{Resource};
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentEvent; overload;
    function Clone : TFhirDocumentEvent; overload;
    {!script show}
  published
    {@member codeList
      This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    }
    property codeList : TFhirCodeableConceptList read FCodeList;

    {@member period
      The period of time covered by the document. There is no assertion that the document is a complete representation for this period, only that it documents events during this time.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member detailList
      Full details for the event(s) the document concents.
    }
    property detailList : TFhirResourceReferenceList{Resource} read FDetailList;

  end;


  {@Class TFhirDocumentEventList
    A list of FhirDocumentEvent
  }
  {!.Net HL7Connect.Fhir.DocumentEventList}
  TFhirDocumentEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentEvent;
    procedure SetItemN(index : Integer; value : TFhirDocumentEvent);
  public
    {!script hide}
    function Link : TFhirDocumentEventList; Overload;
    function Clone : TFhirDocumentEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentEvent to the end of the list.
    }
    function Append : TFhirDocumentEvent;

    
    {@member AddItem
      Add an already existing FhirDocumentEvent to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentEvent) : Integer;
    

    {@member Insert
      Insert FhirDocumentEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentEvent;
    

    {@member InsertItem
       Insert an existing FhirDocumentEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentEvent);
    
    {@member Item
       Get the iIndexth FhirDocumentEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentEvents[index : Integer] : TFhirDocumentEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentSection : TFhirElement
    Identifies a main topic within the document's table of contents.
  }
  {!.Net HL7Connect.Fhir.DocumentSection}
  TFhirDocumentSection = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FSubject : TFhirResourceReference{Resource};
    FContent : TFhirResourceReference{Resource};
    FsectionList : TFhirDocumentSectionList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirResourceReference{Resource});
    Procedure SetContent(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentSection; overload;
    function Clone : TFhirDocumentSection; overload;
    {!script show}
  published
    {@member code
      A code identifying the kind of content contained within the section.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member subject
      Identifies the primary subject of the section.
    }
    property subject : TFhirResourceReference{Resource} read FSubject write SetSubject;

    {@member content
      Identifies the discrete data that provides the content for the section.
    }
    property content : TFhirResourceReference{Resource} read FContent write SetContent;

    {@member sectionList
      Identifies a subtopic within the section as part of the document's table of contents.
    }
    property sectionList : TFhirDocumentSectionList read FSectionList;

  end;


  {@Class TFhirDocumentSectionList
    A list of FhirDocumentSection
  }
  {!.Net HL7Connect.Fhir.DocumentSectionList}
  TFhirDocumentSectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentSection;
    procedure SetItemN(index : Integer; value : TFhirDocumentSection);
  public
    {!script hide}
    function Link : TFhirDocumentSectionList; Overload;
    function Clone : TFhirDocumentSectionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentSection to the end of the list.
    }
    function Append : TFhirDocumentSection;

    
    {@member AddItem
      Add an already existing FhirDocumentSection to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentSection);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentSection) : Integer;
    

    {@member Insert
      Insert FhirDocumentSection before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentSection;
    

    {@member InsertItem
       Insert an existing FhirDocumentSection before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentSection);
    
    {@member Item
       Get the iIndexth FhirDocumentSection. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentSection. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentSection);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentSection;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentSections[index : Integer] : TFhirDocumentSection read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceService : TFhirElement
    A description of a service call that can be used to retrieve the document.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceService}
  TFhirDocumentReferenceService = class (TFhirElement)
  private
    FType_ : TFhirCodeableConcept;
    FAddress : TFhirString;
    FparameterList : TFhirDocumentReferenceServiceParameterList;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAddress(value : TFhirString);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceService; overload;
    function Clone : TFhirDocumentReferenceService; overload;
    {!script show}
  published
    {@member type_
      The type of the service that can be used to access the documents.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member address
      Where the service end-point is located.
    }
    property address : TFhirString read FAddress write SetAddress;
    {@member addressST
      Typed access to Where the service end-point is located.
    }
    property addressST : String read GetAddressST write SetAddressST;

    {@member parameterList
      A list of named parameters that is used in the service call.
    }
    property parameterList : TFhirDocumentReferenceServiceParameterList read FParameterList;

  end;


  {@Class TFhirDocumentReferenceServiceList
    A list of FhirDocumentReferenceService
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceList}
  TFhirDocumentReferenceServiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceService;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceService);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceServiceList; Overload;
    function Clone : TFhirDocumentReferenceServiceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceService to the end of the list.
    }
    function Append : TFhirDocumentReferenceService;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceService to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceService);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceService) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceService before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceService;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceService before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceService);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceService. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceService. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceService);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceService;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceServices[index : Integer] : TFhirDocumentReferenceService read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceServiceParameter : TFhirElement
    A list of named parameters that is used in the service call.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceParameter}
  TFhirDocumentReferenceServiceParameter = class (TFhirElement)
  private
    FName : TFhirString;
    FValue : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceServiceParameter; overload;
    function Clone : TFhirDocumentReferenceServiceParameter; overload;
    {!script show}
  published
    {@member name
      The name of a parameter.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of a parameter.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member value
      The value of the named parameter.
    }
    property value : TFhirString read FValue write SetValue;
    {@member valueST
      Typed access to The value of the named parameter.
    }
    property valueST : String read GetValueST write SetValueST;

  end;


  {@Class TFhirDocumentReferenceServiceParameterList
    A list of FhirDocumentReferenceServiceParameter
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceParameterList}
  TFhirDocumentReferenceServiceParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceServiceParameter;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceServiceParameter);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceServiceParameterList; Overload;
    function Clone : TFhirDocumentReferenceServiceParameterList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceServiceParameter to the end of the list.
    }
    function Append : TFhirDocumentReferenceServiceParameter;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceServiceParameter to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceServiceParameter);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceServiceParameter) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceServiceParameter before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceServiceParameter;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceServiceParameter before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceServiceParameter);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceServiceParameter. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceServiceParameter. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceServiceParameter);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceServiceParameter;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceServiceParameters[index : Integer] : TFhirDocumentReferenceServiceParameter read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceContext : TFhirElement
    The clinical context in which the document was prepared.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceContext}
  TFhirDocumentReferenceContext = class (TFhirElement)
  private
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FFacilityType : TFhirCodeableConcept;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetFacilityType(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceContext; overload;
    function Clone : TFhirDocumentReferenceContext; overload;
    {!script show}
  published
    {@member codeList
      The type of clinical context, such as a kind of surgery, or a kind of speciality, or a clinical type.
    }
    property codeList : TFhirCodeableConceptList read FCodeList;

    {@member period
      The time period of the patient's care that is described by the document.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member facilityType
      The kind of facility where the patient was seen.
    }
    property facilityType : TFhirCodeableConcept read FFacilityType write SetFacilityType;

  end;


  {@Class TFhirDocumentReferenceContextList
    A list of FhirDocumentReferenceContext
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceContextList}
  TFhirDocumentReferenceContextList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceContext;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContext);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceContextList; Overload;
    function Clone : TFhirDocumentReferenceContextList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceContext to the end of the list.
    }
    function Append : TFhirDocumentReferenceContext;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceContext to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceContext);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceContext) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceContext before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceContext;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceContext before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContext);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContext);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceContext;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceContexts[index : Integer] : TFhirDocumentReferenceContext read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterParticipant : TFhirElement
    The main practitioner responsible for providing the service.
  }
  {!.Net HL7Connect.Fhir.EncounterParticipant}
  TFhirEncounterParticipant = class (TFhirElement)
  private
    FType_ : TFhirEnumList;
    FPractitioner : TFhirResourceReference{TFhirPractitioner};
    Function GetType_ST : TFhirParticipantTypeList;
    Procedure SetType_ST(value : TFhirParticipantTypeList);
    Procedure SetPractitioner(value : TFhirResourceReference{TFhirPractitioner});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterParticipant; overload;
    function Clone : TFhirEncounterParticipant; overload;
    {!script show}
  published
    {@member type_
      Role of participant in encounter.
    }
    property type_ : TFhirEnumList read FType_;
    {@member type_ST
      Typed access to Role of participant in encounter.
    }
    property type_ST : TFhirParticipantTypeList read GetType_ST write SetType_ST;
    {@member practitioner
      The practitioner that is involved.
    }
    property practitioner : TFhirResourceReference{TFhirPractitioner} read FPractitioner write SetPractitioner;

  end;


  {@Class TFhirEncounterParticipantList
    A list of FhirEncounterParticipant
  }
  {!.Net HL7Connect.Fhir.EncounterParticipantList}
  TFhirEncounterParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterParticipant;
    procedure SetItemN(index : Integer; value : TFhirEncounterParticipant);
  public
    {!script hide}
    function Link : TFhirEncounterParticipantList; Overload;
    function Clone : TFhirEncounterParticipantList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterParticipant to the end of the list.
    }
    function Append : TFhirEncounterParticipant;

    
    {@member AddItem
      Add an already existing FhirEncounterParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterParticipant);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterParticipant) : Integer;
    

    {@member Insert
      Insert FhirEncounterParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterParticipant;
    

    {@member InsertItem
       Insert an existing FhirEncounterParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterParticipant);
    
    {@member Item
       Get the iIndexth FhirEncounterParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterParticipants[index : Integer] : TFhirEncounterParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterHospitalization : TFhirElement
    Details about an admission to a clinic.
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalization}
  TFhirEncounterHospitalization = class (TFhirElement)
  private
    FPreAdmissionIdentifier : TFhirIdentifier;
    FOrigin : TFhirResourceReference{TFhirLocation};
    FAdmitSource : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FaccomodationList : TFhirEncounterHospitalizationAccomodationList;
    FDiet : TFhirCodeableConcept;
    FspecialCourtesyList : TFhirCodeableConceptList;
    FspecialArrangementList : TFhirCodeableConceptList;
    FDestination : TFhirResourceReference{TFhirLocation};
    FDischargeDisposition : TFhirCodeableConcept;
    FReAdmission : TFhirBoolean;
    Procedure SetPreAdmissionIdentifier(value : TFhirIdentifier);
    Procedure SetOrigin(value : TFhirResourceReference{TFhirLocation});
    Procedure SetAdmitSource(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetDiet(value : TFhirCodeableConcept);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
    Procedure SetDischargeDisposition(value : TFhirCodeableConcept);
    Procedure SetReAdmission(value : TFhirBoolean);
    Function GetReAdmissionST : String;
    Procedure SetReAdmissionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterHospitalization; overload;
    function Clone : TFhirEncounterHospitalization; overload;
    {!script show}
  published
    {@member preAdmissionIdentifier
      Pre-admission identifier.
    }
    property preAdmissionIdentifier : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;

    {@member origin
      The location the patient came from before admission.
    }
    property origin : TFhirResourceReference{TFhirLocation} read FOrigin write SetOrigin;

    {@member admitSource
      Where patient was admitted from (physician referral, transfer).
    }
    property admitSource : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;

    {@member period
      Period of hospitalization.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member accomodationList
      Where the patient stays during this encounter.
    }
    property accomodationList : TFhirEncounterHospitalizationAccomodationList read FAccomodationList;

    {@member diet
      Dietary restrictions for the patient.
    }
    property diet : TFhirCodeableConcept read FDiet write SetDiet;

    {@member specialCourtesyList
      Special courtesies (VIP, board member).
    }
    property specialCourtesyList : TFhirCodeableConceptList read FSpecialCourtesyList;

    {@member specialArrangementList
      Wheelchair, translator, stretcher, etc.
    }
    property specialArrangementList : TFhirCodeableConceptList read FSpecialArrangementList;

    {@member destination
      Location the patient is discharged to.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member dischargeDisposition
      Disposition patient released to.
    }
    property dischargeDisposition : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;

    {@member reAdmission
      Is readmission?.
    }
    property reAdmission : TFhirBoolean read FReAdmission write SetReAdmission;
    {@member reAdmissionST
      Typed access to Is readmission?.
    }
    property reAdmissionST : String read GetReAdmissionST write SetReAdmissionST;

  end;


  {@Class TFhirEncounterHospitalizationList
    A list of FhirEncounterHospitalization
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationList}
  TFhirEncounterHospitalizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalization;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalization);
  public
    {!script hide}
    function Link : TFhirEncounterHospitalizationList; Overload;
    function Clone : TFhirEncounterHospitalizationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterHospitalization to the end of the list.
    }
    function Append : TFhirEncounterHospitalization;

    
    {@member AddItem
      Add an already existing FhirEncounterHospitalization to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterHospitalization);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterHospitalization) : Integer;
    

    {@member Insert
      Insert FhirEncounterHospitalization before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterHospitalization;
    

    {@member InsertItem
       Insert an existing FhirEncounterHospitalization before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalization);
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalization);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterHospitalization;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterHospitalizations[index : Integer] : TFhirEncounterHospitalization read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterHospitalizationAccomodation : TFhirElement
    Where the patient stays during this encounter.
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationAccomodation}
  TFhirEncounterHospitalizationAccomodation = class (TFhirElement)
  private
    FBed : TFhirResourceReference{TFhirLocation};
    FPeriod : TFhirPeriod;
    Procedure SetBed(value : TFhirResourceReference{TFhirLocation});
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterHospitalizationAccomodation; overload;
    function Clone : TFhirEncounterHospitalizationAccomodation; overload;
    {!script show}
  published
    {@member bed
      Bed.
    }
    property bed : TFhirResourceReference{TFhirLocation} read FBed write SetBed;

    {@member period
      Period during which the patient was assigned the bed.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

  end;


  {@Class TFhirEncounterHospitalizationAccomodationList
    A list of FhirEncounterHospitalizationAccomodation
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationAccomodationList}
  TFhirEncounterHospitalizationAccomodationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
  public
    {!script hide}
    function Link : TFhirEncounterHospitalizationAccomodationList; Overload;
    function Clone : TFhirEncounterHospitalizationAccomodationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterHospitalizationAccomodation to the end of the list.
    }
    function Append : TFhirEncounterHospitalizationAccomodation;

    
    {@member AddItem
      Add an already existing FhirEncounterHospitalizationAccomodation to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterHospitalizationAccomodation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterHospitalizationAccomodation) : Integer;
    

    {@member Insert
      Insert FhirEncounterHospitalizationAccomodation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    

    {@member InsertItem
       Insert an existing FhirEncounterHospitalizationAccomodation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalizationAccomodation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalizationAccomodation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterHospitalizationAccomodations[index : Integer] : TFhirEncounterHospitalizationAccomodation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterLocation : TFhirElement
    List of locations the patient has been at.
  }
  {!.Net HL7Connect.Fhir.EncounterLocation}
  TFhirEncounterLocation = class (TFhirElement)
  private
    FLocation : TFhirResourceReference{TFhirLocation};
    FPeriod : TFhirPeriod;
    Procedure SetLocation(value : TFhirResourceReference{TFhirLocation});
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterLocation; overload;
    function Clone : TFhirEncounterLocation; overload;
    {!script show}
  published
    {@member location
      The location the encounter takes place.
    }
    property location : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;

    {@member period
      Time period during which the patient was present at the location.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

  end;


  {@Class TFhirEncounterLocationList
    A list of FhirEncounterLocation
  }
  {!.Net HL7Connect.Fhir.EncounterLocationList}
  TFhirEncounterLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterLocation;
    procedure SetItemN(index : Integer; value : TFhirEncounterLocation);
  public
    {!script hide}
    function Link : TFhirEncounterLocationList; Overload;
    function Clone : TFhirEncounterLocationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterLocation to the end of the list.
    }
    function Append : TFhirEncounterLocation;

    
    {@member AddItem
      Add an already existing FhirEncounterLocation to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterLocation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterLocation) : Integer;
    

    {@member Insert
      Insert FhirEncounterLocation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterLocation;
    

    {@member InsertItem
       Insert an existing FhirEncounterLocation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterLocation);
    
    {@member Item
       Get the iIndexth FhirEncounterLocation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterLocation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterLocation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterLocation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterLocations[index : Integer] : TFhirEncounterLocation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirFamilyHistoryRelation : TFhirElement
    The related person. Each FamilyHistory resource contains the entire family history for a single person.
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelation}
  TFhirFamilyHistoryRelation = class (TFhirElement)
  private
    FName : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FDeceased : TFhirType;
    FNote : TFhirString;
    FconditionList : TFhirFamilyHistoryRelationConditionList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetDeceased(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirFamilyHistoryRelation; overload;
    function Clone : TFhirFamilyHistoryRelation; overload;
    {!script show}
  published
    {@member name
      This will either be a name or a description.  E.g. "Aunt Susan", "my cousin with the red hair".
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to This will either be a name or a description.  E.g. "Aunt Susan", "my cousin with the red hair".
    }
    property nameST : String read GetNameST write SetNameST;

    {@member relationship
      The type of relationship this person has to the patient (father, mother, brother etc.) At the moment this is a code linking to a fixed set of values. I'm not sure if there is an international standard for this. A fixed (possibly extensible) set of codes feels better than a codeable concept for something like this...
    }
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;

    {@member deceased
      If this resource is indicating that the related person is deceased, then an indicator of whether the person is deceased (yes) or not (no) or the age or age range or description of age at death - can be indicated here. If the reason for death is known, then it can be indicated in the outcome code of the condition - in this case the deceased property should still be set.
    }
    property deceased : TFhirType read FDeceased write SetDeceased;

    {@member note
      This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    }
    property note : TFhirString read FNote write SetNote;
    {@member noteST
      Typed access to This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    }
    property noteST : String read GetNoteST write SetNoteST;

    {@member conditionList
      The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    }
    property conditionList : TFhirFamilyHistoryRelationConditionList read FConditionList;

  end;


  {@Class TFhirFamilyHistoryRelationList
    A list of FhirFamilyHistoryRelation
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationList}
  TFhirFamilyHistoryRelationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyHistoryRelation;
    procedure SetItemN(index : Integer; value : TFhirFamilyHistoryRelation);
  public
    {!script hide}
    function Link : TFhirFamilyHistoryRelationList; Overload;
    function Clone : TFhirFamilyHistoryRelationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirFamilyHistoryRelation to the end of the list.
    }
    function Append : TFhirFamilyHistoryRelation;

    
    {@member AddItem
      Add an already existing FhirFamilyHistoryRelation to the end of the list.
    }
    procedure AddItem(value : TFhirFamilyHistoryRelation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirFamilyHistoryRelation) : Integer;
    

    {@member Insert
      Insert FhirFamilyHistoryRelation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirFamilyHistoryRelation;
    

    {@member InsertItem
       Insert an existing FhirFamilyHistoryRelation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirFamilyHistoryRelation);
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyHistoryRelation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirFamilyHistoryRelation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirFamilyHistoryRelations[index : Integer] : TFhirFamilyHistoryRelation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirFamilyHistoryRelationCondition : TFhirElement
    The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationCondition}
  TFhirFamilyHistoryRelationCondition = class (TFhirElement)
  private
    FType_ : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FOnset : TFhirType;
    FNote : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetOnset(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirFamilyHistoryRelationCondition; overload;
    function Clone : TFhirFamilyHistoryRelationCondition; overload;
    {!script show}
  published
    {@member type_
      The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member outcome
      Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation.
    }
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;

    {@member onset
      Either the age of onset, range of approximate age or descriptive string can be recorded.
    }
    property onset : TFhirType read FOnset write SetOnset;

    {@member note
      An area where general notes can be placed about this specific condition.
    }
    property note : TFhirString read FNote write SetNote;
    {@member noteST
      Typed access to An area where general notes can be placed about this specific condition.
    }
    property noteST : String read GetNoteST write SetNoteST;

  end;


  {@Class TFhirFamilyHistoryRelationConditionList
    A list of FhirFamilyHistoryRelationCondition
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationConditionList}
  TFhirFamilyHistoryRelationConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyHistoryRelationCondition;
    procedure SetItemN(index : Integer; value : TFhirFamilyHistoryRelationCondition);
  public
    {!script hide}
    function Link : TFhirFamilyHistoryRelationConditionList; Overload;
    function Clone : TFhirFamilyHistoryRelationConditionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirFamilyHistoryRelationCondition to the end of the list.
    }
    function Append : TFhirFamilyHistoryRelationCondition;

    
    {@member AddItem
      Add an already existing FhirFamilyHistoryRelationCondition to the end of the list.
    }
    procedure AddItem(value : TFhirFamilyHistoryRelationCondition);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirFamilyHistoryRelationCondition) : Integer;
    

    {@member Insert
      Insert FhirFamilyHistoryRelationCondition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirFamilyHistoryRelationCondition;
    

    {@member InsertItem
       Insert an existing FhirFamilyHistoryRelationCondition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirFamilyHistoryRelationCondition);
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelationCondition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelationCondition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyHistoryRelationCondition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirFamilyHistoryRelationCondition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirFamilyHistoryRelationConditions[index : Integer] : TFhirFamilyHistoryRelationCondition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirGroupCharacteristic : TFhirElement
    Identifies the traits shared by members of the group.
  }
  {!.Net HL7Connect.Fhir.GroupCharacteristic}
  TFhirGroupCharacteristic = class (TFhirElement)
  private
    FType_ : TFhirCodeableConcept;
    FValue : TFhirType;
    FExclude : TFhirBoolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
    Procedure SetExclude(value : TFhirBoolean);
    Function GetExcludeST : String;
    Procedure SetExcludeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirGroupCharacteristic; overload;
    function Clone : TFhirGroupCharacteristic; overload;
    {!script show}
  published
    {@member type_
      Identifies the kind of trait being asserted.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member value
      The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    }
    property value : TFhirType read FValue write SetValue;

    {@member exclude
      If true, indicates the characteristic is one that is NOT held by members of the group.
    }
    property exclude : TFhirBoolean read FExclude write SetExclude;
    {@member excludeST
      Typed access to If true, indicates the characteristic is one that is NOT held by members of the group.
    }
    property excludeST : String read GetExcludeST write SetExcludeST;

  end;


  {@Class TFhirGroupCharacteristicList
    A list of FhirGroupCharacteristic
  }
  {!.Net HL7Connect.Fhir.GroupCharacteristicList}
  TFhirGroupCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirGroupCharacteristic);
  public
    {!script hide}
    function Link : TFhirGroupCharacteristicList; Overload;
    function Clone : TFhirGroupCharacteristicList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirGroupCharacteristic to the end of the list.
    }
    function Append : TFhirGroupCharacteristic;

    
    {@member AddItem
      Add an already existing FhirGroupCharacteristic to the end of the list.
    }
    procedure AddItem(value : TFhirGroupCharacteristic);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirGroupCharacteristic) : Integer;
    

    {@member Insert
      Insert FhirGroupCharacteristic before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirGroupCharacteristic;
    

    {@member InsertItem
       Insert an existing FhirGroupCharacteristic before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirGroupCharacteristic);
    
    {@member Item
       Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirGroupCharacteristic);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirGroupCharacteristic;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirGroupCharacteristics[index : Integer] : TFhirGroupCharacteristic read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImagingStudySeries : TFhirElement
    Each study has one or more series of image instances.
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeries}
  TFhirImagingStudySeries = class (TFhirElement)
  private
    FNumber : TFhirInteger;
    FModality : TFhirEnum;
    FUid : TFhirOid;
    FDescription : TFhirString;
    FNumberOfInstances : TFhirInteger;
    FAvailability : TFhirEnum;
    FUrl : TFhirUri;
    FBodySite : TFhirCoding;
    FDateTime : TFhirDateTime;
    FinstanceList : TFhirImagingStudySeriesInstanceList;
    Procedure SetNumber(value : TFhirInteger);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetModality(value : TFhirEnum);
    Function GetModalityST : TFhirModality;
    Procedure SetModalityST(value : TFhirModality);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNumberOfInstances(value : TFhirInteger);
    Function GetNumberOfInstancesST : String;
    Procedure SetNumberOfInstancesST(value : String);
    Procedure SetAvailability(value : TFhirEnum);
    Function GetAvailabilityST : TFhirInstanceAvailability;
    Procedure SetAvailabilityST(value : TFhirInstanceAvailability);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetBodySite(value : TFhirCoding);
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TDateAndTime;
    Procedure SetDateTimeST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImagingStudySeries; overload;
    function Clone : TFhirImagingStudySeries; overload;
    {!script show}
  published
    {@member number
      The number of this series in the overall sequence.
    }
    property number : TFhirInteger read FNumber write SetNumber;
    {@member numberST
      Typed access to The number of this series in the overall sequence.
    }
    property numberST : String read GetNumberST write SetNumberST;

    {@member modality
      The modality of this sequence.
    }
    property modality : TFhirEnum read FModality write SetModality;
    {@member modalityST
      Typed access to The modality of this sequence.
    }
    property modalityST : TFhirModality read GetModalityST write SetModalityST;

    {@member uid
      Formal identifier for this series.
    }
    property uid : TFhirOid read FUid write SetUid;
    {@member uidST
      Typed access to Formal identifier for this series.
    }
    property uidST : String read GetUidST write SetUidST;

    {@member description
      A description of the series.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to A description of the series.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member numberOfInstances
      Sequence that contains attributes from the.
    }
    property numberOfInstances : TFhirInteger read FNumberOfInstances write SetNumberOfInstances;
    {@member numberOfInstancesST
      Typed access to Sequence that contains attributes from the.
    }
    property numberOfInstancesST : String read GetNumberOfInstancesST write SetNumberOfInstancesST;

    {@member availability
      Availability of series (online, offline or nearlnie).
    }
    property availability : TFhirEnum read FAvailability write SetAvailability;
    {@member availabilityST
      Typed access to Availability of series (online, offline or nearlnie).
    }
    property availabilityST : TFhirInstanceAvailability read GetAvailabilityST write SetAvailabilityST;

    {@member url
      WADO-RS URI where Series is available.
    }
    property url : TFhirUri read FUrl write SetUrl;
    {@member urlST
      Typed access to WADO-RS URI where Series is available.
    }
    property urlST : String read GetUrlST write SetUrlST;

    {@member bodySite
      Body part examined. See  DICOM Part 16 Annex L for the mapping from DICOM to Snomed.
    }
    property bodySite : TFhirCoding read FBodySite write SetBodySite;

    {@member dateTime
      When the series started.
    }
    property dateTime : TFhirDateTime read FDateTime write SetDateTime;
    {@member dateTimeST
      Typed access to When the series started.
    }
    property dateTimeST : TDateAndTime read GetDateTimeST write SetDateTimeST;

    {@member instanceList
      A single image taken from a patient.
    }
    property instanceList : TFhirImagingStudySeriesInstanceList read FInstanceList;

  end;


  {@Class TFhirImagingStudySeriesList
    A list of FhirImagingStudySeries
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesList}
  TFhirImagingStudySeriesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeries);
  public
    {!script hide}
    function Link : TFhirImagingStudySeriesList; Overload;
    function Clone : TFhirImagingStudySeriesList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImagingStudySeries to the end of the list.
    }
    function Append : TFhirImagingStudySeries;

    
    {@member AddItem
      Add an already existing FhirImagingStudySeries to the end of the list.
    }
    procedure AddItem(value : TFhirImagingStudySeries);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImagingStudySeries) : Integer;
    

    {@member Insert
      Insert FhirImagingStudySeries before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImagingStudySeries;
    

    {@member InsertItem
       Insert an existing FhirImagingStudySeries before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeries);
    
    {@member Item
       Get the iIndexth FhirImagingStudySeries. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImagingStudySeries. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeries);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImagingStudySeries;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImagingStudySeries[index : Integer] : TFhirImagingStudySeries read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImagingStudySeriesInstance : TFhirElement
    A single image taken from a patient.
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesInstance}
  TFhirImagingStudySeriesInstance = class (TFhirElement)
  private
    FNumber : TFhirInteger;
    FUid : TFhirOid;
    FSopclass : TFhirOid;
    FType_ : TFhirString;
    FTitle : TFhirString;
    FUrl : TFhirUri;
    FAttachment : TFhirResourceReference{Resource};
    Procedure SetNumber(value : TFhirInteger);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetSopclass(value : TFhirOid);
    Function GetSopclassST : String;
    Procedure SetSopclassST(value : String);
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetAttachment(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImagingStudySeriesInstance; overload;
    function Clone : TFhirImagingStudySeriesInstance; overload;
    {!script show}
  published
    {@member number
      The number of this image in the series.
    }
    property number : TFhirInteger read FNumber write SetNumber;
    {@member numberST
      Typed access to The number of this image in the series.
    }
    property numberST : String read GetNumberST write SetNumberST;

    {@member uid
      Formal identifier for this image.
    }
    property uid : TFhirOid read FUid write SetUid;
    {@member uidST
      Typed access to Formal identifier for this image.
    }
    property uidST : String read GetUidST write SetUidST;

    {@member sopclass
      DICOM Image type.
    }
    property sopclass : TFhirOid read FSopclass write SetSopclass;
    {@member sopclassST
      Typed access to DICOM Image type.
    }
    property sopclassST : String read GetSopclassST write SetSopclassST;

    {@member type_
      Type of instance (0004,1430).
    }
    property type_ : TFhirString read FType_ write SetType_;
    {@member type_ST
      Typed access to Type of instance (0004,1430).
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member title
      Description to be provided.
    }
    property title : TFhirString read FTitle write SetTitle;
    {@member titleST
      Typed access to Description to be provided.
    }
    property titleST : String read GetTitleST write SetTitleST;

    {@member url
      WADO url where image is available.
    }
    property url : TFhirUri read FUrl write SetUrl;
    {@member urlST
      Typed access to WADO url where image is available.
    }
    property urlST : String read GetUrlST write SetUrlST;

    {@member attachment
      A FHIR resource with content for this instance.
    }
    property attachment : TFhirResourceReference{Resource} read FAttachment write SetAttachment;

  end;


  {@Class TFhirImagingStudySeriesInstanceList
    A list of FhirImagingStudySeriesInstance
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesInstanceList}
  TFhirImagingStudySeriesInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesInstance);
  public
    {!script hide}
    function Link : TFhirImagingStudySeriesInstanceList; Overload;
    function Clone : TFhirImagingStudySeriesInstanceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImagingStudySeriesInstance to the end of the list.
    }
    function Append : TFhirImagingStudySeriesInstance;

    
    {@member AddItem
      Add an already existing FhirImagingStudySeriesInstance to the end of the list.
    }
    procedure AddItem(value : TFhirImagingStudySeriesInstance);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImagingStudySeriesInstance) : Integer;
    

    {@member Insert
      Insert FhirImagingStudySeriesInstance before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImagingStudySeriesInstance;
    

    {@member InsertItem
       Insert an existing FhirImagingStudySeriesInstance before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    {@member Item
       Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImagingStudySeriesInstance;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImagingStudySeriesInstances[index : Integer] : TFhirImagingStudySeriesInstance read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationExplanation : TFhirElement
    Reasons why a vaccine was administered or refused.
  }
  {!.Net HL7Connect.Fhir.ImmunizationExplanation}
  TFhirImmunizationExplanation = class (TFhirElement)
  private
    FreasonList : TFhirCodeableConceptList;
    FrefusalReasonList : TFhirCodeableConceptList;
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationExplanation; overload;
    function Clone : TFhirImmunizationExplanation; overload;
    {!script show}
  published
    {@member reasonList
      Reasons why a vaccine was administered.
    }
    property reasonList : TFhirCodeableConceptList read FReasonList;

    {@member refusalReasonList
      Refusal or exemption reasons.
    }
    property refusalReasonList : TFhirCodeableConceptList read FRefusalReasonList;

  end;


  {@Class TFhirImmunizationExplanationList
    A list of FhirImmunizationExplanation
  }
  {!.Net HL7Connect.Fhir.ImmunizationExplanationList}
  TFhirImmunizationExplanationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationExplanation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationExplanation);
  public
    {!script hide}
    function Link : TFhirImmunizationExplanationList; Overload;
    function Clone : TFhirImmunizationExplanationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationExplanation to the end of the list.
    }
    function Append : TFhirImmunizationExplanation;

    
    {@member AddItem
      Add an already existing FhirImmunizationExplanation to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationExplanation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationExplanation) : Integer;
    

    {@member Insert
      Insert FhirImmunizationExplanation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationExplanation;
    

    {@member InsertItem
       Insert an existing FhirImmunizationExplanation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationExplanation);
    
    {@member Item
       Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationExplanation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationExplanation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationExplanations[index : Integer] : TFhirImmunizationExplanation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationReaction : TFhirElement
    Categorical data indicating that an adverse event is associated in time to an immunization.
  }
  {!.Net HL7Connect.Fhir.ImmunizationReaction}
  TFhirImmunizationReaction = class (TFhirElement)
  private
    FDate : TFhirDateTime;
    FDetail : TFhirResourceReference{Resource};
    FReported : TFhirBoolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateAndTime;
    Procedure SetDateST(value : TDateAndTime);
    Procedure SetDetail(value : TFhirResourceReference{Resource});
    Procedure SetReported(value : TFhirBoolean);
    Function GetReportedST : String;
    Procedure SetReportedST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationReaction; overload;
    function Clone : TFhirImmunizationReaction; overload;
    {!script show}
  published
    {@member date
      Date of reaction to the immunization.
    }
    property date : TFhirDateTime read FDate write SetDate;
    {@member dateST
      Typed access to Date of reaction to the immunization.
    }
    property dateST : TDateAndTime read GetDateST write SetDateST;

    {@member detail
      Details of the reaction.
    }
    property detail : TFhirResourceReference{Resource} read FDetail write SetDetail;

    {@member reported
      Self-reported indicator.
    }
    property reported : TFhirBoolean read FReported write SetReported;
    {@member reportedST
      Typed access to Self-reported indicator.
    }
    property reportedST : String read GetReportedST write SetReportedST;

  end;


  {@Class TFhirImmunizationReactionList
    A list of FhirImmunizationReaction
  }
  {!.Net HL7Connect.Fhir.ImmunizationReactionList}
  TFhirImmunizationReactionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationReaction;
    procedure SetItemN(index : Integer; value : TFhirImmunizationReaction);
  public
    {!script hide}
    function Link : TFhirImmunizationReactionList; Overload;
    function Clone : TFhirImmunizationReactionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationReaction to the end of the list.
    }
    function Append : TFhirImmunizationReaction;

    
    {@member AddItem
      Add an already existing FhirImmunizationReaction to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationReaction);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationReaction) : Integer;
    

    {@member Insert
      Insert FhirImmunizationReaction before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationReaction;
    

    {@member InsertItem
       Insert an existing FhirImmunizationReaction before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationReaction);
    
    {@member Item
       Get the iIndexth FhirImmunizationReaction. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationReaction. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationReaction);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationReaction;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationReactions[index : Integer] : TFhirImmunizationReaction read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationVaccinationProtocol : TFhirElement
    Contains information about the protocol under which the vaccine was administered.
  }
  {!.Net HL7Connect.Fhir.ImmunizationVaccinationProtocol}
  TFhirImmunizationVaccinationProtocol = class (TFhirElement)
  private
    FDoseSequence : TFhirInteger;
    FDescription : TFhirString;
    FAuthority : TFhirResourceReference{TFhirOrganization};
    FSeries : TFhirString;
    FSeriesDoses : TFhirInteger;
    FDoseTarget : TFhirCodeableConcept;
    FDoseStatus : TFhirCodeableConcept;
    FDoseStatusReason : TFhirCodeableConcept;
    Procedure SetDoseSequence(value : TFhirInteger);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirResourceReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
    Procedure SetSeriesDoses(value : TFhirInteger);
    Function GetSeriesDosesST : String;
    Procedure SetSeriesDosesST(value : String);
    Procedure SetDoseTarget(value : TFhirCodeableConcept);
    Procedure SetDoseStatus(value : TFhirCodeableConcept);
    Procedure SetDoseStatusReason(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationVaccinationProtocol; overload;
    function Clone : TFhirImmunizationVaccinationProtocol; overload;
    {!script show}
  published
    {@member doseSequence
      Nominal position in a series.
    }
    property doseSequence : TFhirInteger read FDoseSequence write SetDoseSequence;
    {@member doseSequenceST
      Typed access to Nominal position in a series.
    }
    property doseSequenceST : String read GetDoseSequenceST write SetDoseSequenceST;

    {@member description
      Contains the description about the protocol under which the vaccine was administered.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Contains the description about the protocol under which the vaccine was administered.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member authority
      Indicates the authority who published the protocol?  E.g. ACIP.
    }
    property authority : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;

    {@member series
      One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property series : TFhirString read FSeries write SetSeries;
    {@member seriesST
      Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property seriesST : String read GetSeriesST write SetSeriesST;

    {@member seriesDoses
      The recommended number of doses to achieve immunity.
    }
    property seriesDoses : TFhirInteger read FSeriesDoses write SetSeriesDoses;
    {@member seriesDosesST
      Typed access to The recommended number of doses to achieve immunity.
    }
    property seriesDosesST : String read GetSeriesDosesST write SetSeriesDosesST;

    {@member doseTarget
      The targeted disease.
    }
    property doseTarget : TFhirCodeableConcept read FDoseTarget write SetDoseTarget;

    {@member doseStatus
      Indicates if the immunization event should "count" against  the protocol.
    }
    property doseStatus : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;

    {@member doseStatusReason
      Provides an explanation as to why a immunization event should or should not count against the protocol.
    }
    property doseStatusReason : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;

  end;


  {@Class TFhirImmunizationVaccinationProtocolList
    A list of FhirImmunizationVaccinationProtocol
  }
  {!.Net HL7Connect.Fhir.ImmunizationVaccinationProtocolList}
  TFhirImmunizationVaccinationProtocolList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationVaccinationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationVaccinationProtocol);
  public
    {!script hide}
    function Link : TFhirImmunizationVaccinationProtocolList; Overload;
    function Clone : TFhirImmunizationVaccinationProtocolList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationVaccinationProtocol to the end of the list.
    }
    function Append : TFhirImmunizationVaccinationProtocol;

    
    {@member AddItem
      Add an already existing FhirImmunizationVaccinationProtocol to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationVaccinationProtocol);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationVaccinationProtocol) : Integer;
    

    {@member Insert
      Insert FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationVaccinationProtocol;
    

    {@member InsertItem
       Insert an existing FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationVaccinationProtocol);
    
    {@member Item
       Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationVaccinationProtocol);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationVaccinationProtocol;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationVaccinationProtocols[index : Integer] : TFhirImmunizationVaccinationProtocol read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationProfileRecommendation : TFhirElement
    Vaccine administration recommendations.
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendation}
  TFhirImmunizationProfileRecommendation = class (TFhirElement)
  private
    FRecommendationDate : TFhirDateTime;
    FVaccineType : TFhirCodeableConcept;
    FDoseNumber : TFhirInteger;
    FForecastStatus : TFhirEnum;
    FdateCriterionList : TFhirImmunizationProfileRecommendationDateCriterionList;
    FProtocol : TFhirImmunizationProfileRecommendationProtocol;
    FsupportingImmunizationList : TFhirResourceReferenceList{TFhirImmunization};
    FsupportingAdverseEventReportList : TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList;
    FsupportingPatientObservationList : TFhirResourceReferenceList{TFhirObservation};
    Procedure SetRecommendationDate(value : TFhirDateTime);
    Function GetRecommendationDateST : TDateAndTime;
    Procedure SetRecommendationDateST(value : TDateAndTime);
    Procedure SetVaccineType(value : TFhirCodeableConcept);
    Procedure SetDoseNumber(value : TFhirInteger);
    Function GetDoseNumberST : String;
    Procedure SetDoseNumberST(value : String);
    Procedure SetForecastStatus(value : TFhirEnum);
    Function GetForecastStatusST : TFhirImmunizationForecastStatus;
    Procedure SetForecastStatusST(value : TFhirImmunizationForecastStatus);
    Procedure SetProtocol(value : TFhirImmunizationProfileRecommendationProtocol);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationProfileRecommendation; overload;
    function Clone : TFhirImmunizationProfileRecommendation; overload;
    {!script show}
  published
    {@member recommendationDate
      The date of the immunization recommendation.
    }
    property recommendationDate : TFhirDateTime read FRecommendationDate write SetRecommendationDate;
    {@member recommendationDateST
      Typed access to The date of the immunization recommendation.
    }
    property recommendationDateST : TDateAndTime read GetRecommendationDateST write SetRecommendationDateST;

    {@member vaccineType
      Vaccine that pertains to the recommendation.
    }
    property vaccineType : TFhirCodeableConcept read FVaccineType write SetVaccineType;

    {@member doseNumber
      Recommended dose number.
    }
    property doseNumber : TFhirInteger read FDoseNumber write SetDoseNumber;
    {@member doseNumberST
      Typed access to Recommended dose number.
    }
    property doseNumberST : String read GetDoseNumberST write SetDoseNumberST;

    {@member forecastStatus
      Vaccine administration status.
    }
    property forecastStatus : TFhirEnum read FForecastStatus write SetForecastStatus;
    {@member forecastStatusST
      Typed access to Vaccine administration status.
    }
    property forecastStatusST : TFhirImmunizationForecastStatus read GetForecastStatusST write SetForecastStatusST;

    {@member dateCriterionList
      Vaccine date recommentations - e.g. earliest date to administer, latest date to administer, etc.
    }
    property dateCriterionList : TFhirImmunizationProfileRecommendationDateCriterionList read FDateCriterionList;

    {@member protocol
      Contains information about the protocol under which the vaccine was administered.
    }
    property protocol : TFhirImmunizationProfileRecommendationProtocol read FProtocol write SetProtocol;

    {@member supportingImmunizationList
      Immunization event history that supports the status and recommendation.
    }
    property supportingImmunizationList : TFhirResourceReferenceList{TFhirImmunization} read FSupportingImmunizationList;

    {@member supportingAdverseEventReportList
      Adverse event report information that supports the status and recommendation.
    }
    property supportingAdverseEventReportList : TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList read FSupportingAdverseEventReportList;

    {@member supportingPatientObservationList
      Patient observation that supports the status and recommendation.
    }
    property supportingPatientObservationList : TFhirResourceReferenceList{TFhirObservation} read FSupportingPatientObservationList;

  end;


  {@Class TFhirImmunizationProfileRecommendationList
    A list of FhirImmunizationProfileRecommendation
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendationList}
  TFhirImmunizationProfileRecommendationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationProfileRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationProfileRecommendation);
  public
    {!script hide}
    function Link : TFhirImmunizationProfileRecommendationList; Overload;
    function Clone : TFhirImmunizationProfileRecommendationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationProfileRecommendation to the end of the list.
    }
    function Append : TFhirImmunizationProfileRecommendation;

    
    {@member AddItem
      Add an already existing FhirImmunizationProfileRecommendation to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationProfileRecommendation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationProfileRecommendation) : Integer;
    

    {@member Insert
      Insert FhirImmunizationProfileRecommendation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationProfileRecommendation;
    

    {@member InsertItem
       Insert an existing FhirImmunizationProfileRecommendation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationProfileRecommendation);
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationProfileRecommendation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationProfileRecommendation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationProfileRecommendations[index : Integer] : TFhirImmunizationProfileRecommendation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationProfileRecommendationDateCriterion : TFhirElement
    Vaccine date recommentations - e.g. earliest date to administer, latest date to administer, etc.
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendationDateCriterion}
  TFhirImmunizationProfileRecommendationDateCriterion = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FValue : TFhirDateTime;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirDateTime);
    Function GetValueST : TDateAndTime;
    Procedure SetValueST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationProfileRecommendationDateCriterion; overload;
    function Clone : TFhirImmunizationProfileRecommendationDateCriterion; overload;
    {!script show}
  published
    {@member code
      Date classification of recommendation - e.g. earliest date to give, latest date to give, etc.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member value
      Date recommendation.
    }
    property value : TFhirDateTime read FValue write SetValue;
    {@member valueST
      Typed access to Date recommendation.
    }
    property valueST : TDateAndTime read GetValueST write SetValueST;

  end;


  {@Class TFhirImmunizationProfileRecommendationDateCriterionList
    A list of FhirImmunizationProfileRecommendationDateCriterion
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendationDateCriterionList}
  TFhirImmunizationProfileRecommendationDateCriterionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationProfileRecommendationDateCriterion;
    procedure SetItemN(index : Integer; value : TFhirImmunizationProfileRecommendationDateCriterion);
  public
    {!script hide}
    function Link : TFhirImmunizationProfileRecommendationDateCriterionList; Overload;
    function Clone : TFhirImmunizationProfileRecommendationDateCriterionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationProfileRecommendationDateCriterion to the end of the list.
    }
    function Append : TFhirImmunizationProfileRecommendationDateCriterion;

    
    {@member AddItem
      Add an already existing FhirImmunizationProfileRecommendationDateCriterion to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationProfileRecommendationDateCriterion);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationProfileRecommendationDateCriterion) : Integer;
    

    {@member Insert
      Insert FhirImmunizationProfileRecommendationDateCriterion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationProfileRecommendationDateCriterion;
    

    {@member InsertItem
       Insert an existing FhirImmunizationProfileRecommendationDateCriterion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationProfileRecommendationDateCriterion);
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendationDateCriterion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendationDateCriterion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationProfileRecommendationDateCriterion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationProfileRecommendationDateCriterion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationProfileRecommendationDateCriterions[index : Integer] : TFhirImmunizationProfileRecommendationDateCriterion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationProfileRecommendationProtocol : TFhirElement
    Contains information about the protocol under which the vaccine was administered.
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendationProtocol}
  TFhirImmunizationProfileRecommendationProtocol = class (TFhirElement)
  private
    FDoseSequence : TFhirInteger;
    FDescription : TFhirString;
    FAuthority : TFhirResourceReference{TFhirOrganization};
    FSeries : TFhirString;
    Procedure SetDoseSequence(value : TFhirInteger);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirResourceReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationProfileRecommendationProtocol; overload;
    function Clone : TFhirImmunizationProfileRecommendationProtocol; overload;
    {!script show}
  published
    {@member doseSequence
      Nominal position in a series.
    }
    property doseSequence : TFhirInteger read FDoseSequence write SetDoseSequence;
    {@member doseSequenceST
      Typed access to Nominal position in a series.
    }
    property doseSequenceST : String read GetDoseSequenceST write SetDoseSequenceST;

    {@member description
      Contains the description about the protocol under which the vaccine was administered.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Contains the description about the protocol under which the vaccine was administered.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member authority
      Indicates the authority who published the protocol?  E.g. ACIP.
    }
    property authority : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;

    {@member series
      One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property series : TFhirString read FSeries write SetSeries;
    {@member seriesST
      Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property seriesST : String read GetSeriesST write SetSeriesST;

  end;


  {@Class TFhirImmunizationProfileRecommendationProtocolList
    A list of FhirImmunizationProfileRecommendationProtocol
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendationProtocolList}
  TFhirImmunizationProfileRecommendationProtocolList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationProfileRecommendationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationProfileRecommendationProtocol);
  public
    {!script hide}
    function Link : TFhirImmunizationProfileRecommendationProtocolList; Overload;
    function Clone : TFhirImmunizationProfileRecommendationProtocolList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationProfileRecommendationProtocol to the end of the list.
    }
    function Append : TFhirImmunizationProfileRecommendationProtocol;

    
    {@member AddItem
      Add an already existing FhirImmunizationProfileRecommendationProtocol to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationProfileRecommendationProtocol);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationProfileRecommendationProtocol) : Integer;
    

    {@member Insert
      Insert FhirImmunizationProfileRecommendationProtocol before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationProfileRecommendationProtocol;
    

    {@member InsertItem
       Insert an existing FhirImmunizationProfileRecommendationProtocol before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationProfileRecommendationProtocol);
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendationProtocol. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendationProtocol. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationProfileRecommendationProtocol);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationProfileRecommendationProtocol;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationProfileRecommendationProtocols[index : Integer] : TFhirImmunizationProfileRecommendationProtocol read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationProfileRecommendationSupportingAdverseEventReport : TFhirElement
    Adverse event report information that supports the status and recommendation.
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendationSupportingAdverseEventReport}
  TFhirImmunizationProfileRecommendationSupportingAdverseEventReport = class (TFhirElement)
  private
    FidentifierList : TFhirIdList;
    FReportType : TFhirCodeableConcept;
    FReportDate : TFhirDateTime;
    FText : TFhirString;
    FreactionList : TFhirResourceReferenceList{TFhirAdverseReaction};
    Procedure SetReportType(value : TFhirCodeableConcept);
    Procedure SetReportDate(value : TFhirDateTime);
    Function GetReportDateST : TDateAndTime;
    Procedure SetReportDateST(value : TDateAndTime);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport; overload;
    function Clone : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport; overload;
    {!script show}
  published
    {@member identifierList
      Unique identifier of the adverse event report.
    }
    property identifierList : TFhirIdList read FIdentifierList;

    {@member reportType
      Advers event report classification.
    }
    property reportType : TFhirCodeableConcept read FReportType write SetReportType;

    {@member reportDate
      The date of the adverse event report.
    }
    property reportDate : TFhirDateTime read FReportDate write SetReportDate;
    {@member reportDateST
      Typed access to The date of the adverse event report.
    }
    property reportDateST : TDateAndTime read GetReportDateST write SetReportDateST;

    {@member text
      The content of the adverse event report.
    }
    property text : TFhirString read FText write SetText;
    {@member textST
      Typed access to The content of the adverse event report.
    }
    property textST : String read GetTextST write SetTextST;

    {@member reactionList
      The documented reaction described in the adverse event report.
    }
    property reactionList : TFhirResourceReferenceList{TFhirAdverseReaction} read FReactionList;

  end;


  {@Class TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList
    A list of FhirImmunizationProfileRecommendationSupportingAdverseEventReport
  }
  {!.Net HL7Connect.Fhir.ImmunizationProfileRecommendationSupportingAdverseEventReportList}
  TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
    procedure SetItemN(index : Integer; value : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
  public
    {!script hide}
    function Link : TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList; Overload;
    function Clone : TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationProfileRecommendationSupportingAdverseEventReport to the end of the list.
    }
    function Append : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;

    
    {@member AddItem
      Add an already existing FhirImmunizationProfileRecommendationSupportingAdverseEventReport to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport) : Integer;
    

    {@member Insert
      Insert FhirImmunizationProfileRecommendationSupportingAdverseEventReport before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
    

    {@member InsertItem
       Insert an existing FhirImmunizationProfileRecommendationSupportingAdverseEventReport before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendationSupportingAdverseEventReport. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationProfileRecommendationSupportingAdverseEventReport. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationProfileRecommendationSupportingAdverseEventReports[index : Integer] : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport read GetItemN write SetItemN; default;
  End;


  {@Class TFhirListEntry : TFhirElement
    Entries in this list.
  }
  {!.Net HL7Connect.Fhir.ListEntry}
  TFhirListEntry = class (TFhirElement)
  private
    FflagList : TFhirCodeableConceptList;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirResourceReference{Resource};
    Procedure SetDeleted(value : TFhirBoolean);
    Function GetDeletedST : String;
    Procedure SetDeletedST(value : String);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateAndTime;
    Procedure SetDateST(value : TDateAndTime);
    Procedure SetItem(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    {!script show}
  published
    {@member flagList
      The flag allows the system constructing the list to make one or more statements about the role and significance of the item in the list.
    }
    property flagList : TFhirCodeableConceptList read FFlagList;

    {@member deleted
      True if this item is marked as deleted in the list.
    }
    property deleted : TFhirBoolean read FDeleted write SetDeleted;
    {@member deletedST
      Typed access to True if this item is marked as deleted in the list.
    }
    property deletedST : String read GetDeletedST write SetDeletedST;

    {@member date
      When this item was added to the list.
    }
    property date : TFhirDateTime read FDate write SetDate;
    {@member dateST
      Typed access to When this item was added to the list.
    }
    property dateST : TDateAndTime read GetDateST write SetDateST;

    {@member item
      A reference to the actual resource from which data was derived.
    }
    property item : TFhirResourceReference{Resource} read FItem write SetItem;

  end;


  {@Class TFhirListEntryList
    A list of FhirListEntry
  }
  {!.Net HL7Connect.Fhir.ListEntryList}
  TFhirListEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  public
    {!script hide}
    function Link : TFhirListEntryList; Overload;
    function Clone : TFhirListEntryList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirListEntry to the end of the list.
    }
    function Append : TFhirListEntry;

    
    {@member AddItem
      Add an already existing FhirListEntry to the end of the list.
    }
    procedure AddItem(value : TFhirListEntry);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirListEntry) : Integer;
    

    {@member Insert
      Insert FhirListEntry before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirListEntry;
    

    {@member InsertItem
       Insert an existing FhirListEntry before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirListEntry);
    
    {@member Item
       Get the iIndexth FhirListEntry. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirListEntry. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirListEntry;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;


  {@Class TFhirLocationPosition : TFhirElement
    The absolute geographic location of the Location, expressed in a KML compatible manner (see notes below for KML).
  }
  {!.Net HL7Connect.Fhir.LocationPosition}
  TFhirLocationPosition = class (TFhirElement)
  private
    FLongitude : TFhirDecimal;
    FLatitude : TFhirDecimal;
    FAltitude : TFhirDecimal;
    Procedure SetLongitude(value : TFhirDecimal);
    Function GetLongitudeST : String;
    Procedure SetLongitudeST(value : String);
    Procedure SetLatitude(value : TFhirDecimal);
    Function GetLatitudeST : String;
    Procedure SetLatitudeST(value : String);
    Procedure SetAltitude(value : TFhirDecimal);
    Function GetAltitudeST : String;
    Procedure SetAltitudeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirLocationPosition; overload;
    function Clone : TFhirLocationPosition; overload;
    {!script show}
  published
    {@member longitude
      Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    }
    property longitude : TFhirDecimal read FLongitude write SetLongitude;
    {@member longitudeST
      Typed access to Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    }
    property longitudeST : String read GetLongitudeST write SetLongitudeST;

    {@member latitude
      Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    }
    property latitude : TFhirDecimal read FLatitude write SetLatitude;
    {@member latitudeST
      Typed access to Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    }
    property latitudeST : String read GetLatitudeST write SetLatitudeST;

    {@member altitude
      Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    }
    property altitude : TFhirDecimal read FAltitude write SetAltitude;
    {@member altitudeST
      Typed access to Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    }
    property altitudeST : String read GetAltitudeST write SetAltitudeST;

  end;


  {@Class TFhirLocationPositionList
    A list of FhirLocationPosition
  }
  {!.Net HL7Connect.Fhir.LocationPositionList}
  TFhirLocationPositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationPosition;
    procedure SetItemN(index : Integer; value : TFhirLocationPosition);
  public
    {!script hide}
    function Link : TFhirLocationPositionList; Overload;
    function Clone : TFhirLocationPositionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirLocationPosition to the end of the list.
    }
    function Append : TFhirLocationPosition;

    
    {@member AddItem
      Add an already existing FhirLocationPosition to the end of the list.
    }
    procedure AddItem(value : TFhirLocationPosition);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirLocationPosition) : Integer;
    

    {@member Insert
      Insert FhirLocationPosition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirLocationPosition;
    

    {@member InsertItem
       Insert an existing FhirLocationPosition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirLocationPosition);
    
    {@member Item
       Get the iIndexth FhirLocationPosition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirLocationPosition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirLocationPosition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirLocationPosition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirLocationPositions[index : Integer] : TFhirLocationPosition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationProduct : TFhirElement
    If is a product.
  }
  {!.Net HL7Connect.Fhir.MedicationProduct}
  TFhirMedicationProduct = class (TFhirElement)
  private
    FForm : TFhirCodeableConcept;
    FingredientList : TFhirMedicationProductIngredientList;
    Procedure SetForm(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationProduct; overload;
    function Clone : TFhirMedicationProduct; overload;
    {!script show}
  published
    {@member form
      Describes the form of the item.  Powder; tables; carton.
    }
    property form : TFhirCodeableConcept read FForm write SetForm;

    {@member ingredientList
      The ingredients of the medication.
    }
    property ingredientList : TFhirMedicationProductIngredientList read FIngredientList;

  end;


  {@Class TFhirMedicationProductList
    A list of FhirMedicationProduct
  }
  {!.Net HL7Connect.Fhir.MedicationProductList}
  TFhirMedicationProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationProduct;
    procedure SetItemN(index : Integer; value : TFhirMedicationProduct);
  public
    {!script hide}
    function Link : TFhirMedicationProductList; Overload;
    function Clone : TFhirMedicationProductList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationProduct to the end of the list.
    }
    function Append : TFhirMedicationProduct;

    
    {@member AddItem
      Add an already existing FhirMedicationProduct to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationProduct);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationProduct) : Integer;
    

    {@member Insert
      Insert FhirMedicationProduct before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationProduct;
    

    {@member InsertItem
       Insert an existing FhirMedicationProduct before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationProduct);
    
    {@member Item
       Get the iIndexth FhirMedicationProduct. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationProduct. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProduct);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationProduct;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationProducts[index : Integer] : TFhirMedicationProduct read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationProductIngredient : TFhirElement
    The ingredients of the medication.
  }
  {!.Net HL7Connect.Fhir.MedicationProductIngredient}
  TFhirMedicationProductIngredient = class (TFhirElement)
  private
    FItem : TFhirResourceReference{Resource};
    FAmount : TFhirRatio;
    Procedure SetItem(value : TFhirResourceReference{Resource});
    Procedure SetAmount(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationProductIngredient; overload;
    function Clone : TFhirMedicationProductIngredient; overload;
    {!script show}
  published
    {@member item
      The actual ingredient - either a substance (simple ingredient) or another medication.
    }
    property item : TFhirResourceReference{Resource} read FItem write SetItem;

    {@member amount
      Specifies how many (or how much) of the items there are in this Medication.  E.g. 250 mg per tablet.
    }
    property amount : TFhirRatio read FAmount write SetAmount;

  end;


  {@Class TFhirMedicationProductIngredientList
    A list of FhirMedicationProductIngredient
  }
  {!.Net HL7Connect.Fhir.MedicationProductIngredientList}
  TFhirMedicationProductIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationProductIngredient);
  public
    {!script hide}
    function Link : TFhirMedicationProductIngredientList; Overload;
    function Clone : TFhirMedicationProductIngredientList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationProductIngredient to the end of the list.
    }
    function Append : TFhirMedicationProductIngredient;

    
    {@member AddItem
      Add an already existing FhirMedicationProductIngredient to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationProductIngredient);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationProductIngredient) : Integer;
    

    {@member Insert
      Insert FhirMedicationProductIngredient before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationProductIngredient;
    

    {@member InsertItem
       Insert an existing FhirMedicationProductIngredient before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationProductIngredient);
    
    {@member Item
       Get the iIndexth FhirMedicationProductIngredient. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationProductIngredient. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProductIngredient);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationProductIngredient;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationProductIngredients[index : Integer] : TFhirMedicationProductIngredient read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPackage : TFhirElement
    Specifies Ingredient / Product / Package.
  }
  {!.Net HL7Connect.Fhir.MedicationPackage}
  TFhirMedicationPackage = class (TFhirElement)
  private
    FContainer : TFhirCodeableConcept;
    FcontentList : TFhirMedicationPackageContentList;
    Procedure SetContainer(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPackage; overload;
    function Clone : TFhirMedicationPackage; overload;
    {!script show}
  published
    {@member container
      The kind of container that this package comes as.
    }
    property container : TFhirCodeableConcept read FContainer write SetContainer;

    {@member contentList
      A set of components that go to make up the described item.
    }
    property contentList : TFhirMedicationPackageContentList read FContentList;

  end;


  {@Class TFhirMedicationPackageList
    A list of FhirMedicationPackage
  }
  {!.Net HL7Connect.Fhir.MedicationPackageList}
  TFhirMedicationPackageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPackage;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackage);
  public
    {!script hide}
    function Link : TFhirMedicationPackageList; Overload;
    function Clone : TFhirMedicationPackageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPackage to the end of the list.
    }
    function Append : TFhirMedicationPackage;

    
    {@member AddItem
      Add an already existing FhirMedicationPackage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPackage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPackage) : Integer;
    

    {@member Insert
      Insert FhirMedicationPackage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPackage;
    

    {@member InsertItem
       Insert an existing FhirMedicationPackage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPackage);
    
    {@member Item
       Get the iIndexth FhirMedicationPackage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPackage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPackage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPackages[index : Integer] : TFhirMedicationPackage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPackageContent : TFhirElement
    A set of components that go to make up the described item.
  }
  {!.Net HL7Connect.Fhir.MedicationPackageContent}
  TFhirMedicationPackageContent = class (TFhirElement)
  private
    FItem : TFhirResourceReference{TFhirMedication};
    FAmount : TFhirQuantity;
    Procedure SetItem(value : TFhirResourceReference{TFhirMedication});
    Procedure SetAmount(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPackageContent; overload;
    function Clone : TFhirMedicationPackageContent; overload;
    {!script show}
  published
    {@member item
      The product that is in the package.
    }
    property item : TFhirResourceReference{TFhirMedication} read FItem write SetItem;

    {@member amount
      The amount of the product that is in the package.
    }
    property amount : TFhirQuantity read FAmount write SetAmount;

  end;


  {@Class TFhirMedicationPackageContentList
    A list of FhirMedicationPackageContent
  }
  {!.Net HL7Connect.Fhir.MedicationPackageContentList}
  TFhirMedicationPackageContentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPackageContent;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackageContent);
  public
    {!script hide}
    function Link : TFhirMedicationPackageContentList; Overload;
    function Clone : TFhirMedicationPackageContentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPackageContent to the end of the list.
    }
    function Append : TFhirMedicationPackageContent;

    
    {@member AddItem
      Add an already existing FhirMedicationPackageContent to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPackageContent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPackageContent) : Integer;
    

    {@member Insert
      Insert FhirMedicationPackageContent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPackageContent;
    

    {@member InsertItem
       Insert an existing FhirMedicationPackageContent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPackageContent);
    
    {@member Item
       Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackageContent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPackageContent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPackageContents[index : Integer] : TFhirMedicationPackageContent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationAdministrationDosage : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationAdministrationDosage}
  TFhirMedicationAdministrationDosage = class (TFhirElement)
  private
    FTiming : TFhirSchedule;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetTiming(value : TFhirSchedule);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationAdministrationDosage; overload;
    function Clone : TFhirMedicationAdministrationDosage; overload;
    {!script show}
  published
    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirSchedule read FTiming write SetTiming;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of themedication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the medication is introduced into the patient. Typically the rate for an infusion e.g. 200ml in 2 hours.  May also expressed as a rate per unit of time such as 100ml per hour - the duration is then not specified, or is specified in the quantity.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that my be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationAdministrationDosageList
    A list of FhirMedicationAdministrationDosage
  }
  {!.Net HL7Connect.Fhir.MedicationAdministrationDosageList}
  TFhirMedicationAdministrationDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministrationDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationDosage);
  public
    {!script hide}
    function Link : TFhirMedicationAdministrationDosageList; Overload;
    function Clone : TFhirMedicationAdministrationDosageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationAdministrationDosage to the end of the list.
    }
    function Append : TFhirMedicationAdministrationDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationAdministrationDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationAdministrationDosage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationAdministrationDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationAdministrationDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationAdministrationDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationAdministrationDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationAdministrationDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationAdministrationDosages[index : Integer] : TFhirMedicationAdministrationDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseDispense : TFhirElement
    Indicates the details of the dispense event such as the days supply and quantity of medication dispensed.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispense}
  TFhirMedicationDispenseDispense = class (TFhirElement)
  private
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FMedication : TFhirResourceReference{TFhirMedication};
    FWhenPrepared : TFhirPeriod;
    FWhenHandedOver : TFhirPeriod;
    FDestination : TFhirResourceReference{TFhirLocation};
    FreceiverList : TFhirResourceReferenceList{TFhirPractitioner};
    FdosageList : TFhirMedicationDispenseDispenseDosageList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationDispenseStatus;
    Procedure SetStatusST(value : TFhirMedicationDispenseStatus);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMedication(value : TFhirResourceReference{TFhirMedication});
    Procedure SetWhenPrepared(value : TFhirPeriod);
    Procedure SetWhenHandedOver(value : TFhirPeriod);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseDispense; overload;
    function Clone : TFhirMedicationDispenseDispense; overload;
    {!script show}
  published
    {@member identifier
      Identifier assigned by the dispensing facility.   This is an identifier assigned outside FHIR.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member status
      A code specifying the state of the dispense event.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to A code specifying the state of the dispense event.
    }
    property statusST : TFhirMedicationDispenseStatus read GetStatusST write SetStatusST;

    {@member type_
      Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member quantity
      The amount of medication that has been dispensed. Includes unit of measure.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member medication
      Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property medication : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;

    {@member whenPrepared
      The time the dispense event occurred.
    }
    property whenPrepared : TFhirPeriod read FWhenPrepared write SetWhenPrepared;

    {@member whenHandedOver
      The time the dispense event occurred.
    }
    property whenHandedOver : TFhirPeriod read FWhenHandedOver write SetWhenHandedOver;

    {@member destination
      Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member receiverList
      Identifies the person who picked up the medication.
    }
    property receiverList : TFhirResourceReferenceList{TFhirPractitioner} read FReceiverList;

    {@member dosageList
      Indicates how the medication is to be used by the patient.
    }
    property dosageList : TFhirMedicationDispenseDispenseDosageList read FDosageList;

  end;


  {@Class TFhirMedicationDispenseDispenseList
    A list of FhirMedicationDispenseDispense
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseList}
  TFhirMedicationDispenseDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseDispense);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseDispenseList; Overload;
    function Clone : TFhirMedicationDispenseDispenseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseDispense to the end of the list.
    }
    function Append : TFhirMedicationDispenseDispense;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseDispense to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseDispense);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseDispense) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseDispense;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseDispense);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseDispenses[index : Integer] : TFhirMedicationDispenseDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseDispenseDosage : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseDosage}
  TFhirMedicationDispenseDispenseDosage = class (TFhirElement)
  private
    FAdditionalInstructions : TFhirType;
    FTiming : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetAdditionalInstructions(value : TFhirType);
    Procedure SetTiming(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseDispenseDosage; overload;
    function Clone : TFhirMedicationDispenseDispenseDosage; overload;
    {!script show}
  published
    {@member additionalInstructions
      Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    }
    property additionalInstructions : TFhirType read FAdditionalInstructions write SetAdditionalInstructions;

    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirType read FTiming write SetTiming;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of the therapeutic or other substance given at one administration event.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that my be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationDispenseDispenseDosageList
    A list of FhirMedicationDispenseDispenseDosage
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseDosageList}
  TFhirMedicationDispenseDispenseDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseDispenseDosageList; Overload;
    function Clone : TFhirMedicationDispenseDispenseDosageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseDispenseDosage to the end of the list.
    }
    function Append : TFhirMedicationDispenseDispenseDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseDispenseDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseDispenseDosage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseDispenseDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseDispenseDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseDispenseDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispenseDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispenseDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseDispenseDosages[index : Integer] : TFhirMedicationDispenseDispenseDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseSubstitution : TFhirElement
    Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but doesn't happen, in other cases substitution is not expected but does happen.  This block explains what substitition did or did not happen and why.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseSubstitution}
  TFhirMedicationDispenseSubstitution = class (TFhirElement)
  private
    FType_ : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FresponsiblePartyList : TFhirResourceReferenceList{TFhirPractitioner};
    Procedure SetType_(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseSubstitution; overload;
    function Clone : TFhirMedicationDispenseSubstitution; overload;
    {!script show}
  published
    {@member type_
      A code signifying whether a different drug was dispensed from what was prescribed.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member reasonList
      Indicates the reason for the substitution of (or lack of substitution) from what was prescribed.
    }
    property reasonList : TFhirCodeableConceptList read FReasonList;

    {@member responsiblePartyList
      The person or organization that has primary responsibility for the substitution.
    }
    property responsiblePartyList : TFhirResourceReferenceList{TFhirPractitioner} read FResponsiblePartyList;

  end;


  {@Class TFhirMedicationDispenseSubstitutionList
    A list of FhirMedicationDispenseSubstitution
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseSubstitutionList}
  TFhirMedicationDispenseSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseSubstitution);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseSubstitutionList; Overload;
    function Clone : TFhirMedicationDispenseSubstitutionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseSubstitution to the end of the list.
    }
    function Append : TFhirMedicationDispenseSubstitution;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseSubstitution to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseSubstitution);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseSubstitution) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseSubstitution;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseSubstitution;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseSubstitutions[index : Integer] : TFhirMedicationDispenseSubstitution read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionDosageInstruction : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDosageInstruction}
  TFhirMedicationPrescriptionDosageInstruction = class (TFhirElement)
  private
    FDosageInstructionsText : TFhirString;
    FAdditionalInstructions : TFhirType;
    FTiming : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDoseQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetDosageInstructionsText(value : TFhirString);
    Function GetDosageInstructionsTextST : String;
    Procedure SetDosageInstructionsTextST(value : String);
    Procedure SetAdditionalInstructions(value : TFhirType);
    Procedure SetTiming(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetDoseQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionDosageInstruction; overload;
    function Clone : TFhirMedicationPrescriptionDosageInstruction; overload;
    {!script show}
  published
    {@member dosageInstructionsText
      Free text dosage instructions for cases where the instructions are too complex to code.
    }
    property dosageInstructionsText : TFhirString read FDosageInstructionsText write SetDosageInstructionsText;
    {@member dosageInstructionsTextST
      Typed access to Free text dosage instructions for cases where the instructions are too complex to code.
    }
    property dosageInstructionsTextST : String read GetDosageInstructionsTextST write SetDosageInstructionsTextST;

    {@member additionalInstructions
      Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    }
    property additionalInstructions : TFhirType read FAdditionalInstructions write SetAdditionalInstructions;

    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirType read FTiming write SetTiming;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member doseQuantity
      The amount of the therapeutic or other substance given at one administration event.
    }
    property doseQuantity : TFhirQuantity read FDoseQuantity write SetDoseQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that my be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationPrescriptionDosageInstructionList
    A list of FhirMedicationPrescriptionDosageInstruction
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDosageInstructionList}
  TFhirMedicationPrescriptionDosageInstructionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionDosageInstructionList; Overload;
    function Clone : TFhirMedicationPrescriptionDosageInstructionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionDosageInstruction to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionDosageInstruction;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionDosageInstruction to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionDosageInstruction) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionDosageInstruction before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionDosageInstruction before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDosageInstruction. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDosageInstruction. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionDosageInstructions[index : Integer] : TFhirMedicationPrescriptionDosageInstruction read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionDispense : TFhirElement
    Deals with details of the dispense part of the order.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDispense}
  TFhirMedicationPrescriptionDispense = class (TFhirElement)
  private
    FMedication : TFhirResourceReference{TFhirMedication};
    FValidityPeriod : TFhirPeriod;
    FNumberOfRepeatsAllowed : TFhirInteger;
    FQuantity : TFhirQuantity;
    FExpectedSupplyDuration : TFhirQuantity;
    Procedure SetMedication(value : TFhirResourceReference{TFhirMedication});
    Procedure SetValidityPeriod(value : TFhirPeriod);
    Procedure SetNumberOfRepeatsAllowed(value : TFhirInteger);
    Function GetNumberOfRepeatsAllowedST : String;
    Procedure SetNumberOfRepeatsAllowedST(value : String);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetExpectedSupplyDuration(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionDispense; overload;
    function Clone : TFhirMedicationPrescriptionDispense; overload;
    {!script show}
  published
    {@member medication
      Identifies the medication that is to be dispensed.  This may be a more specifically defined than the medicationPrescription.medication . This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property medication : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;

    {@member validityPeriod
      Design Comments: This indicates the validity period of a prescription (stale dating the Prescription) 
It reflects the prescriber perspective for the validity of the prescription. Dispenses must not be made against the prescription outside of this period. The lower-bound of the Dispensing Window signifies the earliest date that the prescription can be filled for the first time. If an upper-bound is not specified then the Prescription is open-ended or will default to a stale-date based on regulations. 
Rationale: Indicates when the Prescription becomes valid, and when it ceases to be a dispensable Prescription.
    }
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    {@member numberOfRepeatsAllowed
      An integer indicating the number of repeats of the Dispense. 
UsageNotes: For example, the number of times the prescribed quantity is to be supplied including the initial standard fill.
    }
    property numberOfRepeatsAllowed : TFhirInteger read FNumberOfRepeatsAllowed write SetNumberOfRepeatsAllowed;
    {@member numberOfRepeatsAllowedST
      Typed access to An integer indicating the number of repeats of the Dispense. 
UsageNotes: For example, the number of times the prescribed quantity is to be supplied including the initial standard fill.
    }
    property numberOfRepeatsAllowedST : String read GetNumberOfRepeatsAllowedST write SetNumberOfRepeatsAllowedST;

    {@member quantity
      The amount that is to be dispensed.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member expectedSupplyDuration
      Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. 
In some situations, this attribute may be used instead of quantity to identify the amount supplied by how long it is expected to last, rather than the physical quantity issued. E.g. 90 days supply of medication (based on an ordered dosage) When possible, it is always better to specify quantity, as this tends to be more precise. expectedSupplyDuration will always be an estimate that can be influenced by external factors.
    }
    property expectedSupplyDuration : TFhirQuantity read FExpectedSupplyDuration write SetExpectedSupplyDuration;

  end;


  {@Class TFhirMedicationPrescriptionDispenseList
    A list of FhirMedicationPrescriptionDispense
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDispenseList}
  TFhirMedicationPrescriptionDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionDispense);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionDispenseList; Overload;
    function Clone : TFhirMedicationPrescriptionDispenseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionDispense to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionDispense;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionDispense to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionDispense);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionDispense) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionDispense;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionDispense);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionDispenses[index : Integer] : TFhirMedicationPrescriptionDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionSubstitution : TFhirElement
    Indicates whether or not substitution can or should as part of the dispense.  In some cases substitution must  happen, in other cases substitution must not happen, and in others it does not matter.  This block explains the prescribers intent.  If nothing is specified substitution may be done.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionSubstitution}
  TFhirMedicationPrescriptionSubstitution = class (TFhirElement)
  private
    FType_ : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionSubstitution; overload;
    function Clone : TFhirMedicationPrescriptionSubstitution; overload;
    {!script show}
  published
    {@member type_
      A code signifying whether a different drug should be dispensed from what was prescribed.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member reason
      Indicates the reason for the substitution why substitution must or must not be performed.
    }
    property reason : TFhirCodeableConcept read FReason write SetReason;

  end;


  {@Class TFhirMedicationPrescriptionSubstitutionList
    A list of FhirMedicationPrescriptionSubstitution
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionSubstitutionList}
  TFhirMedicationPrescriptionSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionSubstitutionList; Overload;
    function Clone : TFhirMedicationPrescriptionSubstitutionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionSubstitution to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionSubstitution;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionSubstitution to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionSubstitution);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionSubstitution) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionSubstitution before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionSubstitution before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionSubstitution. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionSubstitution. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionSubstitutions[index : Integer] : TFhirMedicationPrescriptionSubstitution read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationStatementDosage : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationStatementDosage}
  TFhirMedicationStatementDosage = class (TFhirElement)
  private
    FTiming : TFhirSchedule;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetTiming(value : TFhirSchedule);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationStatementDosage; overload;
    function Clone : TFhirMedicationStatementDosage; overload;
    {!script show}
  published
    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirSchedule read FTiming write SetTiming;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of the therapeutic or other substance given at one administration event.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that my be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationStatementDosageList
    A list of FhirMedicationStatementDosage
  }
  {!.Net HL7Connect.Fhir.MedicationStatementDosageList}
  TFhirMedicationStatementDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationStatementDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationStatementDosage);
  public
    {!script hide}
    function Link : TFhirMedicationStatementDosageList; Overload;
    function Clone : TFhirMedicationStatementDosageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationStatementDosage to the end of the list.
    }
    function Append : TFhirMedicationStatementDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationStatementDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationStatementDosage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationStatementDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationStatementDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationStatementDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationStatementDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationStatementDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationStatementDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationStatementDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationStatementDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationStatementDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationStatementDosages[index : Integer] : TFhirMedicationStatementDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageResponse : TFhirElement
    Information about the message that this message is a response to.  Only present if this message is a response.
  }
  {!.Net HL7Connect.Fhir.MessageResponse}
  TFhirMessageResponse = class (TFhirElement)
  private
    FIdentifier : TFhirId;
    FCode : TFhirEnum;
    FDetails : TFhirResourceReference{TFhirOperationOutcome};
    Procedure SetIdentifier(value : TFhirId);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResponseCode;
    Procedure SetCodeST(value : TFhirResponseCode);
    Procedure SetDetails(value : TFhirResourceReference{TFhirOperationOutcome});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageResponse; overload;
    function Clone : TFhirMessageResponse; overload;
    {!script show}
  published
    {@member identifier
      The id of the message that this a response to.
    }
    property identifier : TFhirId read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to The id of the message that this a response to.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member code
      Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    }
    property code : TFhirEnum read FCode write SetCode;
    {@member codeST
      Typed access to Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    }
    property codeST : TFhirResponseCode read GetCodeST write SetCodeST;

    {@member details
      Full details of any issues found in the message.
    }
    property details : TFhirResourceReference{TFhirOperationOutcome} read FDetails write SetDetails;

  end;


  {@Class TFhirMessageResponseList
    A list of FhirMessageResponse
  }
  {!.Net HL7Connect.Fhir.MessageResponseList}
  TFhirMessageResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageResponse);
  public
    {!script hide}
    function Link : TFhirMessageResponseList; Overload;
    function Clone : TFhirMessageResponseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMessageResponse to the end of the list.
    }
    function Append : TFhirMessageResponse;

    
    {@member AddItem
      Add an already existing FhirMessageResponse to the end of the list.
    }
    procedure AddItem(value : TFhirMessageResponse);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageResponse) : Integer;
    

    {@member Insert
      Insert FhirMessageResponse before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageResponse;
    

    {@member InsertItem
       Insert an existing FhirMessageResponse before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageResponse);
    
    {@member Item
       Get the iIndexth FhirMessageResponse. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageResponse. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageResponse);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageResponse;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageResponses[index : Integer] : TFhirMessageResponse read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageSource : TFhirElement
    The source application from which this message originated.
  }
  {!.Net HL7Connect.Fhir.MessageSource}
  TFhirMessageSource = class (TFhirElement)
  private
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContact;
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSoftware(value : TFhirString);
    Function GetSoftwareST : String;
    Procedure SetSoftwareST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetContact(value : TFhirContact);
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageSource; overload;
    function Clone : TFhirMessageSource; overload;
    {!script show}
  published
    {@member name
      Human readable name for the target system.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Human readable name for the target system.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member software
      May include configuration or other information useful in debugging.
    }
    property software : TFhirString read FSoftware write SetSoftware;
    {@member softwareST
      Typed access to May include configuration or other information useful in debugging.
    }
    property softwareST : String read GetSoftwareST write SetSoftwareST;

    {@member version
      Can convey versions of multiple systems in situations where a message passes through multiple hands.
    }
    property version : TFhirString read FVersion write SetVersion;
    {@member versionST
      Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    }
    property versionST : String read GetVersionST write SetVersionST;

    {@member contact
      An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    }
    property contact : TFhirContact read FContact write SetContact;

    {@member endpoint
      Identifies the routing target to send acknowledgements to.
    }
    property endpoint : TFhirUri read FEndpoint write SetEndpoint;
    {@member endpointST
      Typed access to Identifies the routing target to send acknowledgements to.
    }
    property endpointST : String read GetEndpointST write SetEndpointST;

  end;


  {@Class TFhirMessageSourceList
    A list of FhirMessageSource
  }
  {!.Net HL7Connect.Fhir.MessageSourceList}
  TFhirMessageSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageSource;
    procedure SetItemN(index : Integer; value : TFhirMessageSource);
  public
    {!script hide}
    function Link : TFhirMessageSourceList; Overload;
    function Clone : TFhirMessageSourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMessageSource to the end of the list.
    }
    function Append : TFhirMessageSource;

    
    {@member AddItem
      Add an already existing FhirMessageSource to the end of the list.
    }
    procedure AddItem(value : TFhirMessageSource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageSource) : Integer;
    

    {@member Insert
      Insert FhirMessageSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageSource;
    

    {@member InsertItem
       Insert an existing FhirMessageSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageSource);
    
    {@member Item
       Get the iIndexth FhirMessageSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageSources[index : Integer] : TFhirMessageSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageDestination : TFhirElement
    The destination application which the message is intended for.
  }
  {!.Net HL7Connect.Fhir.MessageDestination}
  TFhirMessageDestination = class (TFhirElement)
  private
    FName : TFhirString;
    FTarget : TFhirResourceReference{TFhirDevice};
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTarget(value : TFhirResourceReference{TFhirDevice});
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageDestination; overload;
    function Clone : TFhirMessageDestination; overload;
    {!script show}
  published
    {@member name
      Human readable name for the source system.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Human readable name for the source system.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member target
      Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    }
    property target : TFhirResourceReference{TFhirDevice} read FTarget write SetTarget;

    {@member endpoint
      Indicates where the message should be routed to.
    }
    property endpoint : TFhirUri read FEndpoint write SetEndpoint;
    {@member endpointST
      Typed access to Indicates where the message should be routed to.
    }
    property endpointST : String read GetEndpointST write SetEndpointST;

  end;


  {@Class TFhirMessageDestinationList
    A list of FhirMessageDestination
  }
  {!.Net HL7Connect.Fhir.MessageDestinationList}
  TFhirMessageDestinationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageDestination);
  public
    {!script hide}
    function Link : TFhirMessageDestinationList; Overload;
    function Clone : TFhirMessageDestinationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMessageDestination to the end of the list.
    }
    function Append : TFhirMessageDestination;

    
    {@member AddItem
      Add an already existing FhirMessageDestination to the end of the list.
    }
    procedure AddItem(value : TFhirMessageDestination);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageDestination) : Integer;
    

    {@member Insert
      Insert FhirMessageDestination before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageDestination;
    

    {@member InsertItem
       Insert an existing FhirMessageDestination before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageDestination);
    
    {@member Item
       Get the iIndexth FhirMessageDestination. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageDestination. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageDestination);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageDestination;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageDestinations[index : Integer] : TFhirMessageDestination read GetItemN write SetItemN; default;
  End;


  {@Class TFhirObservationReferenceRange : TFhirElement
    Guidance on how to interpret the value by comparison to a normal or recommended range.
  }
  {!.Net HL7Connect.Fhir.ObservationReferenceRange}
  TFhirObservationReferenceRange = class (TFhirElement)
  private
    FMeaning : TFhirCodeableConcept;
    FRange : TFhirType;
    Procedure SetMeaning(value : TFhirCodeableConcept);
    Procedure SetRange(value : TFhirType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirObservationReferenceRange; overload;
    function Clone : TFhirObservationReferenceRange; overload;
    {!script show}
  published
    {@member meaning
      Code for the meaning of the reference range.
    }
    property meaning : TFhirCodeableConcept read FMeaning write SetMeaning;

    {@member range
      Actual value of the reference range.  May be a quantity (<20mg/L), a range (10-20 umol/L), or some text.
    }
    property range : TFhirType read FRange write SetRange;

  end;


  {@Class TFhirObservationReferenceRangeList
    A list of FhirObservationReferenceRange
  }
  {!.Net HL7Connect.Fhir.ObservationReferenceRangeList}
  TFhirObservationReferenceRangeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirObservationReferenceRange);
  public
    {!script hide}
    function Link : TFhirObservationReferenceRangeList; Overload;
    function Clone : TFhirObservationReferenceRangeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirObservationReferenceRange to the end of the list.
    }
    function Append : TFhirObservationReferenceRange;

    
    {@member AddItem
      Add an already existing FhirObservationReferenceRange to the end of the list.
    }
    procedure AddItem(value : TFhirObservationReferenceRange);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirObservationReferenceRange) : Integer;
    

    {@member Insert
      Insert FhirObservationReferenceRange before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirObservationReferenceRange;
    

    {@member InsertItem
       Insert an existing FhirObservationReferenceRange before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirObservationReferenceRange);
    
    {@member Item
       Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirObservationReferenceRange);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirObservationReferenceRange;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirObservationReferenceRanges[index : Integer] : TFhirObservationReferenceRange read GetItemN write SetItemN; default;
  End;


  {@Class TFhirObservationComponent : TFhirElement
    Component observation.
  }
  {!.Net HL7Connect.Fhir.ObservationComponent}
  TFhirObservationComponent = class (TFhirElement)
  private
    FName : TFhirCodeableConcept;
    FValue : TFhirType;
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirObservationComponent; overload;
    function Clone : TFhirObservationComponent; overload;
    {!script show}
  published
    {@member name
      Identifies what type of sub-observation was performed.
    }
    property name : TFhirCodeableConcept read FName write SetName;

    {@member value
      The information determined as a result of making the sub-observation.
    }
    property value : TFhirType read FValue write SetValue;

  end;


  {@Class TFhirObservationComponentList
    A list of FhirObservationComponent
  }
  {!.Net HL7Connect.Fhir.ObservationComponentList}
  TFhirObservationComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationComponent;
    procedure SetItemN(index : Integer; value : TFhirObservationComponent);
  public
    {!script hide}
    function Link : TFhirObservationComponentList; Overload;
    function Clone : TFhirObservationComponentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirObservationComponent to the end of the list.
    }
    function Append : TFhirObservationComponent;

    
    {@member AddItem
      Add an already existing FhirObservationComponent to the end of the list.
    }
    procedure AddItem(value : TFhirObservationComponent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirObservationComponent) : Integer;
    

    {@member Insert
      Insert FhirObservationComponent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirObservationComponent;
    

    {@member InsertItem
       Insert an existing FhirObservationComponent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirObservationComponent);
    
    {@member Item
       Get the iIndexth FhirObservationComponent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirObservationComponent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirObservationComponent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirObservationComponent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirObservationComponents[index : Integer] : TFhirObservationComponent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOperationOutcomeIssue : TFhirElement
    An error, warning or information message that results from a system action.
  }
  {!.Net HL7Connect.Fhir.OperationOutcomeIssue}
  TFhirOperationOutcomeIssue = class (TFhirElement)
  private
    FSeverity : TFhirEnum;
    FType_ : TFhirCoding;
    FDetails : TFhirString;
    FlocationList : TFhirStringList;
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirIssueSeverity;
    Procedure SetSeverityST(value : TFhirIssueSeverity);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetDetails(value : TFhirString);
    Function GetDetailsST : String;
    Procedure SetDetailsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    {!script show}
  published
    {@member severity
      Indicates whether the issue indicates a variation from successful processing.
    }
    property severity : TFhirEnum read FSeverity write SetSeverity;
    {@member severityST
      Typed access to Indicates whether the issue indicates a variation from successful processing.
    }
    property severityST : TFhirIssueSeverity read GetSeverityST write SetSeverityST;

    {@member type_
      A code indicating the type of error, warning or information message.
    }
    property type_ : TFhirCoding read FType_ write SetType_;

    {@member details
      Additional description of the issue.
    }
    property details : TFhirString read FDetails write SetDetails;
    {@member detailsST
      Typed access to Additional description of the issue.
    }
    property detailsST : String read GetDetailsST write SetDetailsST;

    {@member locationList
      A simple XPath limited to element names, repetition indicators and the default child access that identifies one of the elements in the resource that caused this issue to be raised.
    }
    property locationList : TFhirStringList read FLocationList;

  end;


  {@Class TFhirOperationOutcomeIssueList
    A list of FhirOperationOutcomeIssue
  }
  {!.Net HL7Connect.Fhir.OperationOutcomeIssueList}
  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  public
    {!script hide}
    function Link : TFhirOperationOutcomeIssueList; Overload;
    function Clone : TFhirOperationOutcomeIssueList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirOperationOutcomeIssue to the end of the list.
    }
    function Append : TFhirOperationOutcomeIssue;

    
    {@member AddItem
      Add an already existing FhirOperationOutcomeIssue to the end of the list.
    }
    procedure AddItem(value : TFhirOperationOutcomeIssue);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;
    

    {@member Insert
      Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;
    

    {@member InsertItem
       Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);
    
    {@member Item
       Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOperationOutcomeIssue;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOrderWhen : TFhirElement
    When order should be fulfilled.
  }
  {!.Net HL7Connect.Fhir.OrderWhen}
  TFhirOrderWhen = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FSchedule : TFhirSchedule;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSchedule(value : TFhirSchedule);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOrderWhen; overload;
    function Clone : TFhirOrderWhen; overload;
    {!script show}
  published
    {@member code
      Code specifies when request should be done. The code may simply be a priority code.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member schedule
      A formal schedule.
    }
    property schedule : TFhirSchedule read FSchedule write SetSchedule;

  end;


  {@Class TFhirOrderWhenList
    A list of FhirOrderWhen
  }
  {!.Net HL7Connect.Fhir.OrderWhenList}
  TFhirOrderWhenList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrderWhen;
    procedure SetItemN(index : Integer; value : TFhirOrderWhen);
  public
    {!script hide}
    function Link : TFhirOrderWhenList; Overload;
    function Clone : TFhirOrderWhenList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirOrderWhen to the end of the list.
    }
    function Append : TFhirOrderWhen;

    
    {@member AddItem
      Add an already existing FhirOrderWhen to the end of the list.
    }
    procedure AddItem(value : TFhirOrderWhen);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOrderWhen) : Integer;
    

    {@member Insert
      Insert FhirOrderWhen before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOrderWhen;
    

    {@member InsertItem
       Insert an existing FhirOrderWhen before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOrderWhen);
    
    {@member Item
       Get the iIndexth FhirOrderWhen. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOrderWhen. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOrderWhen);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOrderWhen;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOrderWhens[index : Integer] : TFhirOrderWhen read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOrganizationContact : TFhirElement
    Contact for the organization for a certain purpose.
  }
  {!.Net HL7Connect.Fhir.OrganizationContact}
  TFhirOrganizationContact = class (TFhirElement)
  private
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactList;
    FAddress : TFhirAddress;
    FGender : TFhirCodeableConcept;
    Procedure SetPurpose(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirHumanName);
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetGender(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOrganizationContact; overload;
    function Clone : TFhirOrganizationContact; overload;
    {!script show}
  published
    {@member purpose
      Indicates a purpose for which the contact can be reached.
    }
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;

    {@member name
      A name associated with the contact.
    }
    property name : TFhirHumanName read FName write SetName;

    {@member telecomList
      A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    }
    property telecomList : TFhirContactList read FTelecomList;

    {@member address
      Visiting or postal addresses for the contact.
    }
    property address : TFhirAddress read FAddress write SetAddress;

    {@member gender
      Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    }
    property gender : TFhirCodeableConcept read FGender write SetGender;

  end;


  {@Class TFhirOrganizationContactList
    A list of FhirOrganizationContact
  }
  {!.Net HL7Connect.Fhir.OrganizationContactList}
  TFhirOrganizationContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationContact;
    procedure SetItemN(index : Integer; value : TFhirOrganizationContact);
  public
    {!script hide}
    function Link : TFhirOrganizationContactList; Overload;
    function Clone : TFhirOrganizationContactList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirOrganizationContact to the end of the list.
    }
    function Append : TFhirOrganizationContact;

    
    {@member AddItem
      Add an already existing FhirOrganizationContact to the end of the list.
    }
    procedure AddItem(value : TFhirOrganizationContact);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOrganizationContact) : Integer;
    

    {@member Insert
      Insert FhirOrganizationContact before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOrganizationContact;
    

    {@member InsertItem
       Insert an existing FhirOrganizationContact before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOrganizationContact);
    
    {@member Item
       Get the iIndexth FhirOrganizationContact. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOrganizationContact. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationContact);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOrganizationContact;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOrganizationContacts[index : Integer] : TFhirOrganizationContact read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientContact : TFhirElement
    A contact party (e.g. guardian, partner, friend) for the patient.
  }
  {!.Net HL7Connect.Fhir.PatientContact}
  TFhirPatientContact = class (TFhirElement)
  private
    FrelationshipList : TFhirCodeableConceptList;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactList;
    FAddress : TFhirAddress;
    FGender : TFhirCodeableConcept;
    FOrganization : TFhirResourceReference{TFhirOrganization};
    Procedure SetName(value : TFhirHumanName);
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetGender(value : TFhirCodeableConcept);
    Procedure SetOrganization(value : TFhirResourceReference{TFhirOrganization});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientContact; overload;
    function Clone : TFhirPatientContact; overload;
    {!script show}
  published
    {@member relationshipList
      The nature of the relationship between the patient and the contact person.
    }
    property relationshipList : TFhirCodeableConceptList read FRelationshipList;

    {@member name
      A name associated with the person.
    }
    property name : TFhirHumanName read FName write SetName;

    {@member telecomList
      A contact detail for the person, e.g. a telephone number or an email address.
    }
    property telecomList : TFhirContactList read FTelecomList;

    {@member address
      Address for the contact person.
    }
    property address : TFhirAddress read FAddress write SetAddress;

    {@member gender
      Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    }
    property gender : TFhirCodeableConcept read FGender write SetGender;

    {@member organization
      Organization on behalf of which the contact is acting or for which the contact is working.
    }
    property organization : TFhirResourceReference{TFhirOrganization} read FOrganization write SetOrganization;

  end;


  {@Class TFhirPatientContactList
    A list of FhirPatientContact
  }
  {!.Net HL7Connect.Fhir.PatientContactList}
  TFhirPatientContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientContact;
    procedure SetItemN(index : Integer; value : TFhirPatientContact);
  public
    {!script hide}
    function Link : TFhirPatientContactList; Overload;
    function Clone : TFhirPatientContactList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirPatientContact to the end of the list.
    }
    function Append : TFhirPatientContact;

    
    {@member AddItem
      Add an already existing FhirPatientContact to the end of the list.
    }
    procedure AddItem(value : TFhirPatientContact);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientContact) : Integer;
    

    {@member Insert
      Insert FhirPatientContact before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientContact;
    

    {@member InsertItem
       Insert an existing FhirPatientContact before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientContact);
    
    {@member Item
       Get the iIndexth FhirPatientContact. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientContact. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientContact);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientContact;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientContacts[index : Integer] : TFhirPatientContact read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientAnimal : TFhirElement
    This element has a value if the patient is an animal.
  }
  {!.Net HL7Connect.Fhir.PatientAnimal}
  TFhirPatientAnimal = class (TFhirElement)
  private
    FSpecies : TFhirCodeableConcept;
    FBreed : TFhirCodeableConcept;
    FGenderStatus : TFhirCodeableConcept;
    Procedure SetSpecies(value : TFhirCodeableConcept);
    Procedure SetBreed(value : TFhirCodeableConcept);
    Procedure SetGenderStatus(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientAnimal; overload;
    function Clone : TFhirPatientAnimal; overload;
    {!script show}
  published
    {@member species
      Identifies the high level categorization of the kind of animal.
    }
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;

    {@member breed
      Identifies the detailed categorization of the kind of animal.
    }
    property breed : TFhirCodeableConcept read FBreed write SetBreed;

    {@member genderStatus
      Indicates the current state of the animal's reproductive organs.
    }
    property genderStatus : TFhirCodeableConcept read FGenderStatus write SetGenderStatus;

  end;


  {@Class TFhirPatientAnimalList
    A list of FhirPatientAnimal
  }
  {!.Net HL7Connect.Fhir.PatientAnimalList}
  TFhirPatientAnimalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientAnimal;
    procedure SetItemN(index : Integer; value : TFhirPatientAnimal);
  public
    {!script hide}
    function Link : TFhirPatientAnimalList; Overload;
    function Clone : TFhirPatientAnimalList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirPatientAnimal to the end of the list.
    }
    function Append : TFhirPatientAnimal;

    
    {@member AddItem
      Add an already existing FhirPatientAnimal to the end of the list.
    }
    procedure AddItem(value : TFhirPatientAnimal);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientAnimal) : Integer;
    

    {@member Insert
      Insert FhirPatientAnimal before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientAnimal;
    

    {@member InsertItem
       Insert an existing FhirPatientAnimal before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientAnimal);
    
    {@member Item
       Get the iIndexth FhirPatientAnimal. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientAnimal. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientAnimal);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientAnimal;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientAnimals[index : Integer] : TFhirPatientAnimal read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPractitionerQualification : TFhirElement
    Qualifications relevant to the provided service.
  }
  {!.Net HL7Connect.Fhir.PractitionerQualification}
  TFhirPractitionerQualification = class (TFhirElement)
  private
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirResourceReference{TFhirOrganization};
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetIssuer(value : TFhirResourceReference{TFhirOrganization});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPractitionerQualification; overload;
    function Clone : TFhirPractitionerQualification; overload;
    {!script show}
  published
    {@member code
      Coded representation of the qualification.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member period
      Period during which the qualification is valid.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member issuer
      Organization that regulates and issues the qualification.
    }
    property issuer : TFhirResourceReference{TFhirOrganization} read FIssuer write SetIssuer;

  end;


  {@Class TFhirPractitionerQualificationList
    A list of FhirPractitionerQualification
  }
  {!.Net HL7Connect.Fhir.PractitionerQualificationList}
  TFhirPractitionerQualificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerQualification;
    procedure SetItemN(index : Integer; value : TFhirPractitionerQualification);
  public
    {!script hide}
    function Link : TFhirPractitionerQualificationList; Overload;
    function Clone : TFhirPractitionerQualificationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirPractitionerQualification to the end of the list.
    }
    function Append : TFhirPractitionerQualification;

    
    {@member AddItem
      Add an already existing FhirPractitionerQualification to the end of the list.
    }
    procedure AddItem(value : TFhirPractitionerQualification);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPractitionerQualification) : Integer;
    

    {@member Insert
      Insert FhirPractitionerQualification before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPractitionerQualification;
    

    {@member InsertItem
       Insert an existing FhirPractitionerQualification before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPractitionerQualification);
    
    {@member Item
       Get the iIndexth FhirPractitionerQualification. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPractitionerQualification. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerQualification);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPractitionerQualification;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPractitionerQualifications[index : Integer] : TFhirPractitionerQualification read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProcedurePerformer : TFhirElement
    Limited to 'real' people rather than equipment.
  }
  {!.Net HL7Connect.Fhir.ProcedurePerformer}
  TFhirProcedurePerformer = class (TFhirElement)
  private
    FPerson : TFhirResourceReference{TFhirPractitioner};
    FRole : TFhirCodeableConcept;
    Procedure SetPerson(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetRole(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProcedurePerformer; overload;
    function Clone : TFhirProcedurePerformer; overload;
    {!script show}
  published
    {@member person
      The practitioner who was involved in the procedure.
    }
    property person : TFhirResourceReference{TFhirPractitioner} read FPerson write SetPerson;

    {@member role
      E.g. surgeon, anaethetist, endoscopist.
    }
    property role : TFhirCodeableConcept read FRole write SetRole;

  end;


  {@Class TFhirProcedurePerformerList
    A list of FhirProcedurePerformer
  }
  {!.Net HL7Connect.Fhir.ProcedurePerformerList}
  TFhirProcedurePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedurePerformer;
    procedure SetItemN(index : Integer; value : TFhirProcedurePerformer);
  public
    {!script hide}
    function Link : TFhirProcedurePerformerList; Overload;
    function Clone : TFhirProcedurePerformerList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProcedurePerformer to the end of the list.
    }
    function Append : TFhirProcedurePerformer;

    
    {@member AddItem
      Add an already existing FhirProcedurePerformer to the end of the list.
    }
    procedure AddItem(value : TFhirProcedurePerformer);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProcedurePerformer) : Integer;
    

    {@member Insert
      Insert FhirProcedurePerformer before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProcedurePerformer;
    

    {@member InsertItem
       Insert an existing FhirProcedurePerformer before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProcedurePerformer);
    
    {@member Item
       Get the iIndexth FhirProcedurePerformer. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProcedurePerformer. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProcedurePerformer);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProcedurePerformer;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProcedurePerformers[index : Integer] : TFhirProcedurePerformer read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProcedureRelatedItem : TFhirElement
    Procedures may be related to other items such as procedures or medications. For example treating wound dehiscence following a previous procedure.
  }
  {!.Net HL7Connect.Fhir.ProcedureRelatedItem}
  TFhirProcedureRelatedItem = class (TFhirElement)
  private
    FType_ : TFhirEnum;
    FTarget : TFhirResourceReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirProcedureRelationshipType;
    Procedure SetType_ST(value : TFhirProcedureRelationshipType);
    Procedure SetTarget(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProcedureRelatedItem; overload;
    function Clone : TFhirProcedureRelatedItem; overload;
    {!script show}
  published
    {@member type_
      The nature of the relationship.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The nature of the relationship.
    }
    property type_ST : TFhirProcedureRelationshipType read GetType_ST write SetType_ST;

    {@member target
      The related item - e.g. a procedure.
    }
    property target : TFhirResourceReference{Resource} read FTarget write SetTarget;

  end;


  {@Class TFhirProcedureRelatedItemList
    A list of FhirProcedureRelatedItem
  }
  {!.Net HL7Connect.Fhir.ProcedureRelatedItemList}
  TFhirProcedureRelatedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedureRelatedItem;
    procedure SetItemN(index : Integer; value : TFhirProcedureRelatedItem);
  public
    {!script hide}
    function Link : TFhirProcedureRelatedItemList; Overload;
    function Clone : TFhirProcedureRelatedItemList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProcedureRelatedItem to the end of the list.
    }
    function Append : TFhirProcedureRelatedItem;

    
    {@member AddItem
      Add an already existing FhirProcedureRelatedItem to the end of the list.
    }
    procedure AddItem(value : TFhirProcedureRelatedItem);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProcedureRelatedItem) : Integer;
    

    {@member Insert
      Insert FhirProcedureRelatedItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProcedureRelatedItem;
    

    {@member InsertItem
       Insert an existing FhirProcedureRelatedItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProcedureRelatedItem);
    
    {@member Item
       Get the iIndexth FhirProcedureRelatedItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProcedureRelatedItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureRelatedItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProcedureRelatedItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProcedureRelatedItems[index : Integer] : TFhirProcedureRelatedItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructure : TFhirElement
    A constraint statement about what contents a resource or data type may have.
  }
  {!.Net HL7Connect.Fhir.ProfileStructure}
  TFhirProfileStructure = class (TFhirElement)
  private
    FType_ : TFhirCode;
    FName : TFhirString;
    FPublish : TFhirBoolean;
    FPurpose : TFhirString;
    FelementList : TFhirProfileStructureElementList;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetPublish(value : TFhirBoolean);
    Function GetPublishST : String;
    Procedure SetPublishST(value : String);
    Procedure SetPurpose(value : TFhirString);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructure; overload;
    function Clone : TFhirProfileStructure; overload;
    {!script show}
  published
    {@member type_
      The Resource or Data type being described.
    }
    property type_ : TFhirCode read FType_ write SetType_;
    {@member type_ST
      Typed access to The Resource or Data type being described.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member name
      The name of this resource constraint statement (to refer to it from other resource constraints - from Profile.structure.element.definition.type.profile).
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of this resource constraint statement (to refer to it from other resource constraints - from Profile.structure.element.definition.type.profile).
    }
    property nameST : String read GetNameST write SetNameST;

    {@member publish
      This definition of a profile on a structure is published as a formal statement. Some structural definitions might be defined purely for internal use within the profile, and not intended to be used outside that context.
    }
    property publish : TFhirBoolean read FPublish write SetPublish;
    {@member publishST
      Typed access to This definition of a profile on a structure is published as a formal statement. Some structural definitions might be defined purely for internal use within the profile, and not intended to be used outside that context.
    }
    property publishST : String read GetPublishST write SetPublishST;

    {@member purpose
      Human summary: why describe this resource?.
    }
    property purpose : TFhirString read FPurpose write SetPurpose;
    {@member purposeST
      Typed access to Human summary: why describe this resource?.
    }
    property purposeST : String read GetPurposeST write SetPurposeST;

    {@member elementList
      Captures constraints on each element within the resource.
    }
    property elementList : TFhirProfileStructureElementList read FElementList;

  end;


  {@Class TFhirProfileStructureList
    A list of FhirProfileStructure
  }
  {!.Net HL7Connect.Fhir.ProfileStructureList}
  TFhirProfileStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructure;
    procedure SetItemN(index : Integer; value : TFhirProfileStructure);
  public
    {!script hide}
    function Link : TFhirProfileStructureList; Overload;
    function Clone : TFhirProfileStructureList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructure to the end of the list.
    }
    function Append : TFhirProfileStructure;

    
    {@member AddItem
      Add an already existing FhirProfileStructure to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructure);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructure) : Integer;
    

    {@member Insert
      Insert FhirProfileStructure before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructure;
    

    {@member InsertItem
       Insert an existing FhirProfileStructure before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructure);
    
    {@member Item
       Get the iIndexth FhirProfileStructure. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructure. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructure);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructure;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructures[index : Integer] : TFhirProfileStructure read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElement : TFhirElement
    Captures constraints on each element within the resource.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElement}
  TFhirProfileStructureElement = class (TFhirElement)
  private
    FPath : TFhirString;
    FName : TFhirString;
    FSlicing : TFhirProfileStructureElementSlicing;
    FDefinition : TFhirProfileStructureElementDefinition;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSlicing(value : TFhirProfileStructureElementSlicing);
    Procedure SetDefinition(value : TFhirProfileStructureElementDefinition);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElement; overload;
    function Clone : TFhirProfileStructureElement; overload;
    {!script show}
  published
    {@member path
      The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource.
    }
    property path : TFhirString read FPath write SetPath;
    {@member pathST
      Typed access to The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource.
    }
    property pathST : String read GetPathST write SetPathST;

    {@member name
      The name of this element definition (to refer to it from other element definitions using Profile.structure.element.definition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of this element definition (to refer to it from other element definitions using Profile.structure.element.definition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member slicing
      Indicates that the element is sliced into a set of alternative definitions (there are multiple definitions on a single element in the base resource). The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
    }
    property slicing : TFhirProfileStructureElementSlicing read FSlicing write SetSlicing;

    {@member definition
      Definition of the content of the element to provide a more specific definition than that contained for the element in the base resource.
    }
    property definition : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;

  end;


  {@Class TFhirProfileStructureElementList
    A list of FhirProfileStructureElement
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementList}
  TFhirProfileStructureElementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElement;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElement);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementList; Overload;
    function Clone : TFhirProfileStructureElementList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElement to the end of the list.
    }
    function Append : TFhirProfileStructureElement;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElement to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElement);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElement) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElement before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElement;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElement before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElement);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElement. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElement. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElement);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElement;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElements[index : Integer] : TFhirProfileStructureElement read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementSlicing : TFhirElement
    Indicates that the element is sliced into a set of alternative definitions (there are multiple definitions on a single element in the base resource). The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementSlicing}
  TFhirProfileStructureElementSlicing = class (TFhirElement)
  private
    FDiscriminator : TFhirId;
    FOrdered : TFhirBoolean;
    FRules : TFhirEnum;
    Procedure SetDiscriminator(value : TFhirId);
    Function GetDiscriminatorST : String;
    Procedure SetDiscriminatorST(value : String);
    Procedure SetOrdered(value : TFhirBoolean);
    Function GetOrderedST : String;
    Procedure SetOrderedST(value : String);
    Procedure SetRules(value : TFhirEnum);
    Function GetRulesST : TFhirResourceSlicingRules;
    Procedure SetRulesST(value : TFhirResourceSlicingRules);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementSlicing; overload;
    function Clone : TFhirProfileStructureElementSlicing; overload;
    {!script show}
  published
    {@member discriminator
      Designates which child element is used to discriminate between the slices when processing an instance. The value of the child element in the instance must completely distinguish which slice the element in the resource matches based on the allowed values for that element in each of the slices.
    }
    property discriminator : TFhirId read FDiscriminator write SetDiscriminator;
    {@member discriminatorST
      Typed access to Designates which child element is used to discriminate between the slices when processing an instance. The value of the child element in the instance must completely distinguish which slice the element in the resource matches based on the allowed values for that element in each of the slices.
    }
    property discriminatorST : String read GetDiscriminatorST write SetDiscriminatorST;

    {@member ordered
      If the matching elements have to occur in the same order as defined in the profile.
    }
    property ordered : TFhirBoolean read FOrdered write SetOrdered;
    {@member orderedST
      Typed access to If the matching elements have to occur in the same order as defined in the profile.
    }
    property orderedST : String read GetOrderedST write SetOrderedST;

    {@member rules
      Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    }
    property rules : TFhirEnum read FRules write SetRules;
    {@member rulesST
      Typed access to Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    }
    property rulesST : TFhirResourceSlicingRules read GetRulesST write SetRulesST;

  end;


  {@Class TFhirProfileStructureElementSlicingList
    A list of FhirProfileStructureElementSlicing
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementSlicingList}
  TFhirProfileStructureElementSlicingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementSlicing;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementSlicing);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementSlicingList; Overload;
    function Clone : TFhirProfileStructureElementSlicingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementSlicing to the end of the list.
    }
    function Append : TFhirProfileStructureElementSlicing;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementSlicing to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementSlicing);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementSlicing) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementSlicing before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementSlicing;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementSlicing before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementSlicing);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementSlicing. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementSlicing. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementSlicing);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementSlicing;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementSlicings[index : Integer] : TFhirProfileStructureElementSlicing read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinition : TFhirElement
    Definition of the content of the element to provide a more specific definition than that contained for the element in the base resource.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinition}
  TFhirProfileStructureElementDefinition = class (TFhirElement)
  private
    FShort : TFhirString;
    FFormal : TFhirString;
    FComments : TFhirString;
    FRequirements : TFhirString;
    FsynonymList : TFhirStringList;
    FMin : TFhirInteger;
    FMax : TFhirString;
    Ftype_List : TFhirProfileStructureElementDefinitionTypeList;
    FNameReference : TFhirString;
    FValue : TFhirType;
    FExample : TFhirType;
    FMaxLength : TFhirInteger;
    FconditionList : TFhirIdList;
    FconstraintList : TFhirProfileStructureElementDefinitionConstraintList;
    FMustSupport : TFhirBoolean;
    FIsModifier : TFhirBoolean;
    FBinding : TFhirUri;
    FmappingList : TFhirProfileStructureElementDefinitionMappingList;
    Procedure SetShort(value : TFhirString);
    Function GetShortST : String;
    Procedure SetShortST(value : String);
    Procedure SetFormal(value : TFhirString);
    Function GetFormalST : String;
    Procedure SetFormalST(value : String);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetNameReference(value : TFhirString);
    Function GetNameReferenceST : String;
    Procedure SetNameReferenceST(value : String);
    Procedure SetValue(value : TFhirType);
    Procedure SetExample(value : TFhirType);
    Procedure SetMaxLength(value : TFhirInteger);
    Function GetMaxLengthST : String;
    Procedure SetMaxLengthST(value : String);
    Procedure SetMustSupport(value : TFhirBoolean);
    Function GetMustSupportST : String;
    Procedure SetMustSupportST(value : String);
    Procedure SetIsModifier(value : TFhirBoolean);
    Function GetIsModifierST : String;
    Procedure SetIsModifierST(value : String);
    Procedure SetBinding(value : TFhirUri);
    Function GetBindingST : String;
    Procedure SetBindingST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinition; overload;
    function Clone : TFhirProfileStructureElementDefinition; overload;
    {!script show}
  published
    {@member short
      A concise definition that  is shown in the concise XML format that summarizes profiles.
    }
    property short : TFhirString read FShort write SetShort;
    {@member shortST
      Typed access to A concise definition that  is shown in the concise XML format that summarizes profiles.
    }
    property shortST : String read GetShortST write SetShortST;

    {@member formal
      The definition must be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
    }
    property formal : TFhirString read FFormal write SetFormal;
    {@member formalST
      Typed access to The definition must be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
    }
    property formalST : String read GetFormalST write SetFormalST;

    {@member comments
      Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    }
    property comments : TFhirString read FComments write SetComments;
    {@member commentsST
      Typed access to Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    }
    property commentsST : String read GetCommentsST write SetCommentsST;

    {@member requirements
      Explains why this element is needed and why it's been constrained as it has.
    }
    property requirements : TFhirString read FRequirements write SetRequirements;
    {@member requirementsST
      Typed access to Explains why this element is needed and why it's been constrained as it has.
    }
    property requirementsST : String read GetRequirementsST write SetRequirementsST;

    {@member synonymList
      Identifies additional names by which this element might also be known.
    }
    property synonymList : TFhirStringList read FSynonymList;

    {@member min
      The minimum number of times this element must appear in the instance.
    }
    property min : TFhirInteger read FMin write SetMin;
    {@member minST
      Typed access to The minimum number of times this element must appear in the instance.
    }
    property minST : String read GetMinST write SetMinST;

    {@member max
      The maximum number of times this element is permitted to appear in the instance.
    }
    property max : TFhirString read FMax write SetMax;
    {@member maxST
      Typed access to The maximum number of times this element is permitted to appear in the instance.
    }
    property maxST : String read GetMaxST write SetMaxST;

    {@member type_List
      The data type or resource that the value of this element is permitted to be.
    }
    property type_List : TFhirProfileStructureElementDefinitionTypeList read FType_List;

    {@member nameReference
      Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    }
    property nameReference : TFhirString read FNameReference write SetNameReference;
    {@member nameReferenceST
      Typed access to Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    }
    property nameReferenceST : String read GetNameReferenceST write SetNameReferenceST;

    {@member value
      Specifies a value that must hold for this element in the instance.
    }
    property value : TFhirType read FValue write SetValue;

    {@member example
      An example value for this element.
    }
    property example : TFhirType read FExample write SetExample;

    {@member maxLength
      Indicates the shortest length that must be supported by conformant instances without truncation.
    }
    property maxLength : TFhirInteger read FMaxLength write SetMaxLength;
    {@member maxLengthST
      Typed access to Indicates the shortest length that must be supported by conformant instances without truncation.
    }
    property maxLengthST : String read GetMaxLengthST write SetMaxLengthST;

    {@member conditionList
      A reference to an invariant that may make additional statements about the cardinality in the instance.
    }
    property conditionList : TFhirIdList read FConditionList;

    {@member constraintList
      Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
    }
    property constraintList : TFhirProfileStructureElementDefinitionConstraintList read FConstraintList;

    {@member mustSupport
      If true, conformant resource authors must be capable of providing a value for the element and resource consumers must be capable of extracting and doing something useful with the data element.  If false, the element may be ignored and not supported.
    }
    property mustSupport : TFhirBoolean read FMustSupport write SetMustSupport;
    {@member mustSupportST
      Typed access to If true, conformant resource authors must be capable of providing a value for the element and resource consumers must be capable of extracting and doing something useful with the data element.  If false, the element may be ignored and not supported.
    }
    property mustSupportST : String read GetMustSupportST write SetMustSupportST;

    {@member isModifier
      If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they must either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    }
    property isModifier : TFhirBoolean read FIsModifier write SetIsModifier;
    {@member isModifierST
      Typed access to If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they must either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    }
    property isModifierST : String read GetIsModifierST write SetIsModifierST;

    {@member binding
      Identifies the set of codes that applies to this element if a data type supporting codes is used. The reference can be local - to a Profile.binding.name, or absolute, to a binding.name in another profile.
    }
    property binding : TFhirUri read FBinding write SetBinding;
    {@member bindingST
      Typed access to Identifies the set of codes that applies to this element if a data type supporting codes is used. The reference can be local - to a Profile.binding.name, or absolute, to a binding.name in another profile.
    }
    property bindingST : String read GetBindingST write SetBindingST;

    {@member mappingList
      Identifies a concept from an external specification that roughly corresponds to this element.
    }
    property mappingList : TFhirProfileStructureElementDefinitionMappingList read FMappingList;

  end;


  {@Class TFhirProfileStructureElementDefinitionList
    A list of FhirProfileStructureElementDefinition
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionList}
  TFhirProfileStructureElementDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinition;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinition);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinition to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinition;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinition to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinition);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinition) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinition;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinition);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitions[index : Integer] : TFhirProfileStructureElementDefinition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionType : TFhirElement
    The data type or resource that the value of this element is permitted to be.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionType}
  TFhirProfileStructureElementDefinitionType = class (TFhirElement)
  private
    FCode : TFhirCode;
    FProfile : TFhirUri;
    FBundled : TFhirBoolean;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetProfile(value : TFhirUri);
    Function GetProfileST : String;
    Procedure SetProfileST(value : String);
    Procedure SetBundled(value : TFhirBoolean);
    Function GetBundledST : String;
    Procedure SetBundledST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionType; overload;
    function Clone : TFhirProfileStructureElementDefinitionType; overload;
    {!script show}
  published
    {@member code
      Data type or Resource.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Data type or Resource.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member profile
      Identifies a profile that must hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile.
    }
    property profile : TFhirUri read FProfile write SetProfile;
    {@member profileST
      Typed access to Identifies a profile that must hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile.
    }
    property profileST : String read GetProfileST write SetProfileST;

    {@member bundled
      Whether the Resource that is the value for this element is included in the bundle, if the profile is specifying a bundle.
    }
    property bundled : TFhirBoolean read FBundled write SetBundled;
    {@member bundledST
      Typed access to Whether the Resource that is the value for this element is included in the bundle, if the profile is specifying a bundle.
    }
    property bundledST : String read GetBundledST write SetBundledST;

  end;


  {@Class TFhirProfileStructureElementDefinitionTypeList
    A list of FhirProfileStructureElementDefinitionType
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionTypeList}
  TFhirProfileStructureElementDefinitionTypeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionType;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionType);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionTypeList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionTypeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionType to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionType;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionType to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionType);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionType) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionType before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionType;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionType before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionType);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionType. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionType. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionType);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionType;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionTypes[index : Integer] : TFhirProfileStructureElementDefinitionType read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionConstraint : TFhirElement
    Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionConstraint}
  TFhirProfileStructureElementDefinitionConstraint = class (TFhirElement)
  private
    FKey : TFhirId;
    FName : TFhirString;
    FSeverity : TFhirEnum;
    FHuman : TFhirString;
    FXpath : TFhirString;
    FOcl : TFhirString;
    Procedure SetKey(value : TFhirId);
    Function GetKeyST : String;
    Procedure SetKeyST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirConstraintSeverity;
    Procedure SetSeverityST(value : TFhirConstraintSeverity);
    Procedure SetHuman(value : TFhirString);
    Function GetHumanST : String;
    Procedure SetHumanST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
    Procedure SetOcl(value : TFhirString);
    Function GetOclST : String;
    Procedure SetOclST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionConstraint; overload;
    function Clone : TFhirProfileStructureElementDefinitionConstraint; overload;
    {!script show}
  published
    {@member key
      Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    }
    property key : TFhirId read FKey write SetKey;
    {@member keyST
      Typed access to Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    }
    property keyST : String read GetKeyST write SetKeyST;

    {@member name
      Used to label the constraint in OCL or in short displays incapable of displaying the full human description.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Used to label the constraint in OCL or in short displays incapable of displaying the full human description.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member severity
      Identifies the impact constraint violation has on the conformance of the instance.
    }
    property severity : TFhirEnum read FSeverity write SetSeverity;
    {@member severityST
      Typed access to Identifies the impact constraint violation has on the conformance of the instance.
    }
    property severityST : TFhirConstraintSeverity read GetSeverityST write SetSeverityST;

    {@member human
      Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    }
    property human : TFhirString read FHuman write SetHuman;
    {@member humanST
      Typed access to Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    }
    property humanST : String read GetHumanST write SetHumanST;

    {@member xpath
      XPath expression of constraint.
    }
    property xpath : TFhirString read FXpath write SetXpath;
    {@member xpathST
      Typed access to XPath expression of constraint.
    }
    property xpathST : String read GetXpathST write SetXpathST;

    {@member ocl
      OCL expression of constraint.
    }
    property ocl : TFhirString read FOcl write SetOcl;
    {@member oclST
      Typed access to OCL expression of constraint.
    }
    property oclST : String read GetOclST write SetOclST;

  end;


  {@Class TFhirProfileStructureElementDefinitionConstraintList
    A list of FhirProfileStructureElementDefinitionConstraint
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionConstraintList}
  TFhirProfileStructureElementDefinitionConstraintList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionConstraintList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionConstraintList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionConstraint to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionConstraint;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionConstraint to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionConstraint) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionConstraint before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionConstraint before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionConstraint. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionConstraint. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionConstraints[index : Integer] : TFhirProfileStructureElementDefinitionConstraint read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionMapping : TFhirElement
    Identifies a concept from an external specification that roughly corresponds to this element.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionMapping}
  TFhirProfileStructureElementDefinitionMapping = class (TFhirElement)
  private
    FTarget : TFhirUri;
    FMap : TFhirString;
    Procedure SetTarget(value : TFhirUri);
    Function GetTargetST : String;
    Procedure SetTargetST(value : String);
    Procedure SetMap(value : TFhirString);
    Function GetMapST : String;
    Procedure SetMapST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionMapping; overload;
    function Clone : TFhirProfileStructureElementDefinitionMapping; overload;
    {!script show}
  published
    {@member target
      The name of the specification is mapping is being expressed to.
    }
    property target : TFhirUri read FTarget write SetTarget;
    {@member targetST
      Typed access to The name of the specification is mapping is being expressed to.
    }
    property targetST : String read GetTargetST write SetTargetST;

    {@member map
      Expresses what part of the target specification corresponds to this element.
    }
    property map : TFhirString read FMap write SetMap;
    {@member mapST
      Typed access to Expresses what part of the target specification corresponds to this element.
    }
    property mapST : String read GetMapST write SetMapST;

  end;


  {@Class TFhirProfileStructureElementDefinitionMappingList
    A list of FhirProfileStructureElementDefinitionMapping
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionMappingList}
  TFhirProfileStructureElementDefinitionMappingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionMappingList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionMappingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionMapping to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionMapping;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionMapping to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionMapping) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionMapping before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionMapping before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionMapping. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionMapping. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionMappings[index : Integer] : TFhirProfileStructureElementDefinitionMapping read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileExtensionDefn : TFhirElement
    An extension defined as part of the profile.
  }
  {!.Net HL7Connect.Fhir.ProfileExtensionDefn}
  TFhirProfileExtensionDefn = class (TFhirElement)
  private
    FCode : TFhirCode;
    FContextType : TFhirEnum;
    FcontextList : TFhirStringList;
    FDefinition : TFhirProfileStructureElementDefinition;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetContextType(value : TFhirEnum);
    Function GetContextTypeST : TFhirExtensionContext;
    Procedure SetContextTypeST(value : TFhirExtensionContext);
    Procedure SetDefinition(value : TFhirProfileStructureElementDefinition);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileExtensionDefn; overload;
    function Clone : TFhirProfileExtensionDefn; overload;
    {!script show}
  published
    {@member code
      A unique code (within the profile) used to identify the extension.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to A unique code (within the profile) used to identify the extension.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member contextType
      Identifies the type of context to which the extension applies.
    }
    property contextType : TFhirEnum read FContextType write SetContextType;
    {@member contextTypeST
      Typed access to Identifies the type of context to which the extension applies.
    }
    property contextTypeST : TFhirExtensionContext read GetContextTypeST write SetContextTypeST;

    {@member contextList
      Identifies the types of resource or data type elements to which the extension can be applied.
    }
    property contextList : TFhirStringList read FContextList;

    {@member definition
      Definition of the extension and its content.
    }
    property definition : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;

  end;


  {@Class TFhirProfileExtensionDefnList
    A list of FhirProfileExtensionDefn
  }
  {!.Net HL7Connect.Fhir.ProfileExtensionDefnList}
  TFhirProfileExtensionDefnList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileExtensionDefn;
    procedure SetItemN(index : Integer; value : TFhirProfileExtensionDefn);
  public
    {!script hide}
    function Link : TFhirProfileExtensionDefnList; Overload;
    function Clone : TFhirProfileExtensionDefnList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileExtensionDefn to the end of the list.
    }
    function Append : TFhirProfileExtensionDefn;

    
    {@member AddItem
      Add an already existing FhirProfileExtensionDefn to the end of the list.
    }
    procedure AddItem(value : TFhirProfileExtensionDefn);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileExtensionDefn) : Integer;
    

    {@member Insert
      Insert FhirProfileExtensionDefn before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileExtensionDefn;
    

    {@member InsertItem
       Insert an existing FhirProfileExtensionDefn before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileExtensionDefn);
    
    {@member Item
       Get the iIndexth FhirProfileExtensionDefn. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileExtensionDefn. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileExtensionDefn);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileExtensionDefn;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileExtensionDefns[index : Integer] : TFhirProfileExtensionDefn read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileBinding : TFhirElement
    Defines a linkage between a vocabulary binding name used in the profile (or expected to be used in profile importing this one) and a value set or code list.
  }
  {!.Net HL7Connect.Fhir.ProfileBinding}
  TFhirProfileBinding = class (TFhirElement)
  private
    FName : TFhirString;
    FIsExtensible : TFhirBoolean;
    FConformance : TFhirEnum;
    FDescription : TFhirString;
    FReference : TFhirType;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetIsExtensible(value : TFhirBoolean);
    Function GetIsExtensibleST : String;
    Procedure SetIsExtensibleST(value : String);
    Procedure SetConformance(value : TFhirEnum);
    Function GetConformanceST : TFhirBindingConformance;
    Procedure SetConformanceST(value : TFhirBindingConformance);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetReference(value : TFhirType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileBinding; overload;
    function Clone : TFhirProfileBinding; overload;
    {!script show}
  published
    {@member name
      The name to be associated with this set of codes.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name to be associated with this set of codes.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member isExtensible
      If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    }
    property isExtensible : TFhirBoolean read FIsExtensible write SetIsExtensible;
    {@member isExtensibleST
      Typed access to If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    }
    property isExtensibleST : String read GetIsExtensibleST write SetIsExtensibleST;

    {@member conformance
      Indicates the degree of conformance expectations associated with this binding.
    }
    property conformance : TFhirEnum read FConformance write SetConformance;
    {@member conformanceST
      Typed access to Indicates the degree of conformance expectations associated with this binding.
    }
    property conformanceST : TFhirBindingConformance read GetConformanceST write SetConformanceST;

    {@member description
      Describes the intended use of this particular set of codes.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Describes the intended use of this particular set of codes.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member reference
      Points to the value set or external definition that identifies the set of codes to be used.
    }
    property reference : TFhirType read FReference write SetReference;

  end;


  {@Class TFhirProfileBindingList
    A list of FhirProfileBinding
  }
  {!.Net HL7Connect.Fhir.ProfileBindingList}
  TFhirProfileBindingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileBinding;
    procedure SetItemN(index : Integer; value : TFhirProfileBinding);
  public
    {!script hide}
    function Link : TFhirProfileBindingList; Overload;
    function Clone : TFhirProfileBindingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileBinding to the end of the list.
    }
    function Append : TFhirProfileBinding;

    
    {@member AddItem
      Add an already existing FhirProfileBinding to the end of the list.
    }
    procedure AddItem(value : TFhirProfileBinding);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileBinding) : Integer;
    

    {@member Insert
      Insert FhirProfileBinding before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileBinding;
    

    {@member InsertItem
       Insert an existing FhirProfileBinding before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileBinding);
    
    {@member Item
       Get the iIndexth FhirProfileBinding. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileBinding. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileBinding);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileBinding;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileBindings[index : Integer] : TFhirProfileBinding read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProvenanceAgent : TFhirElement
    An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, a piece of software, an inanimate object, an organization, or other entities that may be ascribed responsibility.
  }
  {!.Net HL7Connect.Fhir.ProvenanceAgent}
  TFhirProvenanceAgent = class (TFhirElement)
  private
    FRole : TFhirCoding;
    FType_ : TFhirCoding;
    FReference : TFhirUri;
    FDisplay : TFhirString;
    Procedure SetRole(value : TFhirCoding);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    {!script show}
  published
    {@member role
      The role that the participant played.
    }
    property role : TFhirCoding read FRole write SetRole;

    {@member type_
      The type of the participant.
    }
    property type_ : TFhirCoding read FType_ write SetType_;

    {@member reference
      Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property reference : TFhirUri read FReference write SetReference;
    {@member referenceST
      Typed access to Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property referenceST : String read GetReferenceST write SetReferenceST;

    {@member display
      Human readable description of the participant.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to Human readable description of the participant.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

  end;


  {@Class TFhirProvenanceAgentList
    A list of FhirProvenanceAgent
  }
  {!.Net HL7Connect.Fhir.ProvenanceAgentList}
  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  public
    {!script hide}
    function Link : TFhirProvenanceAgentList; Overload;
    function Clone : TFhirProvenanceAgentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProvenanceAgent to the end of the list.
    }
    function Append : TFhirProvenanceAgent;

    
    {@member AddItem
      Add an already existing FhirProvenanceAgent to the end of the list.
    }
    procedure AddItem(value : TFhirProvenanceAgent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProvenanceAgent) : Integer;
    

    {@member Insert
      Insert FhirProvenanceAgent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProvenanceAgent;
    

    {@member InsertItem
       Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);
    
    {@member Item
       Get the iIndexth FhirProvenanceAgent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProvenanceAgent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProvenanceAgent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProvenanceEntity : TFhirElement
    An entity used in this activity.
  }
  {!.Net HL7Connect.Fhir.ProvenanceEntity}
  TFhirProvenanceEntity = class (TFhirElement)
  private
    FRole : TFhirEnum;
    FType_ : TFhirCoding;
    FReference : TFhirUri;
    FDisplay : TFhirString;
    FAgent : TFhirProvenanceAgent;
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirProvenanceEntityRole;
    Procedure SetRoleST(value : TFhirProvenanceEntityRole);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetAgent(value : TFhirProvenanceAgent);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    {!script show}
  published
    {@member role
      How the entity was used during the activity.
    }
    property role : TFhirEnum read FRole write SetRole;
    {@member roleST
      Typed access to How the entity was used during the activity.
    }
    property roleST : TFhirProvenanceEntityRole read GetRoleST write SetRoleST;

    {@member type_
      The type of the entity. If the entity is a resource, then this is a resource type.
    }
    property type_ : TFhirCoding read FType_ write SetType_;

    {@member reference
      Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property reference : TFhirUri read FReference write SetReference;
    {@member referenceST
      Typed access to Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property referenceST : String read GetReferenceST write SetReferenceST;

    {@member display
      Human readable description of the entity.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to Human readable description of the entity.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

    {@member agent
      The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as a shorthand for saying that the agent was responsible for the activity which generated the entity.
    }
    property agent : TFhirProvenanceAgent read FAgent write SetAgent;

  end;


  {@Class TFhirProvenanceEntityList
    A list of FhirProvenanceEntity
  }
  {!.Net HL7Connect.Fhir.ProvenanceEntityList}
  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  public
    {!script hide}
    function Link : TFhirProvenanceEntityList; Overload;
    function Clone : TFhirProvenanceEntityList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProvenanceEntity to the end of the list.
    }
    function Append : TFhirProvenanceEntity;

    
    {@member AddItem
      Add an already existing FhirProvenanceEntity to the end of the list.
    }
    procedure AddItem(value : TFhirProvenanceEntity);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProvenanceEntity) : Integer;
    

    {@member Insert
      Insert FhirProvenanceEntity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProvenanceEntity;
    

    {@member InsertItem
       Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);
    
    {@member Item
       Get the iIndexth FhirProvenanceEntity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProvenanceEntity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProvenanceEntity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQueryResponse : TFhirElement
    If this is a response to a query.
  }
  {!.Net HL7Connect.Fhir.QueryResponse}
  TFhirQueryResponse = class (TFhirElement)
  private
    FIdentifier : TFhirUri;
    FOutcome : TFhirEnum;
    FTotal : TFhirInteger;
    FparameterList : TFhirExtensionList;
    FfirstList : TFhirExtensionList;
    FpreviousList : TFhirExtensionList;
    FnextList : TFhirExtensionList;
    FlastList : TFhirExtensionList;
    FreferenceList : TFhirResourceReferenceList{Resource};
    Procedure SetIdentifier(value : TFhirUri);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirQueryOutcome;
    Procedure SetOutcomeST(value : TFhirQueryOutcome);
    Procedure SetTotal(value : TFhirInteger);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQueryResponse; overload;
    function Clone : TFhirQueryResponse; overload;
    {!script show}
  published
    {@member identifier
      Links response to source query.
    }
    property identifier : TFhirUri read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to Links response to source query.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member outcome
      Outcome of processing the query.
    }
    property outcome : TFhirEnum read FOutcome write SetOutcome;
    {@member outcomeST
      Typed access to Outcome of processing the query.
    }
    property outcomeST : TFhirQueryOutcome read GetOutcomeST write SetOutcomeST;

    {@member total
      Total number of matching records.
    }
    property total : TFhirInteger read FTotal write SetTotal;
    {@member totalST
      Typed access to Total number of matching records.
    }
    property totalST : String read GetTotalST write SetTotalST;

    {@member parameterList
      Parameters server used.
    }
    property parameterList : TFhirExtensionList read FParameterList;

    {@member firstList
      To get first page (if paged).
    }
    property firstList : TFhirExtensionList read FFirstList;

    {@member previousList
      To get previous page (if paged).
    }
    property previousList : TFhirExtensionList read FPreviousList;

    {@member nextList
      To get next page (if paged).
    }
    property nextList : TFhirExtensionList read FNextList;

    {@member lastList
      To get last page (if paged).
    }
    property lastList : TFhirExtensionList read FLastList;

    {@member referenceList
      Resources that are the results of the search.
    }
    property referenceList : TFhirResourceReferenceList{Resource} read FReferenceList;

  end;


  {@Class TFhirQueryResponseList
    A list of FhirQueryResponse
  }
  {!.Net HL7Connect.Fhir.QueryResponseList}
  TFhirQueryResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQueryResponse;
    procedure SetItemN(index : Integer; value : TFhirQueryResponse);
  public
    {!script hide}
    function Link : TFhirQueryResponseList; Overload;
    function Clone : TFhirQueryResponseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirQueryResponse to the end of the list.
    }
    function Append : TFhirQueryResponse;

    
    {@member AddItem
      Add an already existing FhirQueryResponse to the end of the list.
    }
    procedure AddItem(value : TFhirQueryResponse);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQueryResponse) : Integer;
    

    {@member Insert
      Insert FhirQueryResponse before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQueryResponse;
    

    {@member InsertItem
       Insert an existing FhirQueryResponse before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQueryResponse);
    
    {@member Item
       Get the iIndexth FhirQueryResponse. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQueryResponse. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQueryResponse);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQueryResponse;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQueryResponses[index : Integer] : TFhirQueryResponse read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQuestionnaireQuestion : TFhirElement
    Answers to questions on a questionnaire.
  }
  {!.Net HL7Connect.Fhir.QuestionnaireQuestion}
  TFhirQuestionnaireQuestion = class (TFhirElement)
  private
    FName : TFhirCodeableConcept;
    FText : TFhirString;
    FAnswer : TFhirType;
    FchoiceList : TFhirCodingList;
    FOptions : TFhirType;
    FData : TFhirType;
    FRemarks : TFhirString;
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetAnswer(value : TFhirType);
    Procedure SetOptions(value : TFhirType);
    Procedure SetData(value : TFhirType);
    Procedure SetRemarks(value : TFhirString);
    Function GetRemarksST : String;
    Procedure SetRemarksST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQuestionnaireQuestion; overload;
    function Clone : TFhirQuestionnaireQuestion; overload;
    {!script show}
  published
    {@member name
      Structured name for the question.
    }
    property name : TFhirCodeableConcept read FName write SetName;

    {@member text
      Text of the question as it may appear on screen or on a form.
    }
    property text : TFhirString read FText write SetText;
    {@member textST
      Typed access to Text of the question as it may appear on screen or on a form.
    }
    property textST : String read GetTextST write SetTextST;

    {@member answer
      Single-valued answer to the question.
    }
    property answer : TFhirType read FAnswer write SetAnswer;

    {@member choiceList
      One of more selections from the list of options.
    }
    property choiceList : TFhirCodingList read FChoiceList;

    {@member options
      Reference to a valueset containing the possible options.
    }
    property options : TFhirType read FOptions write SetOptions;

    {@member data
      Structured answer in the form of a FHIR Resource or datatype.
    }
    property data : TFhirType read FData write SetData;

    {@member remarks
      The remark contains information about the answer given. This is additional information about the answer the author wishes to convey, but should not be used to contain information that is part of the answer itself.
    }
    property remarks : TFhirString read FRemarks write SetRemarks;
    {@member remarksST
      Typed access to The remark contains information about the answer given. This is additional information about the answer the author wishes to convey, but should not be used to contain information that is part of the answer itself.
    }
    property remarksST : String read GetRemarksST write SetRemarksST;

  end;


  {@Class TFhirQuestionnaireQuestionList
    A list of FhirQuestionnaireQuestion
  }
  {!.Net HL7Connect.Fhir.QuestionnaireQuestionList}
  TFhirQuestionnaireQuestionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireQuestion;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireQuestion);
  public
    {!script hide}
    function Link : TFhirQuestionnaireQuestionList; Overload;
    function Clone : TFhirQuestionnaireQuestionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirQuestionnaireQuestion to the end of the list.
    }
    function Append : TFhirQuestionnaireQuestion;

    
    {@member AddItem
      Add an already existing FhirQuestionnaireQuestion to the end of the list.
    }
    procedure AddItem(value : TFhirQuestionnaireQuestion);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQuestionnaireQuestion) : Integer;
    

    {@member Insert
      Insert FhirQuestionnaireQuestion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQuestionnaireQuestion;
    

    {@member InsertItem
       Insert an existing FhirQuestionnaireQuestion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireQuestion);
    
    {@member Item
       Get the iIndexth FhirQuestionnaireQuestion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQuestionnaireQuestion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireQuestion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQuestionnaireQuestion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQuestionnaireQuestions[index : Integer] : TFhirQuestionnaireQuestion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQuestionnaireGroup : TFhirElement
    A group of questions to a possibly similarly grouped set of question in the questionnaire.
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroup}
  TFhirQuestionnaireGroup = class (TFhirElement)
  private
    FName : TFhirCodeableConcept;
    FHeader : TFhirString;
    FText : TFhirString;
    FSubject : TFhirResourceReference{Resource};
    FquestionList : TFhirQuestionnaireQuestionList;
    FgroupList : TFhirQuestionnaireGroupList;
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetHeader(value : TFhirString);
    Function GetHeaderST : String;
    Procedure SetHeaderST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetSubject(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQuestionnaireGroup; overload;
    function Clone : TFhirQuestionnaireGroup; overload;
    {!script show}
  published
    {@member name
      Structured name for a section of a predefined list of questions this questionnaire is responding to.
    }
    property name : TFhirCodeableConcept read FName write SetName;

    {@member header
      Header for the group, used for display purposes.
    }
    property header : TFhirString read FHeader write SetHeader;
    {@member headerST
      Typed access to Header for the group, used for display purposes.
    }
    property headerST : String read GetHeaderST write SetHeaderST;

    {@member text
      Additional text for the group, used for display purposes.
    }
    property text : TFhirString read FText write SetText;
    {@member textST
      Typed access to Additional text for the group, used for display purposes.
    }
    property textST : String read GetTextST write SetTextST;

    {@member subject
      More specific subject this section's answers are about, details the subject given in Questionnaire.
    }
    property subject : TFhirResourceReference{Resource} read FSubject write SetSubject;

    {@member questionList
      Set of questions within this group.
    }
    property questionList : TFhirQuestionnaireQuestionList read FQuestionList;

    {@member groupList
      A sub-group within a group.
    }
    property groupList : TFhirQuestionnaireGroupList read FGroupList;

  end;


  {@Class TFhirQuestionnaireGroupList
    A list of FhirQuestionnaireGroup
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroupList}
  TFhirQuestionnaireGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireGroup;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireGroup);
  public
    {!script hide}
    function Link : TFhirQuestionnaireGroupList; Overload;
    function Clone : TFhirQuestionnaireGroupList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirQuestionnaireGroup to the end of the list.
    }
    function Append : TFhirQuestionnaireGroup;

    
    {@member AddItem
      Add an already existing FhirQuestionnaireGroup to the end of the list.
    }
    procedure AddItem(value : TFhirQuestionnaireGroup);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQuestionnaireGroup) : Integer;
    

    {@member Insert
      Insert FhirQuestionnaireGroup before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQuestionnaireGroup;
    

    {@member InsertItem
       Insert an existing FhirQuestionnaireGroup before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireGroup);
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroup. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroup. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireGroup);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQuestionnaireGroup;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQuestionnaireGroups[index : Integer] : TFhirQuestionnaireGroup read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventEvent : TFhirElement
    Identifies the name, action type, time, and disposition of the audited event.
  }
  {!.Net HL7Connect.Fhir.SecurityEventEvent}
  TFhirSecurityEventEvent = class (TFhirElement)
  private
    FType_ : TFhirCodeableConcept;
    FsubtypeList : TFhirCodeableConceptList;
    FAction : TFhirEnum;
    FDateTime : TFhirInstant;
    FOutcome : TFhirEnum;
    FOutcomeDesc : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirSecurityEventAction;
    Procedure SetActionST(value : TFhirSecurityEventAction);
    Procedure SetDateTime(value : TFhirInstant);
    Function GetDateTimeST : TDateAndTime;
    Procedure SetDateTimeST(value : TDateAndTime);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirSecurityEventOutcome;
    Procedure SetOutcomeST(value : TFhirSecurityEventOutcome);
    Procedure SetOutcomeDesc(value : TFhirString);
    Function GetOutcomeDescST : String;
    Procedure SetOutcomeDescST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventEvent; overload;
    function Clone : TFhirSecurityEventEvent; overload;
    {!script show}
  published
    {@member type_
      Identifier for a family of the event.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member subtypeList
      Identifier for the category of event.
    }
    property subtypeList : TFhirCodeableConceptList read FSubtypeList;

    {@member action
      Indicator for type of action performed during the event that generated the audit.
    }
    property action : TFhirEnum read FAction write SetAction;
    {@member actionST
      Typed access to Indicator for type of action performed during the event that generated the audit.
    }
    property actionST : TFhirSecurityEventAction read GetActionST write SetActionST;

    {@member dateTime
      The time when the event occurred on the source.
    }
    property dateTime : TFhirInstant read FDateTime write SetDateTime;
    {@member dateTimeST
      Typed access to The time when the event occurred on the source.
    }
    property dateTimeST : TDateAndTime read GetDateTimeST write SetDateTimeST;

    {@member outcome
      Indicates whether the event succeeded or failed.
    }
    property outcome : TFhirEnum read FOutcome write SetOutcome;
    {@member outcomeST
      Typed access to Indicates whether the event succeeded or failed.
    }
    property outcomeST : TFhirSecurityEventOutcome read GetOutcomeST write SetOutcomeST;

    {@member outcomeDesc
      A free text description of the outcome of the event.
    }
    property outcomeDesc : TFhirString read FOutcomeDesc write SetOutcomeDesc;
    {@member outcomeDescST
      Typed access to A free text description of the outcome of the event.
    }
    property outcomeDescST : String read GetOutcomeDescST write SetOutcomeDescST;

  end;


  {@Class TFhirSecurityEventEventList
    A list of FhirSecurityEventEvent
  }
  {!.Net HL7Connect.Fhir.SecurityEventEventList}
  TFhirSecurityEventEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventEvent;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventEvent);
  public
    {!script hide}
    function Link : TFhirSecurityEventEventList; Overload;
    function Clone : TFhirSecurityEventEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventEvent to the end of the list.
    }
    function Append : TFhirSecurityEventEvent;

    
    {@member AddItem
      Add an already existing FhirSecurityEventEvent to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventEvent) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventEvent;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventEvent);
    
    {@member Item
       Get the iIndexth FhirSecurityEventEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventEvents[index : Integer] : TFhirSecurityEventEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventParticipant : TFhirElement
    A person, a hardware device or software process.
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipant}
  TFhirSecurityEventParticipant = class (TFhirElement)
  private
    FroleList : TFhirCodeableConceptList;
    FReference : TFhirResourceReference{Resource};
    FUserId : TFhirString;
    FAuthId : TFhirString;
    FName : TFhirString;
    FRequestor : TFhirBoolean;
    FMedia : TFhirCoding;
    FNetwork : TFhirSecurityEventParticipantNetwork;
    Procedure SetReference(value : TFhirResourceReference{Resource});
    Procedure SetUserId(value : TFhirString);
    Function GetUserIdST : String;
    Procedure SetUserIdST(value : String);
    Procedure SetAuthId(value : TFhirString);
    Function GetAuthIdST : String;
    Procedure SetAuthIdST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRequestor(value : TFhirBoolean);
    Function GetRequestorST : String;
    Procedure SetRequestorST(value : String);
    Procedure SetMedia(value : TFhirCoding);
    Procedure SetNetwork(value : TFhirSecurityEventParticipantNetwork);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventParticipant; overload;
    function Clone : TFhirSecurityEventParticipant; overload;
    {!script show}
  published
    {@member roleList
      Specification of the role(s) the user plays when performing the event. Usually the codes used in this element are local codes defined by the role-based access control security system used in the local context.
    }
    property roleList : TFhirCodeableConceptList read FRoleList;

    {@member reference
      Direct reference to a resource that identifies the participant.
    }
    property reference : TFhirResourceReference{Resource} read FReference write SetReference;

    {@member userId
      Unique identifier for the user actively participating in the event.
    }
    property userId : TFhirString read FUserId write SetUserId;
    {@member userIdST
      Typed access to Unique identifier for the user actively participating in the event.
    }
    property userIdST : String read GetUserIdST write SetUserIdST;

    {@member authId
      User identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g., single sign-on), if available.
    }
    property authId : TFhirString read FAuthId write SetAuthId;
    {@member authIdST
      Typed access to User identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g., single sign-on), if available.
    }
    property authIdST : String read GetAuthIdST write SetAuthIdST;

    {@member name
      Human-meaningful name for the user.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Human-meaningful name for the user.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member requestor
      Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    }
    property requestor : TFhirBoolean read FRequestor write SetRequestor;
    {@member requestorST
      Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    }
    property requestorST : String read GetRequestorST write SetRequestorST;

    {@member media
      Type of media involved. Used when the event is about exporting/importing onto media.
    }
    property media : TFhirCoding read FMedia write SetMedia;

    {@member network
      Logical network location for application activity, if the activity has a network location.
    }
    property network : TFhirSecurityEventParticipantNetwork read FNetwork write SetNetwork;

  end;


  {@Class TFhirSecurityEventParticipantList
    A list of FhirSecurityEventParticipant
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantList}
  TFhirSecurityEventParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventParticipant;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventParticipant);
  public
    {!script hide}
    function Link : TFhirSecurityEventParticipantList; Overload;
    function Clone : TFhirSecurityEventParticipantList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventParticipant to the end of the list.
    }
    function Append : TFhirSecurityEventParticipant;

    
    {@member AddItem
      Add an already existing FhirSecurityEventParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventParticipant);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventParticipant) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventParticipant;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventParticipant);
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventParticipants[index : Integer] : TFhirSecurityEventParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventParticipantNetwork : TFhirElement
    Logical network location for application activity, if the activity has a network location.
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantNetwork}
  TFhirSecurityEventParticipantNetwork = class (TFhirElement)
  private
    FIdentifier : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetIdentifier(value : TFhirString);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNetworkType;
    Procedure SetType_ST(value : TFhirNetworkType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventParticipantNetwork; overload;
    function Clone : TFhirSecurityEventParticipantNetwork; overload;
    {!script show}
  published
    {@member identifier
      An identifier for the network access point of the user device for the audit event.
    }
    property identifier : TFhirString read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to An identifier for the network access point of the user device for the audit event.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member type_
      An identifier for the type of network access point that originated the audit event.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to An identifier for the type of network access point that originated the audit event.
    }
    property type_ST : TFhirNetworkType read GetType_ST write SetType_ST;

  end;


  {@Class TFhirSecurityEventParticipantNetworkList
    A list of FhirSecurityEventParticipantNetwork
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantNetworkList}
  TFhirSecurityEventParticipantNetworkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventParticipantNetwork;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventParticipantNetwork);
  public
    {!script hide}
    function Link : TFhirSecurityEventParticipantNetworkList; Overload;
    function Clone : TFhirSecurityEventParticipantNetworkList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventParticipantNetwork to the end of the list.
    }
    function Append : TFhirSecurityEventParticipantNetwork;

    
    {@member AddItem
      Add an already existing FhirSecurityEventParticipantNetwork to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventParticipantNetwork);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventParticipantNetwork) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventParticipantNetwork before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventParticipantNetwork;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventParticipantNetwork before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventParticipantNetwork);
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipantNetwork. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipantNetwork. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventParticipantNetwork);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventParticipantNetwork;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventParticipantNetworks[index : Integer] : TFhirSecurityEventParticipantNetwork read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventSource : TFhirElement
    Application systems and processes.
  }
  {!.Net HL7Connect.Fhir.SecurityEventSource}
  TFhirSecurityEventSource = class (TFhirElement)
  private
    FSite : TFhirString;
    FIdentifier : TFhirString;
    Ftype_List : TFhirCodingList;
    Procedure SetSite(value : TFhirString);
    Function GetSiteST : String;
    Procedure SetSiteST(value : String);
    Procedure SetIdentifier(value : TFhirString);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventSource; overload;
    function Clone : TFhirSecurityEventSource; overload;
    {!script show}
  published
    {@member site
      Logical source location within the healthcare enterprise network.
    }
    property site : TFhirString read FSite write SetSite;
    {@member siteST
      Typed access to Logical source location within the healthcare enterprise network.
    }
    property siteST : String read GetSiteST write SetSiteST;

    {@member identifier
      Identifier of the source where the event originated.
    }
    property identifier : TFhirString read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to Identifier of the source where the event originated.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member type_List
      Code specifying the type of source where event originated.
    }
    property type_List : TFhirCodingList read FType_List;

  end;


  {@Class TFhirSecurityEventSourceList
    A list of FhirSecurityEventSource
  }
  {!.Net HL7Connect.Fhir.SecurityEventSourceList}
  TFhirSecurityEventSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventSource;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventSource);
  public
    {!script hide}
    function Link : TFhirSecurityEventSourceList; Overload;
    function Clone : TFhirSecurityEventSourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventSource to the end of the list.
    }
    function Append : TFhirSecurityEventSource;

    
    {@member AddItem
      Add an already existing FhirSecurityEventSource to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventSource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventSource) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventSource;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventSource);
    
    {@member Item
       Get the iIndexth FhirSecurityEventSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventSources[index : Integer] : TFhirSecurityEventSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventObject : TFhirElement
    Specific instances of data or objects that have been accessed.
  }
  {!.Net HL7Connect.Fhir.SecurityEventObject}
  TFhirSecurityEventObject = class (TFhirElement)
  private
    FIdentifier : TFhirIdentifier;
    FReference : TFhirResourceReference{Resource};
    FType_ : TFhirEnum;
    FRole : TFhirEnum;
    FLifecycle : TFhirEnum;
    FSensitivity : TFhirCodeableConcept;
    FName : TFhirString;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirSecurityEventObjectDetailList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetReference(value : TFhirResourceReference{Resource});
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirObjectType;
    Procedure SetType_ST(value : TFhirObjectType);
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirObjectRole;
    Procedure SetRoleST(value : TFhirObjectRole);
    Procedure SetLifecycle(value : TFhirEnum);
    Function GetLifecycleST : TFhirObjectLifecycle;
    Procedure SetLifecycleST(value : TFhirObjectLifecycle);
    Procedure SetSensitivity(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetQuery(value : TFhirBase64Binary);
    Function GetQueryST : String;
    Procedure SetQueryST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventObject; overload;
    function Clone : TFhirSecurityEventObject; overload;
    {!script show}
  published
    {@member identifier
      Identifies a specific instance of the participant object. The reference should always be version specific.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member reference
      Identifies a specific instance of the participant object. The reference should always be version specific.
    }
    property reference : TFhirResourceReference{Resource} read FReference write SetReference;

    {@member type_
      Object type being audited.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to Object type being audited.
    }
    property type_ST : TFhirObjectType read GetType_ST write SetType_ST;

    {@member role
      Code representing the functional application role of Participant Object being audited.
    }
    property role : TFhirEnum read FRole write SetRole;
    {@member roleST
      Typed access to Code representing the functional application role of Participant Object being audited.
    }
    property roleST : TFhirObjectRole read GetRoleST write SetRoleST;

    {@member lifecycle
      Identifier for the data life-cycle stage for the participant object.
    }
    property lifecycle : TFhirEnum read FLifecycle write SetLifecycle;
    {@member lifecycleST
      Typed access to Identifier for the data life-cycle stage for the participant object.
    }
    property lifecycleST : TFhirObjectLifecycle read GetLifecycleST write SetLifecycleST;

    {@member sensitivity
      Denotes policy-defined sensitivity for the Participant Object ID such as VIP, HIV status, mental health status or similar topics.
    }
    property sensitivity : TFhirCodeableConcept read FSensitivity write SetSensitivity;

    {@member name
      An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member query
      The actual query for a query-type participant object.
    }
    property query : TFhirBase64Binary read FQuery write SetQuery;
    {@member queryST
      Typed access to The actual query for a query-type participant object.
    }
    property queryST : String read GetQueryST write SetQueryST;

    {@member detailList
      Additional Information about the Object.
    }
    property detailList : TFhirSecurityEventObjectDetailList read FDetailList;

  end;


  {@Class TFhirSecurityEventObjectList
    A list of FhirSecurityEventObject
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectList}
  TFhirSecurityEventObjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventObject;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventObject);
  public
    {!script hide}
    function Link : TFhirSecurityEventObjectList; Overload;
    function Clone : TFhirSecurityEventObjectList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventObject to the end of the list.
    }
    function Append : TFhirSecurityEventObject;

    
    {@member AddItem
      Add an already existing FhirSecurityEventObject to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventObject);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventObject) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventObject before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventObject;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventObject before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventObject);
    
    {@member Item
       Get the iIndexth FhirSecurityEventObject. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventObject. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventObject);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventObject;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventObjects[index : Integer] : TFhirSecurityEventObject read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventObjectDetail : TFhirElement
    Additional Information about the Object.
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectDetail}
  TFhirSecurityEventObjectDetail = class (TFhirElement)
  private
    FType_ : TFhirString;
    FValue : TFhirBase64Binary;
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetValue(value : TFhirBase64Binary);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventObjectDetail; overload;
    function Clone : TFhirSecurityEventObjectDetail; overload;
    {!script show}
  published
    {@member type_
      Name of the property.
    }
    property type_ : TFhirString read FType_ write SetType_;
    {@member type_ST
      Typed access to Name of the property.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member value
      Property value.
    }
    property value : TFhirBase64Binary read FValue write SetValue;
    {@member valueST
      Typed access to Property value.
    }
    property valueST : String read GetValueST write SetValueST;

  end;


  {@Class TFhirSecurityEventObjectDetailList
    A list of FhirSecurityEventObjectDetail
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectDetailList}
  TFhirSecurityEventObjectDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventObjectDetail;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventObjectDetail);
  public
    {!script hide}
    function Link : TFhirSecurityEventObjectDetailList; Overload;
    function Clone : TFhirSecurityEventObjectDetailList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventObjectDetail to the end of the list.
    }
    function Append : TFhirSecurityEventObjectDetail;

    
    {@member AddItem
      Add an already existing FhirSecurityEventObjectDetail to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventObjectDetail);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventObjectDetail) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventObjectDetail before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventObjectDetail;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventObjectDetail before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventObjectDetail);
    
    {@member Item
       Get the iIndexth FhirSecurityEventObjectDetail. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventObjectDetail. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventObjectDetail);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventObjectDetail;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventObjectDetails[index : Integer] : TFhirSecurityEventObjectDetail read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenSource : TFhirElement
    Parent specimen from which the focal specimen was a component.
  }
  {!.Net HL7Connect.Fhir.SpecimenSource}
  TFhirSpecimenSource = class (TFhirElement)
  private
    FRelationship : TFhirEnum;
    FtargetList : TFhirResourceReferenceList{TFhirSpecimen};
    Procedure SetRelationship(value : TFhirEnum);
    Function GetRelationshipST : TFhirHierarchicalRelationshipType;
    Procedure SetRelationshipST(value : TFhirHierarchicalRelationshipType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenSource; overload;
    function Clone : TFhirSpecimenSource; overload;
    {!script show}
  published
    {@member relationship
      Whether this relationship is to a parent or to a child.
    }
    property relationship : TFhirEnum read FRelationship write SetRelationship;
    {@member relationshipST
      Typed access to Whether this relationship is to a parent or to a child.
    }
    property relationshipST : TFhirHierarchicalRelationshipType read GetRelationshipST write SetRelationshipST;

    {@member targetList
      The specimen resource that is the target of this relationship.
    }
    property targetList : TFhirResourceReferenceList{TFhirSpecimen} read FTargetList;

  end;


  {@Class TFhirSpecimenSourceList
    A list of FhirSpecimenSource
  }
  {!.Net HL7Connect.Fhir.SpecimenSourceList}
  TFhirSpecimenSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenSource;
    procedure SetItemN(index : Integer; value : TFhirSpecimenSource);
  public
    {!script hide}
    function Link : TFhirSpecimenSourceList; Overload;
    function Clone : TFhirSpecimenSourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenSource to the end of the list.
    }
    function Append : TFhirSpecimenSource;

    
    {@member AddItem
      Add an already existing FhirSpecimenSource to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenSource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenSource) : Integer;
    

    {@member Insert
      Insert FhirSpecimenSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenSource;
    

    {@member InsertItem
       Insert an existing FhirSpecimenSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenSource);
    
    {@member Item
       Get the iIndexth FhirSpecimenSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenSources[index : Integer] : TFhirSpecimenSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenCollection : TFhirElement
    Details concerning the specimen collection.
  }
  {!.Net HL7Connect.Fhir.SpecimenCollection}
  TFhirSpecimenCollection = class (TFhirElement)
  private
    FCollector : TFhirResourceReference{TFhirPractitioner};
    FcommentList : TFhirStringList;
    FCollectedTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FSourceSite : TFhirCodeableConcept;
    Procedure SetCollector(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetCollectedTime(value : TFhirDateTime);
    Function GetCollectedTimeST : TDateAndTime;
    Procedure SetCollectedTimeST(value : TDateAndTime);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetSourceSite(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenCollection; overload;
    function Clone : TFhirSpecimenCollection; overload;
    {!script show}
  published
    {@member collector
      Person who collected the specimen.
    }
    property collector : TFhirResourceReference{TFhirPractitioner} read FCollector write SetCollector;

    {@member commentList
      To communicate any details or issues encountered during the specimen collection procedure.
    }
    property commentList : TFhirStringList read FCommentList;

    {@member collectedTime
      Time when specimen was collected from subject - the physiologically relevant time.
    }
    property collectedTime : TFhirDateTime read FCollectedTime write SetCollectedTime;
    {@member collectedTimeST
      Typed access to Time when specimen was collected from subject - the physiologically relevant time.
    }
    property collectedTimeST : TDateAndTime read GetCollectedTimeST write SetCollectedTimeST;

    {@member quantity
      The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member method
      A coded value specifying the technique that is used to perform the procedure.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member sourceSite
      Anatomical location from which the specimen should be collected (if subject is a patient).
    }
    property sourceSite : TFhirCodeableConcept read FSourceSite write SetSourceSite;

  end;


  {@Class TFhirSpecimenCollectionList
    A list of FhirSpecimenCollection
  }
  {!.Net HL7Connect.Fhir.SpecimenCollectionList}
  TFhirSpecimenCollectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenCollection;
    procedure SetItemN(index : Integer; value : TFhirSpecimenCollection);
  public
    {!script hide}
    function Link : TFhirSpecimenCollectionList; Overload;
    function Clone : TFhirSpecimenCollectionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenCollection to the end of the list.
    }
    function Append : TFhirSpecimenCollection;

    
    {@member AddItem
      Add an already existing FhirSpecimenCollection to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenCollection);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenCollection) : Integer;
    

    {@member Insert
      Insert FhirSpecimenCollection before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenCollection;
    

    {@member InsertItem
       Insert an existing FhirSpecimenCollection before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenCollection);
    
    {@member Item
       Get the iIndexth FhirSpecimenCollection. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenCollection. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenCollection);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenCollection;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenCollections[index : Integer] : TFhirSpecimenCollection read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenTreatment : TFhirElement
    Details concerning treatment and processing steps for the specimen.
  }
  {!.Net HL7Connect.Fhir.SpecimenTreatment}
  TFhirSpecimenTreatment = class (TFhirElement)
  private
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FadditiveList : TFhirResourceReferenceList{TFhirSubstance};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetProcedure_(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenTreatment; overload;
    function Clone : TFhirSpecimenTreatment; overload;
    {!script show}
  published
    {@member description
      Textual description of procedure.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Textual description of procedure.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member procedure_
      A coded value specifying the procedure used to process the specimen.
    }
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    {@member additiveList
      Specimen additive.
    }
    property additiveList : TFhirResourceReferenceList{TFhirSubstance} read FAdditiveList;

  end;


  {@Class TFhirSpecimenTreatmentList
    A list of FhirSpecimenTreatment
  }
  {!.Net HL7Connect.Fhir.SpecimenTreatmentList}
  TFhirSpecimenTreatmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenTreatment;
    procedure SetItemN(index : Integer; value : TFhirSpecimenTreatment);
  public
    {!script hide}
    function Link : TFhirSpecimenTreatmentList; Overload;
    function Clone : TFhirSpecimenTreatmentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenTreatment to the end of the list.
    }
    function Append : TFhirSpecimenTreatment;

    
    {@member AddItem
      Add an already existing FhirSpecimenTreatment to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenTreatment);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenTreatment) : Integer;
    

    {@member Insert
      Insert FhirSpecimenTreatment before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenTreatment;
    

    {@member InsertItem
       Insert an existing FhirSpecimenTreatment before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenTreatment);
    
    {@member Item
       Get the iIndexth FhirSpecimenTreatment. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenTreatment. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenTreatment);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenTreatment;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenTreatments[index : Integer] : TFhirSpecimenTreatment read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenContainer : TFhirElement
    The container holding the specimen. May be recursive; ie blood in tube in tray in rack.
  }
  {!.Net HL7Connect.Fhir.SpecimenContainer}
  TFhirSpecimenContainer = class (TFhirElement)
  private
    FidentifierList : TFhirIdentifierList;
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FCapacity : TFhirQuantity;
    FSpecimenQuantity : TFhirQuantity;
    FAdditive : TFhirResourceReference{TFhirSubstance};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetCapacity(value : TFhirQuantity);
    Procedure SetSpecimenQuantity(value : TFhirQuantity);
    Procedure SetAdditive(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenContainer; overload;
    function Clone : TFhirSpecimenContainer; overload;
    {!script show}
  published
    {@member identifierList
      Id for container. There may be muliple; a manufacturer's bar code, lab assigned identifier, etc.
    }
    property identifierList : TFhirIdentifierList read FIdentifierList;

    {@member description
      Textual description of container.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Textual description of container.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member type_
      The type of container associated with the specimen (eg slide, aliquot, etc).
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member capacity
      The capacity (volume or other measure the container may contain.
    }
    property capacity : TFhirQuantity read FCapacity write SetCapacity;

    {@member specimenQuantity
      The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    }
    property specimenQuantity : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;

    {@member additive
      Additive associated with the container.
    }
    property additive : TFhirResourceReference{TFhirSubstance} read FAdditive write SetAdditive;

  end;


  {@Class TFhirSpecimenContainerList
    A list of FhirSpecimenContainer
  }
  {!.Net HL7Connect.Fhir.SpecimenContainerList}
  TFhirSpecimenContainerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenContainer);
  public
    {!script hide}
    function Link : TFhirSpecimenContainerList; Overload;
    function Clone : TFhirSpecimenContainerList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenContainer to the end of the list.
    }
    function Append : TFhirSpecimenContainer;

    
    {@member AddItem
      Add an already existing FhirSpecimenContainer to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenContainer);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenContainer) : Integer;
    

    {@member Insert
      Insert FhirSpecimenContainer before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenContainer;
    

    {@member InsertItem
       Insert an existing FhirSpecimenContainer before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenContainer);
    
    {@member Item
       Get the iIndexth FhirSpecimenContainer. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenContainer. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenContainer);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenContainer;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenContainers[index : Integer] : TFhirSpecimenContainer read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSupplyDispense : TFhirElement
    Indicates the details of the dispense event such as the days supply and quantity of a supply dispensed.
  }
  {!.Net HL7Connect.Fhir.SupplyDispense}
  TFhirSupplyDispense = class (TFhirElement)
  private
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirCode;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FSuppliedItem : TFhirResourceReference{Resource};
    FSupplier : TFhirResourceReference{TFhirPractitioner};
    FWhenPrepared : TFhirPeriod;
    FWhenHandedOver : TFhirPeriod;
    FDestination : TFhirResourceReference{TFhirLocation};
    FreceiverList : TFhirResourceReferenceList{TFhirPractitioner};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirCode);
    Function GetStatusST : String;
    Procedure SetStatusST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetSuppliedItem(value : TFhirResourceReference{Resource});
    Procedure SetSupplier(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetWhenPrepared(value : TFhirPeriod);
    Procedure SetWhenHandedOver(value : TFhirPeriod);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSupplyDispense; overload;
    function Clone : TFhirSupplyDispense; overload;
    {!script show}
  published
    {@member identifier
      Identifier assigned by the dispensing facility.   This is an identifier assigned outside FHIR.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member status
      A code specifying the state of the dispense event.
    }
    property status : TFhirCode read FStatus write SetStatus;
    {@member statusST
      Typed access to A code specifying the state of the dispense event.
    }
    property statusST : String read GetStatusST write SetStatusST;

    {@member type_
      Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member quantity
      The amount of supply that has been dispensed. Includes unit of measure.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member suppliedItem
      Identifies the medication or substance being dispensed. This is either a link to a resource representing the details of the medication or substance or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property suppliedItem : TFhirResourceReference{Resource} read FSuppliedItem write SetSuppliedItem;

    {@member supplier
      The individual reponsible for dispensing the medication.
    }
    property supplier : TFhirResourceReference{TFhirPractitioner} read FSupplier write SetSupplier;

    {@member whenPrepared
      The time the dispense event occurred.
    }
    property whenPrepared : TFhirPeriod read FWhenPrepared write SetWhenPrepared;

    {@member whenHandedOver
      The time the dispense event occurred.
    }
    property whenHandedOver : TFhirPeriod read FWhenHandedOver write SetWhenHandedOver;

    {@member destination
      Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member receiverList
      Identifies the person who picked up the Supply.
    }
    property receiverList : TFhirResourceReferenceList{TFhirPractitioner} read FReceiverList;

  end;


  {@Class TFhirSupplyDispenseList
    A list of FhirSupplyDispense
  }
  {!.Net HL7Connect.Fhir.SupplyDispenseList}
  TFhirSupplyDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyDispense;
    procedure SetItemN(index : Integer; value : TFhirSupplyDispense);
  public
    {!script hide}
    function Link : TFhirSupplyDispenseList; Overload;
    function Clone : TFhirSupplyDispenseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSupplyDispense to the end of the list.
    }
    function Append : TFhirSupplyDispense;

    
    {@member AddItem
      Add an already existing FhirSupplyDispense to the end of the list.
    }
    procedure AddItem(value : TFhirSupplyDispense);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSupplyDispense) : Integer;
    

    {@member Insert
      Insert FhirSupplyDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSupplyDispense;
    

    {@member InsertItem
       Insert an existing FhirSupplyDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSupplyDispense);
    
    {@member Item
       Get the iIndexth FhirSupplyDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSupplyDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSupplyDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSupplyDispenses[index : Integer] : TFhirSupplyDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetDefine : TFhirElement
    When value set defines its own codes.
  }
  {!.Net HL7Connect.Fhir.ValueSetDefine}
  TFhirValueSetDefine = class (TFhirElement)
  private
    FSystem : TFhirUri;
    FCaseSensitive : TFhirBoolean;
    FconceptList : TFhirValueSetDefineConceptList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCaseSensitive(value : TFhirBoolean);
    Function GetCaseSensitiveST : String;
    Procedure SetCaseSensitiveST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetDefine; overload;
    function Clone : TFhirValueSetDefine; overload;
    {!script show}
  published
    {@member system
      URI to identify the code system.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to URI to identify the code system.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member caseSensitive
      If code comparison is case sensitive when codes within this systemare compared to each other.
    }
    property caseSensitive : TFhirBoolean read FCaseSensitive write SetCaseSensitive;
    {@member caseSensitiveST
      Typed access to If code comparison is case sensitive when codes within this systemare compared to each other.
    }
    property caseSensitiveST : String read GetCaseSensitiveST write SetCaseSensitiveST;

    {@member conceptList
      Concepts in the code system.
    }
    property conceptList : TFhirValueSetDefineConceptList read FConceptList;

  end;


  {@Class TFhirValueSetDefineList
    A list of FhirValueSetDefine
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineList}
  TFhirValueSetDefineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetDefine;
    procedure SetItemN(index : Integer; value : TFhirValueSetDefine);
  public
    {!script hide}
    function Link : TFhirValueSetDefineList; Overload;
    function Clone : TFhirValueSetDefineList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetDefine to the end of the list.
    }
    function Append : TFhirValueSetDefine;

    
    {@member AddItem
      Add an already existing FhirValueSetDefine to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetDefine);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetDefine) : Integer;
    

    {@member Insert
      Insert FhirValueSetDefine before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetDefine;
    

    {@member InsertItem
       Insert an existing FhirValueSetDefine before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetDefine);
    
    {@member Item
       Get the iIndexth FhirValueSetDefine. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetDefine. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetDefine);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetDefine;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetDefines[index : Integer] : TFhirValueSetDefine read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetDefineConcept : TFhirElement
    Concepts in the code system.
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineConcept}
  TFhirValueSetDefineConcept = class (TFhirElement)
  private
    FCode : TFhirCode;
    FAbstract : TFhirBoolean;
    FDisplay : TFhirString;
    FDefinition : TFhirString;
    FconceptList : TFhirValueSetDefineConceptList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : String;
    Procedure SetAbstractST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetDefinition(value : TFhirString);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetDefineConcept; overload;
    function Clone : TFhirValueSetDefineConcept; overload;
    {!script show}
  published
    {@member code
      Code that identifies concept.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Code that identifies concept.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member abstract
      If this code is not for use as a real concept.
    }
    property abstract : TFhirBoolean read FAbstract write SetAbstract;
    {@member abstractST
      Typed access to If this code is not for use as a real concept.
    }
    property abstractST : String read GetAbstractST write SetAbstractST;

    {@member display
      Text to Display to the user.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to Text to Display to the user.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

    {@member definition
      Formal Definition.
    }
    property definition : TFhirString read FDefinition write SetDefinition;
    {@member definitionST
      Typed access to Formal Definition.
    }
    property definitionST : String read GetDefinitionST write SetDefinitionST;

    {@member conceptList
      Child Concepts (is-a / contains).
    }
    property conceptList : TFhirValueSetDefineConceptList read FConceptList;

  end;


  {@Class TFhirValueSetDefineConceptList
    A list of FhirValueSetDefineConcept
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineConceptList}
  TFhirValueSetDefineConceptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetDefineConcept;
    procedure SetItemN(index : Integer; value : TFhirValueSetDefineConcept);
  public
    {!script hide}
    function Link : TFhirValueSetDefineConceptList; Overload;
    function Clone : TFhirValueSetDefineConceptList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetDefineConcept to the end of the list.
    }
    function Append : TFhirValueSetDefineConcept;

    
    {@member AddItem
      Add an already existing FhirValueSetDefineConcept to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetDefineConcept);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetDefineConcept) : Integer;
    

    {@member Insert
      Insert FhirValueSetDefineConcept before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetDefineConcept;
    

    {@member InsertItem
       Insert an existing FhirValueSetDefineConcept before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetDefineConcept);
    
    {@member Item
       Get the iIndexth FhirValueSetDefineConcept. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetDefineConcept. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetDefineConcept);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetDefineConcept;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetDefineConcepts[index : Integer] : TFhirValueSetDefineConcept read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetCompose : TFhirElement
    When value set includes codes from elsewhere.
  }
  {!.Net HL7Connect.Fhir.ValueSetCompose}
  TFhirValueSetCompose = class (TFhirElement)
  private
    FimportList : TFhirUriList;
    FincludeList : TFhirValueSetComposeIncludeList;
    FexcludeList : TFhirValueSetComposeIncludeList;
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetCompose; overload;
    function Clone : TFhirValueSetCompose; overload;
    {!script show}
  published
    {@member importList
      Includes the contents of the referenced value set as part of the contents of this value set.
    }
    property importList : TFhirUriList read FImportList;

    {@member includeList
      Include one or more codes from a code system.
    }
    property includeList : TFhirValueSetComposeIncludeList read FIncludeList;

    {@member excludeList
      Exclude one or more codes from the value set.
    }
    property excludeList : TFhirValueSetComposeIncludeList read FExcludeList;

  end;


  {@Class TFhirValueSetComposeList
    A list of FhirValueSetCompose
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeList}
  TFhirValueSetComposeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetCompose;
    procedure SetItemN(index : Integer; value : TFhirValueSetCompose);
  public
    {!script hide}
    function Link : TFhirValueSetComposeList; Overload;
    function Clone : TFhirValueSetComposeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetCompose to the end of the list.
    }
    function Append : TFhirValueSetCompose;

    
    {@member AddItem
      Add an already existing FhirValueSetCompose to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetCompose);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetCompose) : Integer;
    

    {@member Insert
      Insert FhirValueSetCompose before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetCompose;
    

    {@member InsertItem
       Insert an existing FhirValueSetCompose before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetCompose);
    
    {@member Item
       Get the iIndexth FhirValueSetCompose. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetCompose. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCompose);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetCompose;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposes[index : Integer] : TFhirValueSetCompose read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetComposeInclude : TFhirElement
    Include one or more codes from a code system.
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeInclude}
  TFhirValueSetComposeInclude = class (TFhirElement)
  private
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FcodeList : TFhirCodeList;
    FfilterList : TFhirValueSetComposeIncludeFilterList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetComposeInclude; overload;
    function Clone : TFhirValueSetComposeInclude; overload;
    {!script show}
  published
    {@member system
      The code system from which the selected codes come from.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to The code system from which the selected codes come from.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member version
      The version of the code system that the codes are selected from.
    }
    property version : TFhirString read FVersion write SetVersion;
    {@member versionST
      Typed access to The version of the code system that the codes are selected from.
    }
    property versionST : String read GetVersionST write SetVersionST;

    {@member codeList
      Specifies a code or concept to be included or excluded.
    }
    property codeList : TFhirCodeList read FCodeList;

    {@member filterList
      Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they must all be true.
    }
    property filterList : TFhirValueSetComposeIncludeFilterList read FFilterList;

  end;


  {@Class TFhirValueSetComposeIncludeList
    A list of FhirValueSetComposeInclude
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeList}
  TFhirValueSetComposeIncludeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeInclude;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeInclude);
  public
    {!script hide}
    function Link : TFhirValueSetComposeIncludeList; Overload;
    function Clone : TFhirValueSetComposeIncludeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetComposeInclude to the end of the list.
    }
    function Append : TFhirValueSetComposeInclude;

    
    {@member AddItem
      Add an already existing FhirValueSetComposeInclude to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetComposeInclude);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetComposeInclude) : Integer;
    

    {@member Insert
      Insert FhirValueSetComposeInclude before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetComposeInclude;
    

    {@member InsertItem
       Insert an existing FhirValueSetComposeInclude before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeInclude);
    
    {@member Item
       Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeInclude);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetComposeInclude;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludes[index : Integer] : TFhirValueSetComposeInclude read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetComposeIncludeFilter : TFhirElement
    Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they must all be true.
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeFilter}
  TFhirValueSetComposeIncludeFilter = class (TFhirElement)
  private
    FProperty_ : TFhirCode;
    FOp : TFhirEnum;
    FValue : TFhirCode;
    Procedure SetProperty_(value : TFhirCode);
    Function GetProperty_ST : String;
    Procedure SetProperty_ST(value : String);
    Procedure SetOp(value : TFhirEnum);
    Function GetOpST : TFhirFilterOperator;
    Procedure SetOpST(value : TFhirFilterOperator);
    Procedure SetValue(value : TFhirCode);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetComposeIncludeFilter; overload;
    function Clone : TFhirValueSetComposeIncludeFilter; overload;
    {!script show}
  published
    {@member property_
      A code that identifies a property defined in the code system.
    }
    property property_ : TFhirCode read FProperty_ write SetProperty_;
    {@member property_ST
      Typed access to A code that identifies a property defined in the code system.
    }
    property property_ST : String read GetProperty_ST write SetProperty_ST;

    {@member op
      The kind of operation to perform as part of the filter criteria.
    }
    property op : TFhirEnum read FOp write SetOp;
    {@member opST
      Typed access to The kind of operation to perform as part of the filter criteria.
    }
    property opST : TFhirFilterOperator read GetOpST write SetOpST;

    {@member value
      The match value may be either a code defined by the system, or a string value which is used a regex match on the literal string of the property value.
    }
    property value : TFhirCode read FValue write SetValue;
    {@member valueST
      Typed access to The match value may be either a code defined by the system, or a string value which is used a regex match on the literal string of the property value.
    }
    property valueST : String read GetValueST write SetValueST;

  end;


  {@Class TFhirValueSetComposeIncludeFilterList
    A list of FhirValueSetComposeIncludeFilter
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeFilterList}
  TFhirValueSetComposeIncludeFilterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeFilter;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeFilter);
  public
    {!script hide}
    function Link : TFhirValueSetComposeIncludeFilterList; Overload;
    function Clone : TFhirValueSetComposeIncludeFilterList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetComposeIncludeFilter to the end of the list.
    }
    function Append : TFhirValueSetComposeIncludeFilter;

    
    {@member AddItem
      Add an already existing FhirValueSetComposeIncludeFilter to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetComposeIncludeFilter);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetComposeIncludeFilter) : Integer;
    

    {@member Insert
      Insert FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetComposeIncludeFilter;
    

    {@member InsertItem
       Insert an existing FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    {@member Item
       Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetComposeIncludeFilter;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludeFilters[index : Integer] : TFhirValueSetComposeIncludeFilter read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetExpansion : TFhirElement
    When value set is an expansion.
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansion}
  TFhirValueSetExpansion = class (TFhirElement)
  private
    FTimestamp : TFhirInstant;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetTimestamp(value : TFhirInstant);
    Function GetTimestampST : TDateAndTime;
    Procedure SetTimestampST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetExpansion; overload;
    function Clone : TFhirValueSetExpansion; overload;
    {!script show}
  published
    {@member timestamp
      Time valueset expansion happened.
    }
    property timestamp : TFhirInstant read FTimestamp write SetTimestamp;
    {@member timestampST
      Typed access to Time valueset expansion happened.
    }
    property timestampST : TDateAndTime read GetTimestampST write SetTimestampST;

    {@member containsList
      Codes in the value set.
    }
    property containsList : TFhirValueSetExpansionContainsList read FContainsList;

  end;


  {@Class TFhirValueSetExpansionList
    A list of FhirValueSetExpansion
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionList}
  TFhirValueSetExpansionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansion;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansion);
  public
    {!script hide}
    function Link : TFhirValueSetExpansionList; Overload;
    function Clone : TFhirValueSetExpansionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetExpansion to the end of the list.
    }
    function Append : TFhirValueSetExpansion;

    
    {@member AddItem
      Add an already existing FhirValueSetExpansion to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetExpansion);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetExpansion) : Integer;
    

    {@member Insert
      Insert FhirValueSetExpansion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetExpansion;
    

    {@member InsertItem
       Insert an existing FhirValueSetExpansion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansion);
    
    {@member Item
       Get the iIndexth FhirValueSetExpansion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetExpansion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetExpansion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetExpansions[index : Integer] : TFhirValueSetExpansion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetExpansionContains : TFhirElement
    Codes in the value set.
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionContains}
  TFhirValueSetExpansionContains = class (TFhirElement)
  private
    FSystem : TFhirUri;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetExpansionContains; overload;
    function Clone : TFhirValueSetExpansionContains; overload;
    {!script show}
  published
    {@member system
      System value for the code.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to System value for the code.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member code
      Code - if blank, this is not a choosable code.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Code - if blank, this is not a choosable code.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member display
      User display for the concept.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to User display for the concept.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

    {@member containsList
      Codes contained in this concept.
    }
    property containsList : TFhirValueSetExpansionContainsList read FContainsList;

  end;


  {@Class TFhirValueSetExpansionContainsList
    A list of FhirValueSetExpansionContains
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionContainsList}
  TFhirValueSetExpansionContainsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansionContains;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionContains);
  public
    {!script hide}
    function Link : TFhirValueSetExpansionContainsList; Overload;
    function Clone : TFhirValueSetExpansionContainsList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetExpansionContains to the end of the list.
    }
    function Append : TFhirValueSetExpansionContains;

    
    {@member AddItem
      Add an already existing FhirValueSetExpansionContains to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetExpansionContains);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetExpansionContains) : Integer;
    

    {@member Insert
      Insert FhirValueSetExpansionContains before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetExpansionContains;
    

    {@member InsertItem
       Insert an existing FhirValueSetExpansionContains before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionContains);
    
    {@member Item
       Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionContains);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetExpansionContains;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetExpansionContains[index : Integer] : TFhirValueSetExpansionContains read GetItemN write SetItemN; default;
  End;


implementation

{ TFhirAdverseReactionSymptom }

constructor TFhirAdverseReactionSymptom.Create;
begin
  inherited;
end;

destructor TFhirAdverseReactionSymptom.Destroy;
begin
  FCode.free;
  FSeverity.free;
  inherited;
end;

procedure TFhirAdverseReactionSymptom.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirAdverseReactionSymptom(oSource).code.Clone;
  FSeverity := TFhirAdverseReactionSymptom(oSource).FSeverity.Link;
end;

procedure TFhirAdverseReactionSymptom.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
end;

procedure TFhirAdverseReactionSymptom.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
end;

function TFhirAdverseReactionSymptom.Link : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(inherited Link);
end;

function TFhirAdverseReactionSymptom.Clone : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(inherited Clone);
end;

{ TFhirAdverseReactionSymptom }

Procedure TFhirAdverseReactionSymptom.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirAdverseReactionSymptom.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirAdverseReactionSymptom.GetSeverityST : TFhirReactionSeverity;
begin
  if FSeverity = nil then
    result := TFhirReactionSeverity(0)
  else
    result := TFhirReactionSeverity(StringArrayIndexOf(CODES_TFhirReactionSeverity, Severity.value));
end;

Procedure TFhirAdverseReactionSymptom.SetSeverityST(value : TFhirReactionSeverity);
begin
  if ord(value) = 0 then
    Severity := nil
  else
    Severity := TFhirEnum.create(CODES_TFhirReactionSeverity[value]);
end;


{ TFhirAdverseReactionSymptomList }
procedure TFhirAdverseReactionSymptomList.AddItem(value: TFhirAdverseReactionSymptom);
begin
  assert(value.ClassName = 'TFhirAdverseReactionSymptom', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseReactionSymptom');
  add(value);
end;


function TFhirAdverseReactionSymptomList.Append: TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionSymptomList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseReactionSymptomList.Clone: TFhirAdverseReactionSymptomList;
begin
  result := TFhirAdverseReactionSymptomList(inherited Clone);
end;

function TFhirAdverseReactionSymptomList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseReactionSymptomList.GetItemN(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(ObjectByIndex[index]);
end;

function TFhirAdverseReactionSymptomList.IndexOf(value: TFhirAdverseReactionSymptom): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirAdverseReactionSymptomList.Insert(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionSymptomList.InsertItem(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  Inherited Insert(index, value);
end;

function TFhirAdverseReactionSymptomList.Item(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(ObjectByIndex[index]);
end;

function TFhirAdverseReactionSymptomList.Link: TFhirAdverseReactionSymptomList;
begin
  result := TFhirAdverseReactionSymptomList(inherited Link);
end;

procedure TFhirAdverseReactionSymptomList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseReactionSymptomList.SetItemByIndex(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  FhirAdverseReactionSymptoms[index] := value;
end;

procedure TFhirAdverseReactionSymptomList.SetItemN(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseReactionExposure }

constructor TFhirAdverseReactionExposure.Create;
begin
  inherited;
end;

destructor TFhirAdverseReactionExposure.Destroy;
begin
  FExposureDate.free;
  FExposureType.free;
  FCausalityExpectation.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirAdverseReactionExposure.Assign(oSource : TAdvObject);
begin
  inherited;
  exposureDate := TFhirAdverseReactionExposure(oSource).exposureDate.Clone;
  FExposureType := TFhirAdverseReactionExposure(oSource).FExposureType.Link;
  FCausalityExpectation := TFhirAdverseReactionExposure(oSource).FCausalityExpectation.Link;
  substance := TFhirAdverseReactionExposure(oSource).substance.Clone;
end;

procedure TFhirAdverseReactionExposure.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'exposureDate') Then
     list.add(ExposureDate.Link);
  if (child_name = 'exposureType') Then
     list.add(FExposureType.Link);
  if (child_name = 'causalityExpectation') Then
     list.add(FCausalityExpectation.Link);
  if (child_name = 'substance') Then
     list.add(Substance.Link);
end;

procedure TFhirAdverseReactionExposure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'exposureDate', 'dateTime', FExposureDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposureType', 'code', FExposureType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'causalityExpectation', 'code', FCausalityExpectation.Link));{1}
  oList.add(TFHIRProperty.create(self, 'substance', 'Resource(Substance)', FSubstance.Link.Link));{2}
end;

function TFhirAdverseReactionExposure.Link : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(inherited Link);
end;

function TFhirAdverseReactionExposure.Clone : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(inherited Clone);
end;

{ TFhirAdverseReactionExposure }

Procedure TFhirAdverseReactionExposure.SetExposureDate(value : TFhirDateTime);
begin
  FExposureDate.free;
  FExposureDate := value;
end;

Function TFhirAdverseReactionExposure.GetExposureDateST : TDateAndTime;
begin
  if FExposureDate = nil then
    result := nil
  else
    result := ExposureDate.value;
end;

Procedure TFhirAdverseReactionExposure.SetExposureDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FExposureDate = nil then
      FExposureDate := TFhirDateTime.create;
    FExposureDate.value := value
  end
  else if FExposureDate <> nil then
    FExposureDate.value := nil;
end;

Procedure TFhirAdverseReactionExposure.SetExposureType(value : TFhirEnum);
begin
  FExposureType.free;
  FExposureType := value;
end;

Function TFhirAdverseReactionExposure.GetExposureTypeST : TFhirExposureType;
begin
  if FExposureType = nil then
    result := TFhirExposureType(0)
  else
    result := TFhirExposureType(StringArrayIndexOf(CODES_TFhirExposureType, ExposureType.value));
end;

Procedure TFhirAdverseReactionExposure.SetExposureTypeST(value : TFhirExposureType);
begin
  if ord(value) = 0 then
    ExposureType := nil
  else
    ExposureType := TFhirEnum.create(CODES_TFhirExposureType[value]);
end;

Procedure TFhirAdverseReactionExposure.SetCausalityExpectation(value : TFhirEnum);
begin
  FCausalityExpectation.free;
  FCausalityExpectation := value;
end;

Function TFhirAdverseReactionExposure.GetCausalityExpectationST : TFhirCausalityExpectation;
begin
  if FCausalityExpectation = nil then
    result := TFhirCausalityExpectation(0)
  else
    result := TFhirCausalityExpectation(StringArrayIndexOf(CODES_TFhirCausalityExpectation, CausalityExpectation.value));
end;

Procedure TFhirAdverseReactionExposure.SetCausalityExpectationST(value : TFhirCausalityExpectation);
begin
  if ord(value) = 0 then
    CausalityExpectation := nil
  else
    CausalityExpectation := TFhirEnum.create(CODES_TFhirCausalityExpectation[value]);
end;

Procedure TFhirAdverseReactionExposure.SetSubstance(value : TFhirResourceReference{TFhirSubstance});
begin
  FSubstance.free;
  FSubstance := value;
end;


{ TFhirAdverseReactionExposureList }
procedure TFhirAdverseReactionExposureList.AddItem(value: TFhirAdverseReactionExposure);
begin
  assert(value.ClassName = 'TFhirAdverseReactionExposure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseReactionExposure');
  add(value);
end;


function TFhirAdverseReactionExposureList.Append: TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionExposureList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseReactionExposureList.Clone: TFhirAdverseReactionExposureList;
begin
  result := TFhirAdverseReactionExposureList(inherited Clone);
end;

function TFhirAdverseReactionExposureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseReactionExposureList.GetItemN(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(ObjectByIndex[index]);
end;

function TFhirAdverseReactionExposureList.IndexOf(value: TFhirAdverseReactionExposure): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirAdverseReactionExposureList.Insert(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionExposureList.InsertItem(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  Inherited Insert(index, value);
end;

function TFhirAdverseReactionExposureList.Item(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(ObjectByIndex[index]);
end;

function TFhirAdverseReactionExposureList.Link: TFhirAdverseReactionExposureList;
begin
  result := TFhirAdverseReactionExposureList(inherited Link);
end;

procedure TFhirAdverseReactionExposureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseReactionExposureList.SetItemByIndex(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  FhirAdverseReactionExposures[index] := value;
end;

procedure TFhirAdverseReactionExposureList.SetItemN(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanParticipant }

constructor TFhirCarePlanParticipant.Create;
begin
  inherited;
end;

destructor TFhirCarePlanParticipant.Destroy;
begin
  FRole.free;
  FMember.free;
  inherited;
end;

procedure TFhirCarePlanParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  role := TFhirCarePlanParticipant(oSource).role.Clone;
  member := TFhirCarePlanParticipant(oSource).member.Clone;
end;

procedure TFhirCarePlanParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(Role.Link);
  if (child_name = 'member') Then
     list.add(Member.Link);
end;

procedure TFhirCarePlanParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRole.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'member', 'Resource(Practitioner|RelatedPerson|Patient|Organization)', FMember.Link.Link));{2}
end;

function TFhirCarePlanParticipant.Link : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Link);
end;

function TFhirCarePlanParticipant.Clone : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Clone);
end;

{ TFhirCarePlanParticipant }

Procedure TFhirCarePlanParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirCarePlanParticipant.SetMember(value : TFhirResourceReference{Resource});
begin
  FMember.free;
  FMember := value;
end;


{ TFhirCarePlanParticipantList }
procedure TFhirCarePlanParticipantList.AddItem(value: TFhirCarePlanParticipant);
begin
  assert(value.ClassName = 'TFhirCarePlanParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanParticipant');
  add(value);
end;


function TFhirCarePlanParticipantList.Append: TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanParticipantList.Clone: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Clone);
end;

function TFhirCarePlanParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanParticipantList.GetItemN(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.IndexOf(value: TFhirCarePlanParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanParticipantList.Insert(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanParticipantList.InsertItem(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  Inherited Insert(index, value);
end;

function TFhirCarePlanParticipantList.Item(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.Link: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Link);
end;

procedure TFhirCarePlanParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanParticipantList.SetItemByIndex(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  FhirCarePlanParticipants[index] := value;
end;

procedure TFhirCarePlanParticipantList.SetItemN(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanGoal }

constructor TFhirCarePlanGoal.Create;
begin
  inherited;
end;

destructor TFhirCarePlanGoal.Destroy;
begin
  FDescription.free;
  FStatus.free;
  FNotes.free;
  inherited;
end;

procedure TFhirCarePlanGoal.Assign(oSource : TAdvObject);
begin
  inherited;
  description := TFhirCarePlanGoal(oSource).description.Clone;
  FStatus := TFhirCarePlanGoal(oSource).FStatus.Link;
  notes := TFhirCarePlanGoal(oSource).notes.Clone;
end;

procedure TFhirCarePlanGoal.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'notes') Then
     list.add(Notes.Link);
end;

procedure TFhirCarePlanGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notes', 'string', FNotes.Link.Link));{2}
end;

function TFhirCarePlanGoal.Link : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(inherited Link);
end;

function TFhirCarePlanGoal.Clone : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(inherited Clone);
end;

{ TFhirCarePlanGoal }

Procedure TFhirCarePlanGoal.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCarePlanGoal.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirCarePlanGoal.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirCarePlanGoal.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanGoal.GetStatusST : TFhirCarePlanGoalStatus;
begin
  if FStatus = nil then
    result := TFhirCarePlanGoalStatus(0)
  else
    result := TFhirCarePlanGoalStatus(StringArrayIndexOf(CODES_TFhirCarePlanGoalStatus, Status.value));
end;

Procedure TFhirCarePlanGoal.SetStatusST(value : TFhirCarePlanGoalStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirCarePlanGoalStatus[value]);
end;

Procedure TFhirCarePlanGoal.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirCarePlanGoal.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := Notes.value;
end;

Procedure TFhirCarePlanGoal.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;


{ TFhirCarePlanGoalList }
procedure TFhirCarePlanGoalList.AddItem(value: TFhirCarePlanGoal);
begin
  assert(value.ClassName = 'TFhirCarePlanGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanGoal');
  add(value);
end;


function TFhirCarePlanGoalList.Append: TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanGoalList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanGoalList.Clone: TFhirCarePlanGoalList;
begin
  result := TFhirCarePlanGoalList(inherited Clone);
end;

function TFhirCarePlanGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanGoalList.GetItemN(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(ObjectByIndex[index]);
end;

function TFhirCarePlanGoalList.IndexOf(value: TFhirCarePlanGoal): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanGoalList.Insert(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanGoalList.InsertItem(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  Inherited Insert(index, value);
end;

function TFhirCarePlanGoalList.Item(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(ObjectByIndex[index]);
end;

function TFhirCarePlanGoalList.Link: TFhirCarePlanGoalList;
begin
  result := TFhirCarePlanGoalList(inherited Link);
end;

procedure TFhirCarePlanGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanGoalList.SetItemByIndex(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  FhirCarePlanGoals[index] := value;
end;

procedure TFhirCarePlanGoalList.SetItemN(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivity }

constructor TFhirCarePlanActivity.Create;
begin
  inherited;
  FPerformerList := TFhirResourceReferenceList{Resource}.Create;
  FActionTakenList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirCarePlanActivity.Destroy;
begin
  FCategory.free;
  FCode.free;
  FStatus.free;
  FProhibited.free;
  FTiming.free;
  FLocation.free;
  FPerformerList.Free;
  FProduct.free;
  FDailyAmount.free;
  FQuantity.free;
  FDetails.free;
  FActionTakenList.Free;
  FNotes.free;
  inherited;
end;

procedure TFhirCarePlanActivity.Assign(oSource : TAdvObject);
begin
  inherited;
  FCategory := TFhirCarePlanActivity(oSource).FCategory.Link;
  code := TFhirCarePlanActivity(oSource).code.Clone;
  FStatus := TFhirCarePlanActivity(oSource).FStatus.Link;
  prohibited := TFhirCarePlanActivity(oSource).prohibited.Clone;
  timing := TFhirCarePlanActivity(oSource).timing.Clone;
  location := TFhirCarePlanActivity(oSource).location.Clone;
  FPerformerList.Assign(TFhirCarePlanActivity(oSource).FPerformerList);
  product := TFhirCarePlanActivity(oSource).product.Clone;
  dailyAmount := TFhirCarePlanActivity(oSource).dailyAmount.Clone;
  quantity := TFhirCarePlanActivity(oSource).quantity.Clone;
  details := TFhirCarePlanActivity(oSource).details.Clone;
  FActionTakenList.Assign(TFhirCarePlanActivity(oSource).FActionTakenList);
  notes := TFhirCarePlanActivity(oSource).notes.Clone;
end;

procedure TFhirCarePlanActivity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(FCategory.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'prohibited') Then
     list.add(Prohibited.Link);
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'location') Then
     list.add(Location.Link);
  if (child_name = 'performer') Then
     list.addAll(FPerformerList);
  if (child_name = 'product') Then
     list.add(Product.Link);
  if (child_name = 'dailyAmount') Then
     list.add(DailyAmount.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'details') Then
     list.add(Details.Link);
  if (child_name = 'actionTaken') Then
     list.addAll(FActionTakenList);
  if (child_name = 'notes') Then
     list.add(Notes.Link);
end;

procedure TFhirCarePlanActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'code', FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'prohibited', 'boolean', FProhibited.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Schedule|Period|string', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Resource(Location)', FLocation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Resource(Practitioner|Organization|RelatedPerson|Patient)', FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product', 'Resource(Medication|Substance)', FProduct.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dailyAmount', 'Quantity', FDailyAmount.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'details', 'string', FDetails.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actionTaken', 'Resource(Any)', FActionTakenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notes', 'string', FNotes.Link.Link));{2}
end;

function TFhirCarePlanActivity.Link : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Link);
end;

function TFhirCarePlanActivity.Clone : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Clone);
end;

{ TFhirCarePlanActivity }

Procedure TFhirCarePlanActivity.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirCarePlanActivity.GetCategoryST : TFhirCarePlanActivityCategory;
begin
  if FCategory = nil then
    result := TFhirCarePlanActivityCategory(0)
  else
    result := TFhirCarePlanActivityCategory(StringArrayIndexOf(CODES_TFhirCarePlanActivityCategory, Category.value));
end;

Procedure TFhirCarePlanActivity.SetCategoryST(value : TFhirCarePlanActivityCategory);
begin
  if ord(value) = 0 then
    Category := nil
  else
    Category := TFhirEnum.create(CODES_TFhirCarePlanActivityCategory[value]);
end;

Procedure TFhirCarePlanActivity.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCarePlanActivity.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanActivity.GetStatusST : TFhirCarePlanActivityStatus;
begin
  if FStatus = nil then
    result := TFhirCarePlanActivityStatus(0)
  else
    result := TFhirCarePlanActivityStatus(StringArrayIndexOf(CODES_TFhirCarePlanActivityStatus, Status.value));
end;

Procedure TFhirCarePlanActivity.SetStatusST(value : TFhirCarePlanActivityStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirCarePlanActivityStatus[value]);
end;

Procedure TFhirCarePlanActivity.SetProhibited(value : TFhirBoolean);
begin
  FProhibited.free;
  FProhibited := value;
end;

Function TFhirCarePlanActivity.GetProhibitedST : String;
begin
  if FProhibited = nil then
    result := ''
  else
    result := Prohibited.value;
end;

Procedure TFhirCarePlanActivity.SetProhibitedST(value : String);
begin
  if value <> '' then
  begin
    if FProhibited = nil then
      FProhibited := TFhirBoolean.create;
    FProhibited.value := value
  end
  else if FProhibited <> nil then
    FProhibited.value := '';
end;

Procedure TFhirCarePlanActivity.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirCarePlanActivity.SetLocation(value : TFhirResourceReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirCarePlanActivity.SetProduct(value : TFhirResourceReference{Resource});
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirCarePlanActivity.SetDailyAmount(value : TFhirQuantity);
begin
  FDailyAmount.free;
  FDailyAmount := value;
end;

Procedure TFhirCarePlanActivity.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirCarePlanActivity.SetDetails(value : TFhirString);
begin
  FDetails.free;
  FDetails := value;
end;

Function TFhirCarePlanActivity.GetDetailsST : String;
begin
  if FDetails = nil then
    result := ''
  else
    result := Details.value;
end;

Procedure TFhirCarePlanActivity.SetDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FDetails = nil then
      FDetails := TFhirString.create;
    FDetails.value := value
  end
  else if FDetails <> nil then
    FDetails.value := '';
end;

Procedure TFhirCarePlanActivity.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirCarePlanActivity.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := Notes.value;
end;

Procedure TFhirCarePlanActivity.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;


{ TFhirCarePlanActivityList }
procedure TFhirCarePlanActivityList.AddItem(value: TFhirCarePlanActivity);
begin
  assert(value.ClassName = 'TFhirCarePlanActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivity');
  add(value);
end;


function TFhirCarePlanActivityList.Append: TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivityList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityList.Clone: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Clone);
end;

function TFhirCarePlanActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityList.GetItemN(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.IndexOf(value: TFhirCarePlanActivity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanActivityList.Insert(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivityList.InsertItem(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityList.Item(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.Link: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Link);
end;

procedure TFhirCarePlanActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  FhirCarePlanActivities[index] := value;
end;

procedure TFhirCarePlanActivityList.SetItemN(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionStage }

constructor TFhirConditionStage.Create;
begin
  inherited;
  FAssessmentList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirConditionStage.Destroy;
begin
  FSummary.free;
  FAssessmentList.Free;
  inherited;
end;

procedure TFhirConditionStage.Assign(oSource : TAdvObject);
begin
  inherited;
  summary := TFhirConditionStage(oSource).summary.Clone;
  FAssessmentList.Assign(TFhirConditionStage(oSource).FAssessmentList);
end;

procedure TFhirConditionStage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'summary') Then
     list.add(Summary.Link);
  if (child_name = 'assessment') Then
     list.addAll(FAssessmentList);
end;

procedure TFhirConditionStage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'CodeableConcept', FSummary.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assessment', 'Resource(Any)', FAssessmentList.Link)){3};
end;

function TFhirConditionStage.Link : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Link);
end;

function TFhirConditionStage.Clone : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Clone);
end;

{ TFhirConditionStage }

Procedure TFhirConditionStage.SetSummary(value : TFhirCodeableConcept);
begin
  FSummary.free;
  FSummary := value;
end;


{ TFhirConditionStageList }
procedure TFhirConditionStageList.AddItem(value: TFhirConditionStage);
begin
  assert(value.ClassName = 'TFhirConditionStage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionStage');
  add(value);
end;


function TFhirConditionStageList.Append: TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionStageList.ClearItems;
begin
  Clear;
end;

function TFhirConditionStageList.Clone: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Clone);
end;

function TFhirConditionStageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionStageList.GetItemN(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.IndexOf(value: TFhirConditionStage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionStageList.Insert(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionStageList.InsertItem(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  Inherited Insert(index, value);
end;

function TFhirConditionStageList.Item(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.Link: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Link);
end;

procedure TFhirConditionStageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionStageList.SetItemByIndex(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  FhirConditionStages[index] := value;
end;

procedure TFhirConditionStageList.SetItemN(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionEvidence }

constructor TFhirConditionEvidence.Create;
begin
  inherited;
  FDetailList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirConditionEvidence.Destroy;
begin
  FCode.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirConditionEvidence.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConditionEvidence(oSource).code.Clone;
  FDetailList.Assign(TFhirConditionEvidence(oSource).FDetailList);
end;

procedure TFhirConditionEvidence.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirConditionEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Any)', FDetailList.Link)){3};
end;

function TFhirConditionEvidence.Link : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Link);
end;

function TFhirConditionEvidence.Clone : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Clone);
end;

{ TFhirConditionEvidence }

Procedure TFhirConditionEvidence.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirConditionEvidenceList }
procedure TFhirConditionEvidenceList.AddItem(value: TFhirConditionEvidence);
begin
  assert(value.ClassName = 'TFhirConditionEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionEvidence');
  add(value);
end;


function TFhirConditionEvidenceList.Append: TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirConditionEvidenceList.Clone: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Clone);
end;

function TFhirConditionEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionEvidenceList.GetItemN(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.IndexOf(value: TFhirConditionEvidence): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionEvidenceList.Insert(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionEvidenceList.InsertItem(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  Inherited Insert(index, value);
end;

function TFhirConditionEvidenceList.Item(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.Link: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Link);
end;

procedure TFhirConditionEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionEvidenceList.SetItemByIndex(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  FhirConditionEvidences[index] := value;
end;

procedure TFhirConditionEvidenceList.SetItemN(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionLocation }

constructor TFhirConditionLocation.Create;
begin
  inherited;
end;

destructor TFhirConditionLocation.Destroy;
begin
  FCode.free;
  FDetail.free;
  inherited;
end;

procedure TFhirConditionLocation.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConditionLocation(oSource).code.Clone;
  detail := TFhirConditionLocation(oSource).detail.Clone;
end;

procedure TFhirConditionLocation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'detail') Then
     list.add(Detail.Link);
end;

procedure TFhirConditionLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'string', FDetail.Link.Link));{2}
end;

function TFhirConditionLocation.Link : TFhirConditionLocation;
begin
  result := TFhirConditionLocation(inherited Link);
end;

function TFhirConditionLocation.Clone : TFhirConditionLocation;
begin
  result := TFhirConditionLocation(inherited Clone);
end;

{ TFhirConditionLocation }

Procedure TFhirConditionLocation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConditionLocation.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirConditionLocation.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := Detail.value;
end;

Procedure TFhirConditionLocation.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;


{ TFhirConditionLocationList }
procedure TFhirConditionLocationList.AddItem(value: TFhirConditionLocation);
begin
  assert(value.ClassName = 'TFhirConditionLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionLocation');
  add(value);
end;


function TFhirConditionLocationList.Append: TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionLocationList.ClearItems;
begin
  Clear;
end;

function TFhirConditionLocationList.Clone: TFhirConditionLocationList;
begin
  result := TFhirConditionLocationList(inherited Clone);
end;

function TFhirConditionLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionLocationList.GetItemN(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation(ObjectByIndex[index]);
end;

function TFhirConditionLocationList.IndexOf(value: TFhirConditionLocation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionLocationList.Insert(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionLocationList.InsertItem(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  Inherited Insert(index, value);
end;

function TFhirConditionLocationList.Item(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation(ObjectByIndex[index]);
end;

function TFhirConditionLocationList.Link: TFhirConditionLocationList;
begin
  result := TFhirConditionLocationList(inherited Link);
end;

procedure TFhirConditionLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionLocationList.SetItemByIndex(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  FhirConditionLocations[index] := value;
end;

procedure TFhirConditionLocationList.SetItemN(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionRelatedItem }

constructor TFhirConditionRelatedItem.Create;
begin
  inherited;
end;

destructor TFhirConditionRelatedItem.Destroy;
begin
  FType_.free;
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirConditionRelatedItem.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirConditionRelatedItem(oSource).FType_.Link;
  code := TFhirConditionRelatedItem(oSource).code.Clone;
  target := TFhirConditionRelatedItem(oSource).target.Clone;
end;

procedure TFhirConditionRelatedItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
end;

procedure TFhirConditionRelatedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Condition|Procedure|Substance)', FTarget.Link.Link));{2}
end;

function TFhirConditionRelatedItem.Link : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(inherited Link);
end;

function TFhirConditionRelatedItem.Clone : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(inherited Clone);
end;

{ TFhirConditionRelatedItem }

Procedure TFhirConditionRelatedItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConditionRelatedItem.GetType_ST : TFhirConditionRelationshipType;
begin
  if FType_ = nil then
    result := TFhirConditionRelationshipType(0)
  else
    result := TFhirConditionRelationshipType(StringArrayIndexOf(CODES_TFhirConditionRelationshipType, Type_.value));
end;

Procedure TFhirConditionRelatedItem.SetType_ST(value : TFhirConditionRelationshipType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirConditionRelationshipType[value]);
end;

Procedure TFhirConditionRelatedItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConditionRelatedItem.SetTarget(value : TFhirResourceReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirConditionRelatedItemList }
procedure TFhirConditionRelatedItemList.AddItem(value: TFhirConditionRelatedItem);
begin
  assert(value.ClassName = 'TFhirConditionRelatedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionRelatedItem');
  add(value);
end;


function TFhirConditionRelatedItemList.Append: TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionRelatedItemList.ClearItems;
begin
  Clear;
end;

function TFhirConditionRelatedItemList.Clone: TFhirConditionRelatedItemList;
begin
  result := TFhirConditionRelatedItemList(inherited Clone);
end;

function TFhirConditionRelatedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionRelatedItemList.GetItemN(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(ObjectByIndex[index]);
end;

function TFhirConditionRelatedItemList.IndexOf(value: TFhirConditionRelatedItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionRelatedItemList.Insert(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionRelatedItemList.InsertItem(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  Inherited Insert(index, value);
end;

function TFhirConditionRelatedItemList.Item(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(ObjectByIndex[index]);
end;

function TFhirConditionRelatedItemList.Link: TFhirConditionRelatedItemList;
begin
  result := TFhirConditionRelatedItemList(inherited Link);
end;

procedure TFhirConditionRelatedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionRelatedItemList.SetItemByIndex(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  FhirConditionRelatedItems[index] := value;
end;

procedure TFhirConditionRelatedItemList.SetItemN(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceSoftware }

constructor TFhirConformanceSoftware.Create;
begin
  inherited;
end;

destructor TFhirConformanceSoftware.Destroy;
begin
  FName.free;
  FVersion.free;
  FReleaseDate.free;
  inherited;
end;

procedure TFhirConformanceSoftware.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirConformanceSoftware(oSource).name.Clone;
  version := TFhirConformanceSoftware(oSource).version.Clone;
  releaseDate := TFhirConformanceSoftware(oSource).releaseDate.Clone;
end;

procedure TFhirConformanceSoftware.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'version') Then
     list.add(Version.Link);
  if (child_name = 'releaseDate') Then
     list.add(ReleaseDate.Link);
end;

procedure TFhirConformanceSoftware.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'releaseDate', 'dateTime', FReleaseDate.Link.Link));{2}
end;

function TFhirConformanceSoftware.Link : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Link);
end;

function TFhirConformanceSoftware.Clone : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Clone);
end;

{ TFhirConformanceSoftware }

Procedure TFhirConformanceSoftware.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceSoftware.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirConformanceSoftware.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceSoftware.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirConformanceSoftware.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := Version.value;
end;

Procedure TFhirConformanceSoftware.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirConformanceSoftware.SetReleaseDate(value : TFhirDateTime);
begin
  FReleaseDate.free;
  FReleaseDate := value;
end;

Function TFhirConformanceSoftware.GetReleaseDateST : TDateAndTime;
begin
  if FReleaseDate = nil then
    result := nil
  else
    result := ReleaseDate.value;
end;

Procedure TFhirConformanceSoftware.SetReleaseDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FReleaseDate = nil then
      FReleaseDate := TFhirDateTime.create;
    FReleaseDate.value := value
  end
  else if FReleaseDate <> nil then
    FReleaseDate.value := nil;
end;


{ TFhirConformanceSoftwareList }
procedure TFhirConformanceSoftwareList.AddItem(value: TFhirConformanceSoftware);
begin
  assert(value.ClassName = 'TFhirConformanceSoftware', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceSoftware');
  add(value);
end;


function TFhirConformanceSoftwareList.Append: TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceSoftwareList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceSoftwareList.Clone: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Clone);
end;

function TFhirConformanceSoftwareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceSoftwareList.GetItemN(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.IndexOf(value: TFhirConformanceSoftware): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceSoftwareList.Insert(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceSoftwareList.InsertItem(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  Inherited Insert(index, value);
end;

function TFhirConformanceSoftwareList.Item(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.Link: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Link);
end;

procedure TFhirConformanceSoftwareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceSoftwareList.SetItemByIndex(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  FhirConformanceSoftwares[index] := value;
end;

procedure TFhirConformanceSoftwareList.SetItemN(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceImplementation }

constructor TFhirConformanceImplementation.Create;
begin
  inherited;
end;

destructor TFhirConformanceImplementation.Destroy;
begin
  FDescription.free;
  FUrl.free;
  inherited;
end;

procedure TFhirConformanceImplementation.Assign(oSource : TAdvObject);
begin
  inherited;
  description := TFhirConformanceImplementation(oSource).description.Clone;
  url := TFhirConformanceImplementation(oSource).url.Clone;
end;

procedure TFhirConformanceImplementation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'url') Then
     list.add(Url.Link);
end;

procedure TFhirConformanceImplementation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link.Link));{2}
end;

function TFhirConformanceImplementation.Link : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Link);
end;

function TFhirConformanceImplementation.Clone : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Clone);
end;

{ TFhirConformanceImplementation }

Procedure TFhirConformanceImplementation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceImplementation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirConformanceImplementation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirConformanceImplementation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirConformanceImplementation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := Url.value;
end;

Procedure TFhirConformanceImplementation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;


{ TFhirConformanceImplementationList }
procedure TFhirConformanceImplementationList.AddItem(value: TFhirConformanceImplementation);
begin
  assert(value.ClassName = 'TFhirConformanceImplementation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceImplementation');
  add(value);
end;


function TFhirConformanceImplementationList.Append: TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceImplementationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceImplementationList.Clone: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Clone);
end;

function TFhirConformanceImplementationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceImplementationList.GetItemN(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.IndexOf(value: TFhirConformanceImplementation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceImplementationList.Insert(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceImplementationList.InsertItem(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  Inherited Insert(index, value);
end;

function TFhirConformanceImplementationList.Item(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.Link: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Link);
end;

procedure TFhirConformanceImplementationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceImplementationList.SetItemByIndex(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  FhirConformanceImplementations[index] := value;
end;

procedure TFhirConformanceImplementationList.SetItemN(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRest }

constructor TFhirConformanceRest.Create;
begin
  inherited;
  FResourceList := TFhirConformanceRestResourceList.Create;
  FQueryList := TFhirConformanceRestQueryList.Create;
end;

destructor TFhirConformanceRest.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FSecurity.free;
  FResourceList.Free;
  FBatch.free;
  FHistory.free;
  FQueryList.Free;
  inherited;
end;

procedure TFhirConformanceRest.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode := TFhirConformanceRest(oSource).FMode.Link;
  documentation := TFhirConformanceRest(oSource).documentation.Clone;
  security := TFhirConformanceRest(oSource).security.Clone;
  FResourceList.Assign(TFhirConformanceRest(oSource).FResourceList);
  batch := TFhirConformanceRest(oSource).batch.Clone;
  history := TFhirConformanceRest(oSource).history.Clone;
  FQueryList.Assign(TFhirConformanceRest(oSource).FQueryList);
end;

procedure TFhirConformanceRest.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'security') Then
     list.add(Security.Link);
  if (child_name = 'resource') Then
     list.addAll(FResourceList);
  if (child_name = 'batch') Then
     list.add(Batch.Link);
  if (child_name = 'history') Then
     list.add(History.Link);
  if (child_name = 'query') Then
     list.addAll(FQueryList);
end;

procedure TFhirConformanceRest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'security', '', FSecurity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', FResourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'batch', 'boolean', FBatch.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'history', 'boolean', FHistory.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'query', '', FQueryList.Link)){3};
end;

function TFhirConformanceRest.Link : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Link);
end;

function TFhirConformanceRest.Clone : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Clone);
end;

{ TFhirConformanceRest }

Procedure TFhirConformanceRest.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceRest.GetModeST : TFhirRestfulConformanceMode;
begin
  if FMode = nil then
    result := TFhirRestfulConformanceMode(0)
  else
    result := TFhirRestfulConformanceMode(StringArrayIndexOf(CODES_TFhirRestfulConformanceMode, Mode.value));
end;

Procedure TFhirConformanceRest.SetModeST(value : TFhirRestfulConformanceMode);
begin
  if ord(value) = 0 then
    Mode := nil
  else
    Mode := TFhirEnum.create(CODES_TFhirRestfulConformanceMode[value]);
end;

Procedure TFhirConformanceRest.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRest.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRest.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceRest.SetSecurity(value : TFhirConformanceRestSecurity);
begin
  FSecurity.free;
  FSecurity := value;
end;

Procedure TFhirConformanceRest.SetBatch(value : TFhirBoolean);
begin
  FBatch.free;
  FBatch := value;
end;

Function TFhirConformanceRest.GetBatchST : String;
begin
  if FBatch = nil then
    result := ''
  else
    result := Batch.value;
end;

Procedure TFhirConformanceRest.SetBatchST(value : String);
begin
  if value <> '' then
  begin
    if FBatch = nil then
      FBatch := TFhirBoolean.create;
    FBatch.value := value
  end
  else if FBatch <> nil then
    FBatch.value := '';
end;

Procedure TFhirConformanceRest.SetHistory(value : TFhirBoolean);
begin
  FHistory.free;
  FHistory := value;
end;

Function TFhirConformanceRest.GetHistoryST : String;
begin
  if FHistory = nil then
    result := ''
  else
    result := History.value;
end;

Procedure TFhirConformanceRest.SetHistoryST(value : String);
begin
  if value <> '' then
  begin
    if FHistory = nil then
      FHistory := TFhirBoolean.create;
    FHistory.value := value
  end
  else if FHistory <> nil then
    FHistory.value := '';
end;


{ TFhirConformanceRestList }
procedure TFhirConformanceRestList.AddItem(value: TFhirConformanceRest);
begin
  assert(value.ClassName = 'TFhirConformanceRest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRest');
  add(value);
end;


function TFhirConformanceRestList.Append: TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestList.Clone: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Clone);
end;

function TFhirConformanceRestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestList.GetItemN(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.IndexOf(value: TFhirConformanceRest): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestList.Insert(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestList.InsertItem(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestList.Item(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.Link: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Link);
end;

procedure TFhirConformanceRestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestList.SetItemByIndex(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  FhirConformanceRests[index] := value;
end;

procedure TFhirConformanceRestList.SetItemN(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurity }

constructor TFhirConformanceRestSecurity.Create;
begin
  inherited;
  FServiceList := TFhirCodeableConceptList.Create;
  FCertificateList := TFhirConformanceRestSecurityCertificateList.Create;
end;

destructor TFhirConformanceRestSecurity.Destroy;
begin
  FServiceList.Free;
  FDescription.free;
  FCertificateList.Free;
  inherited;
end;

procedure TFhirConformanceRestSecurity.Assign(oSource : TAdvObject);
begin
  inherited;
  FServiceList.Assign(TFhirConformanceRestSecurity(oSource).FServiceList);
  description := TFhirConformanceRestSecurity(oSource).description.Clone;
  FCertificateList.Assign(TFhirConformanceRestSecurity(oSource).FCertificateList);
end;

procedure TFhirConformanceRestSecurity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'service') Then
     list.addAll(FServiceList);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'certificate') Then
     list.addAll(FCertificateList);
end;

procedure TFhirConformanceRestSecurity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', FServiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'certificate', '', FCertificateList.Link)){3};
end;

function TFhirConformanceRestSecurity.Link : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Link);
end;

function TFhirConformanceRestSecurity.Clone : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Clone);
end;

{ TFhirConformanceRestSecurity }

Procedure TFhirConformanceRestSecurity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceRestSecurity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirConformanceRestSecurity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;


{ TFhirConformanceRestSecurityList }
procedure TFhirConformanceRestSecurityList.AddItem(value: TFhirConformanceRestSecurity);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurity');
  add(value);
end;


function TFhirConformanceRestSecurityList.Append: TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityList.Clone: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Clone);
end;

function TFhirConformanceRestSecurityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityList.GetItemN(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.IndexOf(value: TFhirConformanceRestSecurity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestSecurityList.Insert(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityList.InsertItem(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityList.Item(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.Link: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Link);
end;

procedure TFhirConformanceRestSecurityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  FhirConformanceRestSecurities[index] := value;
end;

procedure TFhirConformanceRestSecurityList.SetItemN(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurityCertificate }

constructor TFhirConformanceRestSecurityCertificate.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestSecurityCertificate.Destroy;
begin
  FType_.free;
  FBlob.free;
  inherited;
end;

procedure TFhirConformanceRestSecurityCertificate.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirConformanceRestSecurityCertificate(oSource).type_.Clone;
  blob := TFhirConformanceRestSecurityCertificate(oSource).blob.Clone;
end;

procedure TFhirConformanceRestSecurityCertificate.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'blob') Then
     list.add(Blob.Link);
end;

procedure TFhirConformanceRestSecurityCertificate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'blob', 'base64Binary', FBlob.Link.Link));{2}
end;

function TFhirConformanceRestSecurityCertificate.Link : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Link);
end;

function TFhirConformanceRestSecurityCertificate.Clone : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Clone);
end;

{ TFhirConformanceRestSecurityCertificate }

Procedure TFhirConformanceRestSecurityCertificate.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlob(value : TFhirBase64Binary);
begin
  FBlob.free;
  FBlob := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetBlobST : String;
begin
  if FBlob = nil then
    result := ''
  else
    result := Blob.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlobST(value : String);
begin
  if value <> '' then
  begin
    if FBlob = nil then
      FBlob := TFhirBase64Binary.create;
    FBlob.value := value
  end
  else if FBlob <> nil then
    FBlob.value := '';
end;


{ TFhirConformanceRestSecurityCertificateList }
procedure TFhirConformanceRestSecurityCertificateList.AddItem(value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurityCertificate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurityCertificate');
  add(value);
end;


function TFhirConformanceRestSecurityCertificateList.Append: TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityCertificateList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityCertificateList.Clone: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Clone);
end;

function TFhirConformanceRestSecurityCertificateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityCertificateList.GetItemN(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.IndexOf(value: TFhirConformanceRestSecurityCertificate): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestSecurityCertificateList.Insert(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityCertificateList.InsertItem(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityCertificateList.Item(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.Link: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Link);
end;

procedure TFhirConformanceRestSecurityCertificateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  FhirConformanceRestSecurityCertificates[index] := value;
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemN(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResource }

constructor TFhirConformanceRestResource.Create;
begin
  inherited;
  FOperationList := TFhirConformanceRestResourceOperationList.Create;
  FSearchIncludeList := TFhirStringList.Create;
  FSearchParamList := TFhirConformanceRestResourceSearchParamList.Create;
end;

destructor TFhirConformanceRestResource.Destroy;
begin
  FType_.free;
  FProfile.free;
  FOperationList.Free;
  FReadHistory.free;
  FSearchIncludeList.Free;
  FSearchParamList.Free;
  inherited;
end;

procedure TFhirConformanceRestResource.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirConformanceRestResource(oSource).type_.Clone;
  profile := TFhirConformanceRestResource(oSource).profile.Clone;
  FOperationList.Assign(TFhirConformanceRestResource(oSource).FOperationList);
  readHistory := TFhirConformanceRestResource(oSource).readHistory.Clone;
  FSearchIncludeList.Assign(TFhirConformanceRestResource(oSource).FSearchIncludeList);
  FSearchParamList.Assign(TFhirConformanceRestResource(oSource).FSearchParamList);
end;

procedure TFhirConformanceRestResource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'profile') Then
     list.add(Profile.Link);
  if (child_name = 'operation') Then
     list.addAll(FOperationList);
  if (child_name = 'readHistory') Then
     list.add(ReadHistory.Link);
  if (child_name = 'searchInclude') Then
     list.addAll(FSearchIncludeList);
  if (child_name = 'searchParam') Then
     list.addAll(FSearchParamList);
end;

procedure TFhirConformanceRestResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Resource(Profile)', FProfile.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operation', '', FOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'readHistory', 'boolean', FReadHistory.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'searchInclude', 'string', FSearchIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '', FSearchParamList.Link)){3};
end;

function TFhirConformanceRestResource.Link : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Link);
end;

function TFhirConformanceRestResource.Clone : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Clone);
end;

{ TFhirConformanceRestResource }

Procedure TFhirConformanceRestResource.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResource.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirConformanceRestResource.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirConformanceRestResource.SetProfile(value : TFhirResourceReference{TFhirProfile});
begin
  FProfile.free;
  FProfile := value;
end;

Procedure TFhirConformanceRestResource.SetReadHistory(value : TFhirBoolean);
begin
  FReadHistory.free;
  FReadHistory := value;
end;

Function TFhirConformanceRestResource.GetReadHistoryST : String;
begin
  if FReadHistory = nil then
    result := ''
  else
    result := ReadHistory.value;
end;

Procedure TFhirConformanceRestResource.SetReadHistoryST(value : String);
begin
  if value <> '' then
  begin
    if FReadHistory = nil then
      FReadHistory := TFhirBoolean.create;
    FReadHistory.value := value
  end
  else if FReadHistory <> nil then
    FReadHistory.value := '';
end;


{ TFhirConformanceRestResourceList }
procedure TFhirConformanceRestResourceList.AddItem(value: TFhirConformanceRestResource);
begin
  assert(value.ClassName = 'TFhirConformanceRestResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResource');
  add(value);
end;


function TFhirConformanceRestResourceList.Append: TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceList.Clone: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Clone);
end;

function TFhirConformanceRestResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceList.GetItemN(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.IndexOf(value: TFhirConformanceRestResource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceList.Insert(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceList.InsertItem(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceList.Item(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.Link: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Link);
end;

procedure TFhirConformanceRestResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  FhirConformanceRestResources[index] := value;
end;

procedure TFhirConformanceRestResourceList.SetItemN(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceOperation }

constructor TFhirConformanceRestResourceOperation.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestResourceOperation.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceRestResourceOperation.Assign(oSource : TAdvObject);
begin
  inherited;
  FCode := TFhirConformanceRestResourceOperation(oSource).FCode.Link;
  documentation := TFhirConformanceRestResourceOperation(oSource).documentation.Clone;
end;

procedure TFhirConformanceRestResourceOperation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
end;

procedure TFhirConformanceRestResourceOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
end;

function TFhirConformanceRestResourceOperation.Link : TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(inherited Link);
end;

function TFhirConformanceRestResourceOperation.Clone : TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(inherited Clone);
end;

{ TFhirConformanceRestResourceOperation }

Procedure TFhirConformanceRestResourceOperation.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceRestResourceOperation.GetCodeST : TFhirRestfulOperation;
begin
  if FCode = nil then
    result := TFhirRestfulOperation(0)
  else
    result := TFhirRestfulOperation(StringArrayIndexOf(CODES_TFhirRestfulOperation, Code.value));
end;

Procedure TFhirConformanceRestResourceOperation.SetCodeST(value : TFhirRestfulOperation);
begin
  if ord(value) = 0 then
    Code := nil
  else
    Code := TFhirEnum.create(CODES_TFhirRestfulOperation[value]);
end;

Procedure TFhirConformanceRestResourceOperation.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceOperation.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRestResourceOperation.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestResourceOperationList }
procedure TFhirConformanceRestResourceOperationList.AddItem(value: TFhirConformanceRestResourceOperation);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceOperation');
  add(value);
end;


function TFhirConformanceRestResourceOperationList.Append: TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceOperationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceOperationList.Clone: TFhirConformanceRestResourceOperationList;
begin
  result := TFhirConformanceRestResourceOperationList(inherited Clone);
end;

function TFhirConformanceRestResourceOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceOperationList.GetItemN(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceOperationList.IndexOf(value: TFhirConformanceRestResourceOperation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceOperationList.Insert(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceOperationList.InsertItem(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceOperationList.Item(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceOperationList.Link: TFhirConformanceRestResourceOperationList;
begin
  result := TFhirConformanceRestResourceOperationList(inherited Link);
end;

procedure TFhirConformanceRestResourceOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceOperationList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  FhirConformanceRestResourceOperations[index] := value;
end;

procedure TFhirConformanceRestResourceOperationList.SetItemN(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceSearchParam }

constructor TFhirConformanceRestResourceSearchParam.Create;
begin
  inherited;
  FTargetList := TFhirCodeList.Create;
  FChainList := TFhirStringList.Create;
end;

destructor TFhirConformanceRestResourceSearchParam.Destroy;
begin
  FName.free;
  FSource.free;
  FType_.free;
  FDocumentation.free;
  FXpath.free;
  FTargetList.Free;
  FChainList.Free;
  inherited;
end;

procedure TFhirConformanceRestResourceSearchParam.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirConformanceRestResourceSearchParam(oSource).name.Clone;
  source := TFhirConformanceRestResourceSearchParam(oSource).source.Clone;
  FType_ := TFhirConformanceRestResourceSearchParam(oSource).FType_.Link;
  documentation := TFhirConformanceRestResourceSearchParam(oSource).documentation.Clone;
  xpath := TFhirConformanceRestResourceSearchParam(oSource).xpath.Clone;
  FTargetList.Assign(TFhirConformanceRestResourceSearchParam(oSource).FTargetList);
  FChainList.Assign(TFhirConformanceRestResourceSearchParam(oSource).FChainList);
end;

procedure TFhirConformanceRestResourceSearchParam.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'source') Then
     list.add(Source.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'xpath') Then
     list.add(Xpath.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
  if (child_name = 'chain') Then
     list.addAll(FChainList);
end;

procedure TFhirConformanceRestResourceSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'uri', FSource.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', FXpath.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'code', FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'chain', 'string', FChainList.Link)){3};
end;

function TFhirConformanceRestResourceSearchParam.Link : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Link);
end;

function TFhirConformanceRestResourceSearchParam.Clone : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Clone);
end;

{ TFhirConformanceRestResourceSearchParam }

Procedure TFhirConformanceRestResourceSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := Source.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetType_ST : TFhirSearchParamType;
begin
  if FType_ = nil then
    result := TFhirSearchParamType(0)
  else
    result := TFhirSearchParamType(StringArrayIndexOf(CODES_TFhirSearchParamType, Type_.value));
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_ST(value : TFhirSearchParamType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirSearchParamType[value]);
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := Xpath.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;


{ TFhirConformanceRestResourceSearchParamList }
procedure TFhirConformanceRestResourceSearchParamList.AddItem(value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceSearchParam');
  add(value);
end;


function TFhirConformanceRestResourceSearchParamList.Append: TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceSearchParamList.Clone: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Clone);
end;

function TFhirConformanceRestResourceSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceSearchParamList.GetItemN(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.IndexOf(value: TFhirConformanceRestResourceSearchParam): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceSearchParamList.Insert(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceSearchParamList.InsertItem(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceSearchParamList.Item(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.Link: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Link);
end;

procedure TFhirConformanceRestResourceSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  FhirConformanceRestResourceSearchParams[index] := value;
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemN(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestQuery }

constructor TFhirConformanceRestQuery.Create;
begin
  inherited;
  FParameterList := TFhirConformanceRestResourceSearchParamList.Create;
end;

destructor TFhirConformanceRestQuery.Destroy;
begin
  FName.free;
  FDocumentation.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirConformanceRestQuery.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirConformanceRestQuery(oSource).name.Clone;
  documentation := TFhirConformanceRestQuery(oSource).documentation.Clone;
  FParameterList.Assign(TFhirConformanceRestQuery(oSource).FParameterList);
end;

procedure TFhirConformanceRestQuery.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirConformanceRestQuery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '@Conformance.rest.resource.searchParam', FParameterList.Link)){3};
end;

function TFhirConformanceRestQuery.Link : TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(inherited Link);
end;

function TFhirConformanceRestQuery.Clone : TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(inherited Clone);
end;

{ TFhirConformanceRestQuery }

Procedure TFhirConformanceRestQuery.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestQuery.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirConformanceRestQuery.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestQuery.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestQuery.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRestQuery.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestQueryList }
procedure TFhirConformanceRestQueryList.AddItem(value: TFhirConformanceRestQuery);
begin
  assert(value.ClassName = 'TFhirConformanceRestQuery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestQuery');
  add(value);
end;


function TFhirConformanceRestQueryList.Append: TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestQueryList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestQueryList.Clone: TFhirConformanceRestQueryList;
begin
  result := TFhirConformanceRestQueryList(inherited Clone);
end;

function TFhirConformanceRestQueryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestQueryList.GetItemN(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(ObjectByIndex[index]);
end;

function TFhirConformanceRestQueryList.IndexOf(value: TFhirConformanceRestQuery): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestQueryList.Insert(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestQueryList.InsertItem(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestQueryList.Item(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(ObjectByIndex[index]);
end;

function TFhirConformanceRestQueryList.Link: TFhirConformanceRestQueryList;
begin
  result := TFhirConformanceRestQueryList(inherited Link);
end;

procedure TFhirConformanceRestQueryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestQueryList.SetItemByIndex(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  FhirConformanceRestQueries[index] := value;
end;

procedure TFhirConformanceRestQueryList.SetItemN(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessaging }

constructor TFhirConformanceMessaging.Create;
begin
  inherited;
  FEventList := TFhirConformanceMessagingEventList.Create;
end;

destructor TFhirConformanceMessaging.Destroy;
begin
  FEndpoint.free;
  FReliableCache.free;
  FDocumentation.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirConformanceMessaging.Assign(oSource : TAdvObject);
begin
  inherited;
  endpoint := TFhirConformanceMessaging(oSource).endpoint.Clone;
  reliableCache := TFhirConformanceMessaging(oSource).reliableCache.Clone;
  documentation := TFhirConformanceMessaging(oSource).documentation.Clone;
  FEventList.Assign(TFhirConformanceMessaging(oSource).FEventList);
end;

procedure TFhirConformanceMessaging.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'endpoint') Then
     list.add(Endpoint.Link);
  if (child_name = 'reliableCache') Then
     list.add(ReliableCache.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'event') Then
     list.addAll(FEventList);
end;

procedure TFhirConformanceMessaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reliableCache', 'integer', FReliableCache.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', '', FEventList.Link)){3};
end;

function TFhirConformanceMessaging.Link : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Link);
end;

function TFhirConformanceMessaging.Clone : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Clone);
end;

{ TFhirConformanceMessaging }

Procedure TFhirConformanceMessaging.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirConformanceMessaging.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := Endpoint.value;
end;

Procedure TFhirConformanceMessaging.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

Procedure TFhirConformanceMessaging.SetReliableCache(value : TFhirInteger);
begin
  FReliableCache.free;
  FReliableCache := value;
end;

Function TFhirConformanceMessaging.GetReliableCacheST : String;
begin
  if FReliableCache = nil then
    result := ''
  else
    result := ReliableCache.value;
end;

Procedure TFhirConformanceMessaging.SetReliableCacheST(value : String);
begin
  if value <> '' then
  begin
    if FReliableCache = nil then
      FReliableCache := TFhirInteger.create;
    FReliableCache.value := value
  end
  else if FReliableCache <> nil then
    FReliableCache.value := '';
end;

Procedure TFhirConformanceMessaging.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessaging.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceMessaging.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceMessagingList }
procedure TFhirConformanceMessagingList.AddItem(value: TFhirConformanceMessaging);
begin
  assert(value.ClassName = 'TFhirConformanceMessaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessaging');
  add(value);
end;


function TFhirConformanceMessagingList.Append: TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingList.Clone: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Clone);
end;

function TFhirConformanceMessagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingList.GetItemN(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.IndexOf(value: TFhirConformanceMessaging): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceMessagingList.Insert(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingList.InsertItem(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingList.Item(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.Link: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Link);
end;

procedure TFhirConformanceMessagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingList.SetItemByIndex(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  FhirConformanceMessagings[index] := value;
end;

procedure TFhirConformanceMessagingList.SetItemN(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessagingEvent }

constructor TFhirConformanceMessagingEvent.Create;
begin
  inherited;
  FProtocolList := TFhirCodingList.Create;
end;

destructor TFhirConformanceMessagingEvent.Destroy;
begin
  FCode.free;
  FMode.free;
  FProtocolList.Free;
  FFocus.free;
  FRequest.free;
  FResponse.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceMessagingEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConformanceMessagingEvent(oSource).code.Clone;
  FMode := TFhirConformanceMessagingEvent(oSource).FMode.Link;
  FProtocolList.Assign(TFhirConformanceMessagingEvent(oSource).FProtocolList);
  focus := TFhirConformanceMessagingEvent(oSource).focus.Clone;
  request := TFhirConformanceMessagingEvent(oSource).request.Clone;
  response := TFhirConformanceMessagingEvent(oSource).response.Clone;
  documentation := TFhirConformanceMessagingEvent(oSource).documentation.Clone;
end;

procedure TFhirConformanceMessagingEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'protocol') Then
     list.addAll(FProtocolList);
  if (child_name = 'focus') Then
     list.add(Focus.Link);
  if (child_name = 'request') Then
     list.add(Request.Link);
  if (child_name = 'response') Then
     list.add(Response.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
end;

procedure TFhirConformanceMessagingEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'protocol', 'Coding', FProtocolList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'focus', 'code', FFocus.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Resource(Profile)', FRequest.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Resource(Profile)', FResponse.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
end;

function TFhirConformanceMessagingEvent.Link : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Link);
end;

function TFhirConformanceMessagingEvent.Clone : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Clone);
end;

{ TFhirConformanceMessagingEvent }

Procedure TFhirConformanceMessagingEvent.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceMessagingEvent.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirConformanceMessagingEvent.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConformanceMessagingEvent.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceMessagingEvent.GetModeST : TFhirMessageConformanceEventMode;
begin
  if FMode = nil then
    result := TFhirMessageConformanceEventMode(0)
  else
    result := TFhirMessageConformanceEventMode(StringArrayIndexOf(CODES_TFhirMessageConformanceEventMode, Mode.value));
end;

Procedure TFhirConformanceMessagingEvent.SetModeST(value : TFhirMessageConformanceEventMode);
begin
  if ord(value) = 0 then
    Mode := nil
  else
    Mode := TFhirEnum.create(CODES_TFhirMessageConformanceEventMode[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetFocus(value : TFhirCode);
begin
  FFocus.free;
  FFocus := value;
end;

Function TFhirConformanceMessagingEvent.GetFocusST : String;
begin
  if FFocus = nil then
    result := ''
  else
    result := Focus.value;
end;

Procedure TFhirConformanceMessagingEvent.SetFocusST(value : String);
begin
  if value <> '' then
  begin
    if FFocus = nil then
      FFocus := TFhirCode.create;
    FFocus.value := value
  end
  else if FFocus <> nil then
    FFocus.value := '';
end;

Procedure TFhirConformanceMessagingEvent.SetRequest(value : TFhirResourceReference{TFhirProfile});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirConformanceMessagingEvent.SetResponse(value : TFhirResourceReference{TFhirProfile});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessagingEvent.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceMessagingEventList }
procedure TFhirConformanceMessagingEventList.AddItem(value: TFhirConformanceMessagingEvent);
begin
  assert(value.ClassName = 'TFhirConformanceMessagingEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessagingEvent');
  add(value);
end;


function TFhirConformanceMessagingEventList.Append: TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingEventList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingEventList.Clone: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Clone);
end;

function TFhirConformanceMessagingEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingEventList.GetItemN(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.IndexOf(value: TFhirConformanceMessagingEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceMessagingEventList.Insert(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingEventList.InsertItem(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingEventList.Item(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.Link: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Link);
end;

procedure TFhirConformanceMessagingEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingEventList.SetItemByIndex(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  FhirConformanceMessagingEvents[index] := value;
end;

procedure TFhirConformanceMessagingEventList.SetItemN(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceDocument }

constructor TFhirConformanceDocument.Create;
begin
  inherited;
end;

destructor TFhirConformanceDocument.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FProfile.free;
  inherited;
end;

procedure TFhirConformanceDocument.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode := TFhirConformanceDocument(oSource).FMode.Link;
  documentation := TFhirConformanceDocument(oSource).documentation.Clone;
  profile := TFhirConformanceDocument(oSource).profile.Clone;
end;

procedure TFhirConformanceDocument.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'profile') Then
     list.add(Profile.Link);
end;

procedure TFhirConformanceDocument.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Resource(Profile)', FProfile.Link.Link));{2}
end;

function TFhirConformanceDocument.Link : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Link);
end;

function TFhirConformanceDocument.Clone : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Clone);
end;

{ TFhirConformanceDocument }

Procedure TFhirConformanceDocument.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceDocument.GetModeST : TFhirDocumentMode;
begin
  if FMode = nil then
    result := TFhirDocumentMode(0)
  else
    result := TFhirDocumentMode(StringArrayIndexOf(CODES_TFhirDocumentMode, Mode.value));
end;

Procedure TFhirConformanceDocument.SetModeST(value : TFhirDocumentMode);
begin
  if ord(value) = 0 then
    Mode := nil
  else
    Mode := TFhirEnum.create(CODES_TFhirDocumentMode[value]);
end;

Procedure TFhirConformanceDocument.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceDocument.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceDocument.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceDocument.SetProfile(value : TFhirResourceReference{TFhirProfile});
begin
  FProfile.free;
  FProfile := value;
end;


{ TFhirConformanceDocumentList }
procedure TFhirConformanceDocumentList.AddItem(value: TFhirConformanceDocument);
begin
  assert(value.ClassName = 'TFhirConformanceDocument', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceDocument');
  add(value);
end;


function TFhirConformanceDocumentList.Append: TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceDocumentList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceDocumentList.Clone: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Clone);
end;

function TFhirConformanceDocumentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceDocumentList.GetItemN(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.IndexOf(value: TFhirConformanceDocument): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceDocumentList.Insert(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceDocumentList.InsertItem(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  Inherited Insert(index, value);
end;

function TFhirConformanceDocumentList.Item(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.Link: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Link);
end;

procedure TFhirConformanceDocumentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceDocumentList.SetItemByIndex(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  FhirConformanceDocuments[index] := value;
end;

procedure TFhirConformanceDocumentList.SetItemN(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageSubscriber }

constructor TFhirCoverageSubscriber.Create;
begin
  inherited;
end;

destructor TFhirCoverageSubscriber.Destroy;
begin
  FName.free;
  FAddress.free;
  FBirthdate.free;
  inherited;
end;

procedure TFhirCoverageSubscriber.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirCoverageSubscriber(oSource).name.Clone;
  address := TFhirCoverageSubscriber(oSource).address.Clone;
  birthdate := TFhirCoverageSubscriber(oSource).birthdate.Clone;
end;

procedure TFhirCoverageSubscriber.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'address') Then
     list.add(Address.Link);
  if (child_name = 'birthdate') Then
     list.add(Birthdate.Link);
end;

procedure TFhirCoverageSubscriber.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'address', 'Address', FAddress.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'birthdate', 'date', FBirthdate.Link.Link));{2}
end;

function TFhirCoverageSubscriber.Link : TFhirCoverageSubscriber;
begin
  result := TFhirCoverageSubscriber(inherited Link);
end;

function TFhirCoverageSubscriber.Clone : TFhirCoverageSubscriber;
begin
  result := TFhirCoverageSubscriber(inherited Clone);
end;

{ TFhirCoverageSubscriber }

Procedure TFhirCoverageSubscriber.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirCoverageSubscriber.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirCoverageSubscriber.SetBirthdate(value : TFhirDate);
begin
  FBirthdate.free;
  FBirthdate := value;
end;

Function TFhirCoverageSubscriber.GetBirthdateST : TDateAndTime;
begin
  if FBirthdate = nil then
    result := nil
  else
    result := Birthdate.value;
end;

Procedure TFhirCoverageSubscriber.SetBirthdateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FBirthdate = nil then
      FBirthdate := TFhirDate.create;
    FBirthdate.value := value
  end
  else if FBirthdate <> nil then
    FBirthdate.value := nil;
end;


{ TFhirCoverageSubscriberList }
procedure TFhirCoverageSubscriberList.AddItem(value: TFhirCoverageSubscriber);
begin
  assert(value.ClassName = 'TFhirCoverageSubscriber', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageSubscriber');
  add(value);
end;


function TFhirCoverageSubscriberList.Append: TFhirCoverageSubscriber;
begin
  result := TFhirCoverageSubscriber.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCoverageSubscriberList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageSubscriberList.Clone: TFhirCoverageSubscriberList;
begin
  result := TFhirCoverageSubscriberList(inherited Clone);
end;

function TFhirCoverageSubscriberList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageSubscriberList.GetItemN(index: Integer): TFhirCoverageSubscriber;
begin
  result := TFhirCoverageSubscriber(ObjectByIndex[index]);
end;

function TFhirCoverageSubscriberList.IndexOf(value: TFhirCoverageSubscriber): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCoverageSubscriberList.Insert(index: Integer): TFhirCoverageSubscriber;
begin
  result := TFhirCoverageSubscriber.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCoverageSubscriberList.InsertItem(index: Integer; value: TFhirCoverageSubscriber);
begin
  assert(value is TFhirCoverageSubscriber);
  Inherited Insert(index, value);
end;

function TFhirCoverageSubscriberList.Item(index: Integer): TFhirCoverageSubscriber;
begin
  result := TFhirCoverageSubscriber(ObjectByIndex[index]);
end;

function TFhirCoverageSubscriberList.Link: TFhirCoverageSubscriberList;
begin
  result := TFhirCoverageSubscriberList(inherited Link);
end;

procedure TFhirCoverageSubscriberList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageSubscriberList.SetItemByIndex(index: Integer; value: TFhirCoverageSubscriber);
begin
  assert(value is TFhirCoverageSubscriber);
  FhirCoverageSubscribers[index] := value;
end;

procedure TFhirCoverageSubscriberList.SetItemN(index: Integer; value: TFhirCoverageSubscriber);
begin
  assert(value is TFhirCoverageSubscriber);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceIdentity }

constructor TFhirDeviceIdentity.Create;
begin
  inherited;
end;

destructor TFhirDeviceIdentity.Destroy;
begin
  FGtin.free;
  FLot.free;
  FSerialNumber.free;
  inherited;
end;

procedure TFhirDeviceIdentity.Assign(oSource : TAdvObject);
begin
  inherited;
  gtin := TFhirDeviceIdentity(oSource).gtin.Clone;
  lot := TFhirDeviceIdentity(oSource).lot.Clone;
  serialNumber := TFhirDeviceIdentity(oSource).serialNumber.Clone;
end;

procedure TFhirDeviceIdentity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'gtin') Then
     list.add(Gtin.Link);
  if (child_name = 'lot') Then
     list.add(Lot.Link);
  if (child_name = 'serialNumber') Then
     list.add(SerialNumber.Link);
end;

procedure TFhirDeviceIdentity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'gtin', 'string', FGtin.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lot', 'string', FLot.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'serialNumber', 'string', FSerialNumber.Link.Link));{2}
end;

function TFhirDeviceIdentity.Link : TFhirDeviceIdentity;
begin
  result := TFhirDeviceIdentity(inherited Link);
end;

function TFhirDeviceIdentity.Clone : TFhirDeviceIdentity;
begin
  result := TFhirDeviceIdentity(inherited Clone);
end;

{ TFhirDeviceIdentity }

Procedure TFhirDeviceIdentity.SetGtin(value : TFhirString);
begin
  FGtin.free;
  FGtin := value;
end;

Function TFhirDeviceIdentity.GetGtinST : String;
begin
  if FGtin = nil then
    result := ''
  else
    result := Gtin.value;
end;

Procedure TFhirDeviceIdentity.SetGtinST(value : String);
begin
  if value <> '' then
  begin
    if FGtin = nil then
      FGtin := TFhirString.create;
    FGtin.value := value
  end
  else if FGtin <> nil then
    FGtin.value := '';
end;

Procedure TFhirDeviceIdentity.SetLot(value : TFhirString);
begin
  FLot.free;
  FLot := value;
end;

Function TFhirDeviceIdentity.GetLotST : String;
begin
  if FLot = nil then
    result := ''
  else
    result := Lot.value;
end;

Procedure TFhirDeviceIdentity.SetLotST(value : String);
begin
  if value <> '' then
  begin
    if FLot = nil then
      FLot := TFhirString.create;
    FLot.value := value
  end
  else if FLot <> nil then
    FLot.value := '';
end;

Procedure TFhirDeviceIdentity.SetSerialNumber(value : TFhirString);
begin
  FSerialNumber.free;
  FSerialNumber := value;
end;

Function TFhirDeviceIdentity.GetSerialNumberST : String;
begin
  if FSerialNumber = nil then
    result := ''
  else
    result := SerialNumber.value;
end;

Procedure TFhirDeviceIdentity.SetSerialNumberST(value : String);
begin
  if value <> '' then
  begin
    if FSerialNumber = nil then
      FSerialNumber := TFhirString.create;
    FSerialNumber.value := value
  end
  else if FSerialNumber <> nil then
    FSerialNumber.value := '';
end;


{ TFhirDeviceIdentityList }
procedure TFhirDeviceIdentityList.AddItem(value: TFhirDeviceIdentity);
begin
  assert(value.ClassName = 'TFhirDeviceIdentity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceIdentity');
  add(value);
end;


function TFhirDeviceIdentityList.Append: TFhirDeviceIdentity;
begin
  result := TFhirDeviceIdentity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceIdentityList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceIdentityList.Clone: TFhirDeviceIdentityList;
begin
  result := TFhirDeviceIdentityList(inherited Clone);
end;

function TFhirDeviceIdentityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceIdentityList.GetItemN(index: Integer): TFhirDeviceIdentity;
begin
  result := TFhirDeviceIdentity(ObjectByIndex[index]);
end;

function TFhirDeviceIdentityList.IndexOf(value: TFhirDeviceIdentity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceIdentityList.Insert(index: Integer): TFhirDeviceIdentity;
begin
  result := TFhirDeviceIdentity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceIdentityList.InsertItem(index: Integer; value: TFhirDeviceIdentity);
begin
  assert(value is TFhirDeviceIdentity);
  Inherited Insert(index, value);
end;

function TFhirDeviceIdentityList.Item(index: Integer): TFhirDeviceIdentity;
begin
  result := TFhirDeviceIdentity(ObjectByIndex[index]);
end;

function TFhirDeviceIdentityList.Link: TFhirDeviceIdentityList;
begin
  result := TFhirDeviceIdentityList(inherited Link);
end;

procedure TFhirDeviceIdentityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceIdentityList.SetItemByIndex(index: Integer; value: TFhirDeviceIdentity);
begin
  assert(value is TFhirDeviceIdentity);
  FhirDeviceIdentities[index] := value;
end;

procedure TFhirDeviceIdentityList.SetItemN(index: Integer; value: TFhirDeviceIdentity);
begin
  assert(value is TFhirDeviceIdentity);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceCapabilitiesVirtualDevice }

constructor TFhirDeviceCapabilitiesVirtualDevice.Create;
begin
  inherited;
  FChannelList := TFhirDeviceCapabilitiesVirtualDeviceChannelList.Create;
end;

destructor TFhirDeviceCapabilitiesVirtualDevice.Destroy;
begin
  FCode.free;
  FChannelList.Free;
  inherited;
end;

procedure TFhirDeviceCapabilitiesVirtualDevice.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceCapabilitiesVirtualDevice(oSource).code.Clone;
  FChannelList.Assign(TFhirDeviceCapabilitiesVirtualDevice(oSource).FChannelList);
end;

procedure TFhirDeviceCapabilitiesVirtualDevice.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'channel') Then
     list.addAll(FChannelList);
end;

procedure TFhirDeviceCapabilitiesVirtualDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'channel', '', FChannelList.Link)){3};
end;

function TFhirDeviceCapabilitiesVirtualDevice.Link : TFhirDeviceCapabilitiesVirtualDevice;
begin
  result := TFhirDeviceCapabilitiesVirtualDevice(inherited Link);
end;

function TFhirDeviceCapabilitiesVirtualDevice.Clone : TFhirDeviceCapabilitiesVirtualDevice;
begin
  result := TFhirDeviceCapabilitiesVirtualDevice(inherited Clone);
end;

{ TFhirDeviceCapabilitiesVirtualDevice }

Procedure TFhirDeviceCapabilitiesVirtualDevice.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirDeviceCapabilitiesVirtualDeviceList }
procedure TFhirDeviceCapabilitiesVirtualDeviceList.AddItem(value: TFhirDeviceCapabilitiesVirtualDevice);
begin
  assert(value.ClassName = 'TFhirDeviceCapabilitiesVirtualDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceCapabilitiesVirtualDevice');
  add(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceList.Append: TFhirDeviceCapabilitiesVirtualDevice;
begin
  result := TFhirDeviceCapabilitiesVirtualDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceCapabilitiesVirtualDeviceList.Clone: TFhirDeviceCapabilitiesVirtualDeviceList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceList(inherited Clone);
end;

function TFhirDeviceCapabilitiesVirtualDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceCapabilitiesVirtualDeviceList.GetItemN(index: Integer): TFhirDeviceCapabilitiesVirtualDevice;
begin
  result := TFhirDeviceCapabilitiesVirtualDevice(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceList.IndexOf(value: TFhirDeviceCapabilitiesVirtualDevice): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceList.Insert(index: Integer): TFhirDeviceCapabilitiesVirtualDevice;
begin
  result := TFhirDeviceCapabilitiesVirtualDevice.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceList.InsertItem(index: Integer; value: TFhirDeviceCapabilitiesVirtualDevice);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDevice);
  Inherited Insert(index, value);
end;

function TFhirDeviceCapabilitiesVirtualDeviceList.Item(index: Integer): TFhirDeviceCapabilitiesVirtualDevice;
begin
  result := TFhirDeviceCapabilitiesVirtualDevice(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceList.Link: TFhirDeviceCapabilitiesVirtualDeviceList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceList(inherited Link);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceList.SetItemByIndex(index: Integer; value: TFhirDeviceCapabilitiesVirtualDevice);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDevice);
  FhirDeviceCapabilitiesVirtualDevices[index] := value;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceList.SetItemN(index: Integer; value: TFhirDeviceCapabilitiesVirtualDevice);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDevice);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannel }

constructor TFhirDeviceCapabilitiesVirtualDeviceChannel.Create;
begin
  inherited;
  FMetricList := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Create;
end;

destructor TFhirDeviceCapabilitiesVirtualDeviceChannel.Destroy;
begin
  FCode.free;
  FMetricList.Free;
  inherited;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannel.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceCapabilitiesVirtualDeviceChannel(oSource).code.Clone;
  FMetricList.Assign(TFhirDeviceCapabilitiesVirtualDeviceChannel(oSource).FMetricList);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannel.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'metric') Then
     list.addAll(FMetricList);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'metric', '', FMetricList.Link)){3};
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannel.Link : TFhirDeviceCapabilitiesVirtualDeviceChannel;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannel(inherited Link);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannel.Clone : TFhirDeviceCapabilitiesVirtualDeviceChannel;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannel(inherited Clone);
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannel }

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannel.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirDeviceCapabilitiesVirtualDeviceChannelList }
procedure TFhirDeviceCapabilitiesVirtualDeviceChannelList.AddItem(value: TFhirDeviceCapabilitiesVirtualDeviceChannel);
begin
  assert(value.ClassName = 'TFhirDeviceCapabilitiesVirtualDeviceChannel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceCapabilitiesVirtualDeviceChannel');
  add(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelList.Append: TFhirDeviceCapabilitiesVirtualDeviceChannel;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelList.Clone: TFhirDeviceCapabilitiesVirtualDeviceChannelList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelList(inherited Clone);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelList.GetItemN(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannel;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannel(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelList.IndexOf(value: TFhirDeviceCapabilitiesVirtualDeviceChannel): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelList.Insert(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannel;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannel.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelList.InsertItem(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannel);
  Inherited Insert(index, value);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelList.Item(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannel;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannel(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelList.Link: TFhirDeviceCapabilitiesVirtualDeviceChannelList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelList(inherited Link);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelList.SetItemByIndex(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannel);
  FhirDeviceCapabilitiesVirtualDeviceChannels[index] := value;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelList.SetItemN(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannel);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetric }

constructor TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.Create;
begin
  inherited;
  FFacetList := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Create;
end;

destructor TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.Destroy;
begin
  FCode.free;
  FKey.free;
  FInfo.free;
  FFacetList.Free;
  inherited;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(oSource).code.Clone;
  key := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(oSource).key.Clone;
  info := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(oSource).info.Clone;
  FFacetList.Assign(TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(oSource).FFacetList);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'key') Then
     list.add(Key.Link);
  if (child_name = 'info') Then
     list.add(Info.Link);
  if (child_name = 'facet') Then
     list.addAll(FFacetList);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'key', 'string', FKey.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'info', '', FInfo.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facet', '', FFacetList.Link)){3};
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(inherited Link);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(inherited Clone);
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetric }

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.SetKey(value : TFhirString);
begin
  FKey.free;
  FKey := value;
end;

Function TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.GetKeyST : String;
begin
  if FKey = nil then
    result := ''
  else
    result := Key.value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.SetKeyST(value : String);
begin
  if value <> '' then
  begin
    if FKey = nil then
      FKey := TFhirString.create;
    FKey.value := value
  end
  else if FKey <> nil then
    FKey.value := '';
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.SetInfo(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
begin
  FInfo.free;
  FInfo := value;
end;


{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList }
procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.AddItem(value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
begin
  assert(value.ClassName = 'TFhirDeviceCapabilitiesVirtualDeviceChannelMetric', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceCapabilitiesVirtualDeviceChannelMetric');
  add(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Append: TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Clone: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList(inherited Clone);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.GetItemN(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.IndexOf(value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetric): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Insert(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.InsertItem(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
  Inherited Insert(index, value);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Item(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetric(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Link: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList(inherited Link);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.SetItemByIndex(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
  FhirDeviceCapabilitiesVirtualDeviceChannelMetrics[index] := value;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricList.SetItemN(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetric);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo }

constructor TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.Create;
begin
  inherited;
end;

destructor TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.Destroy;
begin
  FType_.free;
  FUnits.free;
  FUcum.free;
  FTemplate.free;
  FSystem.free;
  inherited;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(oSource).FType_.Link;
  units := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(oSource).units.Clone;
  ucum := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(oSource).ucum.Clone;
  template := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(oSource).template.Clone;
  system := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(oSource).system.Clone;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'units') Then
     list.add(Units.Link);
  if (child_name = 'ucum') Then
     list.add(Ucum.Link);
  if (child_name = 'template') Then
     list.add(Template.Link);
  if (child_name = 'system') Then
     list.add(System.Link);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'units', 'string', FUnits.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ucum', 'code', FUcum.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'template', 'SampledData', FTemplate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(inherited Link);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(inherited Clone);
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo }

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.GetType_ST : TFhirDeviceDataType;
begin
  if FType_ = nil then
    result := TFhirDeviceDataType(0)
  else
    result := TFhirDeviceDataType(StringArrayIndexOf(CODES_TFhirDeviceDataType, Type_.value));
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetType_ST(value : TFhirDeviceDataType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirDeviceDataType[value]);
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetUnits(value : TFhirString);
begin
  FUnits.free;
  FUnits := value;
end;

Function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.GetUnitsST : String;
begin
  if FUnits = nil then
    result := ''
  else
    result := Units.value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetUnitsST(value : String);
begin
  if value <> '' then
  begin
    if FUnits = nil then
      FUnits := TFhirString.create;
    FUnits.value := value
  end
  else if FUnits <> nil then
    FUnits.value := '';
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetUcum(value : TFhirCode);
begin
  FUcum.free;
  FUcum := value;
end;

Function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.GetUcumST : String;
begin
  if FUcum = nil then
    result := ''
  else
    result := Ucum.value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetUcumST(value : String);
begin
  if value <> '' then
  begin
    if FUcum = nil then
      FUcum := TFhirCode.create;
    FUcum.value := value
  end
  else if FUcum <> nil then
    FUcum.value := '';
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetTemplate(value : TFhirSampledData);
begin
  FTemplate.free;
  FTemplate := value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;


{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList }
procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.AddItem(value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
begin
  assert(value.ClassName = 'TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo');
  add(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.Append: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.Clone: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList(inherited Clone);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.GetItemN(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.IndexOf(value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.Insert(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.InsertItem(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
  Inherited Insert(index, value);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.Item(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.Link: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList(inherited Link);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.SetItemByIndex(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
  FhirDeviceCapabilitiesVirtualDeviceChannelMetricInfos[index] := value;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfoList.SetItemN(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet }

constructor TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.Create;
begin
  inherited;
end;

destructor TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.Destroy;
begin
  FCode.free;
  FScale.free;
  FKey.free;
  FInfo.free;
  inherited;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(oSource).code.Clone;
  scale := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(oSource).scale.Clone;
  key := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(oSource).key.Clone;
  info := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(oSource).info.Clone;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'scale') Then
     list.add(Scale.Link);
  if (child_name = 'key') Then
     list.add(Key.Link);
  if (child_name = 'info') Then
     list.add(Info.Link);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'scale', 'decimal', FScale.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'key', 'string', FKey.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'info', '@DeviceCapabilities.virtualDevice.channel.metric.info', FInfo.Link.Link));{2}
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.Link : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(inherited Link);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.Clone : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(inherited Clone);
end;

{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet }

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.SetScale(value : TFhirDecimal);
begin
  FScale.free;
  FScale := value;
end;

Function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.GetScaleST : String;
begin
  if FScale = nil then
    result := ''
  else
    result := Scale.value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.SetScaleST(value : String);
begin
  if value <> '' then
  begin
    if FScale = nil then
      FScale := TFhirDecimal.create;
    FScale.value := value
  end
  else if FScale <> nil then
    FScale.value := '';
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.SetKey(value : TFhirString);
begin
  FKey.free;
  FKey := value;
end;

Function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.GetKeyST : String;
begin
  if FKey = nil then
    result := ''
  else
    result := Key.value;
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.SetKeyST(value : String);
begin
  if value <> '' then
  begin
    if FKey = nil then
      FKey := TFhirString.create;
    FKey.value := value
  end
  else if FKey <> nil then
    FKey.value := '';
end;

Procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.SetInfo(value : TFhirDeviceCapabilitiesVirtualDeviceChannelMetricInfo);
begin
  FInfo.free;
  FInfo := value;
end;


{ TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList }
procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.AddItem(value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
begin
  assert(value.ClassName = 'TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet');
  add(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Append: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Clone: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList(inherited Clone);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.GetItemN(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.IndexOf(value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Insert(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.InsertItem(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
  Inherited Insert(index, value);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Item(index: Integer): TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet(ObjectByIndex[index]);
end;

function TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Link: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList;
begin
  result := TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList(inherited Link);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.SetItemByIndex(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
  FhirDeviceCapabilitiesVirtualDeviceChannelMetricFacets[index] := value;
end;

procedure TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacetList.SetItemN(index: Integer; value: TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
begin
  assert(value is TFhirDeviceCapabilitiesVirtualDeviceChannelMetricFacet);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceLogItem }

constructor TFhirDeviceLogItem.Create;
begin
  inherited;
  FFlag := TFHIREnumList.Create;
end;

destructor TFhirDeviceLogItem.Destroy;
begin
  FKey.free;
  FValue.free;
  FFlag.Free;
  inherited;
end;

procedure TFhirDeviceLogItem.Assign(oSource : TAdvObject);
begin
  inherited;
  key := TFhirDeviceLogItem(oSource).key.Clone;
  value := TFhirDeviceLogItem(oSource).value.Clone;
  FFlag.Assign(TFhirDeviceLogItem(oSource).FFlag);
end;

procedure TFhirDeviceLogItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'key') Then
     list.add(Key.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
  if (child_name = 'flag') Then
     list.addAll(FFlag);
end;

procedure TFhirDeviceLogItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'key', 'string', FKey.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', FValue.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'flag', 'code', FFlag.Link)){3};
end;

function TFhirDeviceLogItem.Link : TFhirDeviceLogItem;
begin
  result := TFhirDeviceLogItem(inherited Link);
end;

function TFhirDeviceLogItem.Clone : TFhirDeviceLogItem;
begin
  result := TFhirDeviceLogItem(inherited Clone);
end;

{ TFhirDeviceLogItem }

Procedure TFhirDeviceLogItem.SetKey(value : TFhirString);
begin
  FKey.free;
  FKey := value;
end;

Function TFhirDeviceLogItem.GetKeyST : String;
begin
  if FKey = nil then
    result := ''
  else
    result := Key.value;
end;

Procedure TFhirDeviceLogItem.SetKeyST(value : String);
begin
  if value <> '' then
  begin
    if FKey = nil then
      FKey := TFhirString.create;
    FKey.value := value
  end
  else if FKey <> nil then
    FKey.value := '';
end;

Procedure TFhirDeviceLogItem.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirDeviceLogItem.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := Value.value;
end;

Procedure TFhirDeviceLogItem.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Function TFhirDeviceLogItem.GetFlagST : TFhirDeviceValueFlagList;
  var i : integer;
begin
  result := [];
  for i := 0 to flag.count - 1 do
    result := result + [TFhirDeviceValueFlag(StringArrayIndexOf(CODES_TFhirDeviceValueFlag, flag[i].value))];
end;

Procedure TFhirDeviceLogItem.SetFlagST(value : TFhirDeviceValueFlagList);
var a : TFhirDeviceValueFlag;
begin
  flag.clear;
  for a := low(TFhirDeviceValueFlag) to high(TFhirDeviceValueFlag) do
    if a in value then
      flag.add(TFhirEnum.create(CODES_TFhirDeviceValueFlag[a]));
end;


{ TFhirDeviceLogItemList }
procedure TFhirDeviceLogItemList.AddItem(value: TFhirDeviceLogItem);
begin
  assert(value.ClassName = 'TFhirDeviceLogItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceLogItem');
  add(value);
end;


function TFhirDeviceLogItemList.Append: TFhirDeviceLogItem;
begin
  result := TFhirDeviceLogItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceLogItemList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceLogItemList.Clone: TFhirDeviceLogItemList;
begin
  result := TFhirDeviceLogItemList(inherited Clone);
end;

function TFhirDeviceLogItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceLogItemList.GetItemN(index: Integer): TFhirDeviceLogItem;
begin
  result := TFhirDeviceLogItem(ObjectByIndex[index]);
end;

function TFhirDeviceLogItemList.IndexOf(value: TFhirDeviceLogItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceLogItemList.Insert(index: Integer): TFhirDeviceLogItem;
begin
  result := TFhirDeviceLogItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceLogItemList.InsertItem(index: Integer; value: TFhirDeviceLogItem);
begin
  assert(value is TFhirDeviceLogItem);
  Inherited Insert(index, value);
end;

function TFhirDeviceLogItemList.Item(index: Integer): TFhirDeviceLogItem;
begin
  result := TFhirDeviceLogItem(ObjectByIndex[index]);
end;

function TFhirDeviceLogItemList.Link: TFhirDeviceLogItemList;
begin
  result := TFhirDeviceLogItemList(inherited Link);
end;

procedure TFhirDeviceLogItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceLogItemList.SetItemByIndex(index: Integer; value: TFhirDeviceLogItem);
begin
  assert(value is TFhirDeviceLogItem);
  FhirDeviceLogItems[index] := value;
end;

procedure TFhirDeviceLogItemList.SetItemN(index: Integer; value: TFhirDeviceLogItem);
begin
  assert(value is TFhirDeviceLogItem);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrderEvent }

constructor TFhirDiagnosticOrderEvent.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticOrderEvent.Destroy;
begin
  FStatus.free;
  FDate.free;
  FActor.free;
  inherited;
end;

procedure TFhirDiagnosticOrderEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  FStatus := TFhirDiagnosticOrderEvent(oSource).FStatus.Link;
  date := TFhirDiagnosticOrderEvent(oSource).date.Clone;
  actor := TFhirDiagnosticOrderEvent(oSource).actor.Clone;
end;

procedure TFhirDiagnosticOrderEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'date') Then
     list.add(Date.Link);
  if (child_name = 'actor') Then
     list.add(Actor.Link);
end;

procedure TFhirDiagnosticOrderEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Resource(Practitioner|Device)', FActor.Link.Link));{2}
end;

function TFhirDiagnosticOrderEvent.Link : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Link);
end;

function TFhirDiagnosticOrderEvent.Clone : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Clone);
end;

{ TFhirDiagnosticOrderEvent }

Procedure TFhirDiagnosticOrderEvent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderEvent.GetStatusST : TFhirDiagnosticOrderStatus;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatus(0)
  else
    result := TFhirDiagnosticOrderStatus(StringArrayIndexOf(CODES_TFhirDiagnosticOrderStatus, Status.value));
end;

Procedure TFhirDiagnosticOrderEvent.SetStatusST(value : TFhirDiagnosticOrderStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirDiagnosticOrderStatus[value]);
end;

Procedure TFhirDiagnosticOrderEvent.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirDiagnosticOrderEvent.GetDateST : TDateAndTime;
begin
  if FDate = nil then
    result := nil
  else
    result := Date.value;
end;

Procedure TFhirDiagnosticOrderEvent.SetDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirDiagnosticOrderEvent.SetActor(value : TFhirResourceReference{Resource});
begin
  FActor.free;
  FActor := value;
end;


{ TFhirDiagnosticOrderEventList }
procedure TFhirDiagnosticOrderEventList.AddItem(value: TFhirDiagnosticOrderEvent);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderEvent');
  add(value);
end;


function TFhirDiagnosticOrderEventList.Append: TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderEventList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderEventList.Clone: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Clone);
end;

function TFhirDiagnosticOrderEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderEventList.GetItemN(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.IndexOf(value: TFhirDiagnosticOrderEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticOrderEventList.Insert(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderEventList.InsertItem(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderEventList.Item(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.Link: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Link);
end;

procedure TFhirDiagnosticOrderEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderEventList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  FhirDiagnosticOrderEvents[index] := value;
end;

procedure TFhirDiagnosticOrderEventList.SetItemN(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrderItem }

constructor TFhirDiagnosticOrderItem.Create;
begin
  inherited;
  FSpecimenList := TFhirResourceReferenceList{TFhirSpecimen}.Create;
  FEventList := TFhirDiagnosticOrderEventList.Create;
end;

destructor TFhirDiagnosticOrderItem.Destroy;
begin
  FCode.free;
  FSpecimenList.Free;
  FBodySite.free;
  FStatus.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirDiagnosticOrderItem.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDiagnosticOrderItem(oSource).code.Clone;
  FSpecimenList.Assign(TFhirDiagnosticOrderItem(oSource).FSpecimenList);
  bodySite := TFhirDiagnosticOrderItem(oSource).bodySite.Clone;
  FStatus := TFhirDiagnosticOrderItem(oSource).FStatus.Link;
  FEventList.Assign(TFhirDiagnosticOrderItem(oSource).FEventList);
end;

procedure TFhirDiagnosticOrderItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'specimen') Then
     list.addAll(FSpecimenList);
  if (child_name = 'bodySite') Then
     list.add(BodySite.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'event') Then
     list.addAll(FEventList);
end;

procedure TFhirDiagnosticOrderItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Resource(Specimen)', FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', FBodySite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'event', '@DiagnosticOrder.event', FEventList.Link)){3};
end;

function TFhirDiagnosticOrderItem.Link : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Link);
end;

function TFhirDiagnosticOrderItem.Clone : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Clone);
end;

{ TFhirDiagnosticOrderItem }

Procedure TFhirDiagnosticOrderItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDiagnosticOrderItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirDiagnosticOrderItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderItem.GetStatusST : TFhirDiagnosticOrderStatus;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatus(0)
  else
    result := TFhirDiagnosticOrderStatus(StringArrayIndexOf(CODES_TFhirDiagnosticOrderStatus, Status.value));
end;

Procedure TFhirDiagnosticOrderItem.SetStatusST(value : TFhirDiagnosticOrderStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirDiagnosticOrderStatus[value]);
end;


{ TFhirDiagnosticOrderItemList }
procedure TFhirDiagnosticOrderItemList.AddItem(value: TFhirDiagnosticOrderItem);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderItem');
  add(value);
end;


function TFhirDiagnosticOrderItemList.Append: TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderItemList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderItemList.Clone: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Clone);
end;

function TFhirDiagnosticOrderItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderItemList.GetItemN(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.IndexOf(value: TFhirDiagnosticOrderItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticOrderItemList.Insert(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderItemList.InsertItem(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderItemList.Item(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.Link: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Link);
end;

procedure TFhirDiagnosticOrderItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderItemList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  FhirDiagnosticOrderItems[index] := value;
end;

procedure TFhirDiagnosticOrderItemList.SetItemN(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReportRequestDetail }

constructor TFhirDiagnosticReportRequestDetail.Create;
begin
  inherited;
  FRequestTestList := TFhirCodeableConceptList.Create;
end;

destructor TFhirDiagnosticReportRequestDetail.Destroy;
begin
  FEncounter.free;
  FRequestOrderId.free;
  FReceiverOrderId.free;
  FRequestTestList.Free;
  FBodySite.free;
  FRequester.free;
  FClinicalInfo.free;
  inherited;
end;

procedure TFhirDiagnosticReportRequestDetail.Assign(oSource : TAdvObject);
begin
  inherited;
  encounter := TFhirDiagnosticReportRequestDetail(oSource).encounter.Clone;
  requestOrderId := TFhirDiagnosticReportRequestDetail(oSource).requestOrderId.Clone;
  receiverOrderId := TFhirDiagnosticReportRequestDetail(oSource).receiverOrderId.Clone;
  FRequestTestList.Assign(TFhirDiagnosticReportRequestDetail(oSource).FRequestTestList);
  bodySite := TFhirDiagnosticReportRequestDetail(oSource).bodySite.Clone;
  requester := TFhirDiagnosticReportRequestDetail(oSource).requester.Clone;
  clinicalInfo := TFhirDiagnosticReportRequestDetail(oSource).clinicalInfo.Clone;
end;

procedure TFhirDiagnosticReportRequestDetail.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'encounter') Then
     list.add(Encounter.Link);
  if (child_name = 'requestOrderId') Then
     list.add(RequestOrderId.Link);
  if (child_name = 'receiverOrderId') Then
     list.add(ReceiverOrderId.Link);
  if (child_name = 'requestTest') Then
     list.addAll(FRequestTestList);
  if (child_name = 'bodySite') Then
     list.add(BodySite.Link);
  if (child_name = 'requester') Then
     list.add(Requester.Link);
  if (child_name = 'clinicalInfo') Then
     list.add(ClinicalInfo.Link);
end;

procedure TFhirDiagnosticReportRequestDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'encounter', 'Resource(Encounter)', FEncounter.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrderId', 'Identifier', FRequestOrderId.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiverOrderId', 'Identifier', FReceiverOrderId.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestTest', 'CodeableConcept', FRequestTestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', FBodySite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', 'Resource(Organization|Practitioner)', FRequester.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'clinicalInfo', 'string', FClinicalInfo.Link.Link));{2}
end;

function TFhirDiagnosticReportRequestDetail.Link : TFhirDiagnosticReportRequestDetail;
begin
  result := TFhirDiagnosticReportRequestDetail(inherited Link);
end;

function TFhirDiagnosticReportRequestDetail.Clone : TFhirDiagnosticReportRequestDetail;
begin
  result := TFhirDiagnosticReportRequestDetail(inherited Clone);
end;

{ TFhirDiagnosticReportRequestDetail }

Procedure TFhirDiagnosticReportRequestDetail.SetEncounter(value : TFhirResourceReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirDiagnosticReportRequestDetail.SetRequestOrderId(value : TFhirIdentifier);
begin
  FRequestOrderId.free;
  FRequestOrderId := value;
end;

Procedure TFhirDiagnosticReportRequestDetail.SetReceiverOrderId(value : TFhirIdentifier);
begin
  FReceiverOrderId.free;
  FReceiverOrderId := value;
end;

Procedure TFhirDiagnosticReportRequestDetail.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirDiagnosticReportRequestDetail.SetRequester(value : TFhirResourceReference{Resource});
begin
  FRequester.free;
  FRequester := value;
end;

Procedure TFhirDiagnosticReportRequestDetail.SetClinicalInfo(value : TFhirString);
begin
  FClinicalInfo.free;
  FClinicalInfo := value;
end;

Function TFhirDiagnosticReportRequestDetail.GetClinicalInfoST : String;
begin
  if FClinicalInfo = nil then
    result := ''
  else
    result := ClinicalInfo.value;
end;

Procedure TFhirDiagnosticReportRequestDetail.SetClinicalInfoST(value : String);
begin
  if value <> '' then
  begin
    if FClinicalInfo = nil then
      FClinicalInfo := TFhirString.create;
    FClinicalInfo.value := value
  end
  else if FClinicalInfo <> nil then
    FClinicalInfo.value := '';
end;


{ TFhirDiagnosticReportRequestDetailList }
procedure TFhirDiagnosticReportRequestDetailList.AddItem(value: TFhirDiagnosticReportRequestDetail);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportRequestDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportRequestDetail');
  add(value);
end;


function TFhirDiagnosticReportRequestDetailList.Append: TFhirDiagnosticReportRequestDetail;
begin
  result := TFhirDiagnosticReportRequestDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportRequestDetailList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportRequestDetailList.Clone: TFhirDiagnosticReportRequestDetailList;
begin
  result := TFhirDiagnosticReportRequestDetailList(inherited Clone);
end;

function TFhirDiagnosticReportRequestDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportRequestDetailList.GetItemN(index: Integer): TFhirDiagnosticReportRequestDetail;
begin
  result := TFhirDiagnosticReportRequestDetail(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportRequestDetailList.IndexOf(value: TFhirDiagnosticReportRequestDetail): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticReportRequestDetailList.Insert(index: Integer): TFhirDiagnosticReportRequestDetail;
begin
  result := TFhirDiagnosticReportRequestDetail.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportRequestDetailList.InsertItem(index: Integer; value: TFhirDiagnosticReportRequestDetail);
begin
  assert(value is TFhirDiagnosticReportRequestDetail);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportRequestDetailList.Item(index: Integer): TFhirDiagnosticReportRequestDetail;
begin
  result := TFhirDiagnosticReportRequestDetail(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportRequestDetailList.Link: TFhirDiagnosticReportRequestDetailList;
begin
  result := TFhirDiagnosticReportRequestDetailList(inherited Link);
end;

procedure TFhirDiagnosticReportRequestDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportRequestDetailList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportRequestDetail);
begin
  assert(value is TFhirDiagnosticReportRequestDetail);
  FhirDiagnosticReportRequestDetails[index] := value;
end;

procedure TFhirDiagnosticReportRequestDetailList.SetItemN(index: Integer; value: TFhirDiagnosticReportRequestDetail);
begin
  assert(value is TFhirDiagnosticReportRequestDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReportResults }

constructor TFhirDiagnosticReportResults.Create;
begin
  inherited;
  FGroupList := TFhirDiagnosticReportResultsList.Create;
  FResultList := TFhirResourceReferenceList{TFhirObservation}.Create;
end;

destructor TFhirDiagnosticReportResults.Destroy;
begin
  FName.free;
  FSpecimen.free;
  FGroupList.Free;
  FResultList.Free;
  inherited;
end;

procedure TFhirDiagnosticReportResults.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirDiagnosticReportResults(oSource).name.Clone;
  specimen := TFhirDiagnosticReportResults(oSource).specimen.Clone;
  FGroupList.Assign(TFhirDiagnosticReportResults(oSource).FGroupList);
  FResultList.Assign(TFhirDiagnosticReportResults(oSource).FResultList);
end;

procedure TFhirDiagnosticReportResults.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'specimen') Then
     list.add(Specimen.Link);
  if (child_name = 'group') Then
     list.addAll(FGroupList);
  if (child_name = 'result') Then
     list.addAll(FResultList);
end;

procedure TFhirDiagnosticReportResults.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Resource(Specimen)', FSpecimen.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@DiagnosticReport.results', FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'result', 'Resource(Observation)', FResultList.Link)){3};
end;

function TFhirDiagnosticReportResults.Link : TFhirDiagnosticReportResults;
begin
  result := TFhirDiagnosticReportResults(inherited Link);
end;

function TFhirDiagnosticReportResults.Clone : TFhirDiagnosticReportResults;
begin
  result := TFhirDiagnosticReportResults(inherited Clone);
end;

{ TFhirDiagnosticReportResults }

Procedure TFhirDiagnosticReportResults.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirDiagnosticReportResults.SetSpecimen(value : TFhirResourceReference{TFhirSpecimen});
begin
  FSpecimen.free;
  FSpecimen := value;
end;


{ TFhirDiagnosticReportResultsList }
procedure TFhirDiagnosticReportResultsList.AddItem(value: TFhirDiagnosticReportResults);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportResults', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportResults');
  add(value);
end;


function TFhirDiagnosticReportResultsList.Append: TFhirDiagnosticReportResults;
begin
  result := TFhirDiagnosticReportResults.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportResultsList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportResultsList.Clone: TFhirDiagnosticReportResultsList;
begin
  result := TFhirDiagnosticReportResultsList(inherited Clone);
end;

function TFhirDiagnosticReportResultsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportResultsList.GetItemN(index: Integer): TFhirDiagnosticReportResults;
begin
  result := TFhirDiagnosticReportResults(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportResultsList.IndexOf(value: TFhirDiagnosticReportResults): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticReportResultsList.Insert(index: Integer): TFhirDiagnosticReportResults;
begin
  result := TFhirDiagnosticReportResults.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportResultsList.InsertItem(index: Integer; value: TFhirDiagnosticReportResults);
begin
  assert(value is TFhirDiagnosticReportResults);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportResultsList.Item(index: Integer): TFhirDiagnosticReportResults;
begin
  result := TFhirDiagnosticReportResults(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportResultsList.Link: TFhirDiagnosticReportResultsList;
begin
  result := TFhirDiagnosticReportResultsList(inherited Link);
end;

procedure TFhirDiagnosticReportResultsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportResultsList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportResults);
begin
  assert(value is TFhirDiagnosticReportResults);
  FhirDiagnosticReportResults[index] := value;
end;

procedure TFhirDiagnosticReportResultsList.SetItemN(index: Integer; value: TFhirDiagnosticReportResults);
begin
  assert(value is TFhirDiagnosticReportResults);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentAttester }

constructor TFhirDocumentAttester.Create;
begin
  inherited;
end;

destructor TFhirDocumentAttester.Destroy;
begin
  FMode.free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirDocumentAttester.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode := TFhirDocumentAttester(oSource).FMode.Link;
  time := TFhirDocumentAttester(oSource).time.Clone;
  party := TFhirDocumentAttester(oSource).party.Clone;
end;

procedure TFhirDocumentAttester.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'time') Then
     list.add(Time.Link);
  if (child_name = 'party') Then
     list.add(Party.Link);
end;

procedure TFhirDocumentAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', FTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Resource(Patient|Practitioner|Organization)', FParty.Link.Link));{2}
end;

function TFhirDocumentAttester.Link : TFhirDocumentAttester;
begin
  result := TFhirDocumentAttester(inherited Link);
end;

function TFhirDocumentAttester.Clone : TFhirDocumentAttester;
begin
  result := TFhirDocumentAttester(inherited Clone);
end;

{ TFhirDocumentAttester }

Procedure TFhirDocumentAttester.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirDocumentAttester.GetModeST : TFhirDocumentAttestationMode;
begin
  if FMode = nil then
    result := TFhirDocumentAttestationMode(0)
  else
    result := TFhirDocumentAttestationMode(StringArrayIndexOf(CODES_TFhirDocumentAttestationMode, Mode.value));
end;

Procedure TFhirDocumentAttester.SetModeST(value : TFhirDocumentAttestationMode);
begin
  if ord(value) = 0 then
    Mode := nil
  else
    Mode := TFhirEnum.create(CODES_TFhirDocumentAttestationMode[value]);
end;

Procedure TFhirDocumentAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirDocumentAttester.GetTimeST : TDateAndTime;
begin
  if FTime = nil then
    result := nil
  else
    result := Time.value;
end;

Procedure TFhirDocumentAttester.SetTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FTime = nil then
      FTime := TFhirDateTime.create;
    FTime.value := value
  end
  else if FTime <> nil then
    FTime.value := nil;
end;

Procedure TFhirDocumentAttester.SetParty(value : TFhirResourceReference{Resource});
begin
  FParty.free;
  FParty := value;
end;


{ TFhirDocumentAttesterList }
procedure TFhirDocumentAttesterList.AddItem(value: TFhirDocumentAttester);
begin
  assert(value.ClassName = 'TFhirDocumentAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentAttester');
  add(value);
end;


function TFhirDocumentAttesterList.Append: TFhirDocumentAttester;
begin
  result := TFhirDocumentAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentAttesterList.Clone: TFhirDocumentAttesterList;
begin
  result := TFhirDocumentAttesterList(inherited Clone);
end;

function TFhirDocumentAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentAttesterList.GetItemN(index: Integer): TFhirDocumentAttester;
begin
  result := TFhirDocumentAttester(ObjectByIndex[index]);
end;

function TFhirDocumentAttesterList.IndexOf(value: TFhirDocumentAttester): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentAttesterList.Insert(index: Integer): TFhirDocumentAttester;
begin
  result := TFhirDocumentAttester.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentAttesterList.InsertItem(index: Integer; value: TFhirDocumentAttester);
begin
  assert(value is TFhirDocumentAttester);
  Inherited Insert(index, value);
end;

function TFhirDocumentAttesterList.Item(index: Integer): TFhirDocumentAttester;
begin
  result := TFhirDocumentAttester(ObjectByIndex[index]);
end;

function TFhirDocumentAttesterList.Link: TFhirDocumentAttesterList;
begin
  result := TFhirDocumentAttesterList(inherited Link);
end;

procedure TFhirDocumentAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentAttesterList.SetItemByIndex(index: Integer; value: TFhirDocumentAttester);
begin
  assert(value is TFhirDocumentAttester);
  FhirDocumentAttesters[index] := value;
end;

procedure TFhirDocumentAttesterList.SetItemN(index: Integer; value: TFhirDocumentAttester);
begin
  assert(value is TFhirDocumentAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentEvent }

constructor TFhirDocumentEvent.Create;
begin
  inherited;
  FCodeList := TFhirCodeableConceptList.Create;
  FDetailList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirDocumentEvent.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirDocumentEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  FCodeList.Assign(TFhirDocumentEvent(oSource).FCodeList);
  period := TFhirDocumentEvent(oSource).period.Clone;
  FDetailList.Assign(TFhirDocumentEvent(oSource).FDetailList);
end;

procedure TFhirDocumentEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.addAll(FCodeList);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirDocumentEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Any)', FDetailList.Link)){3};
end;

function TFhirDocumentEvent.Link : TFhirDocumentEvent;
begin
  result := TFhirDocumentEvent(inherited Link);
end;

function TFhirDocumentEvent.Clone : TFhirDocumentEvent;
begin
  result := TFhirDocumentEvent(inherited Clone);
end;

{ TFhirDocumentEvent }

Procedure TFhirDocumentEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirDocumentEventList }
procedure TFhirDocumentEventList.AddItem(value: TFhirDocumentEvent);
begin
  assert(value.ClassName = 'TFhirDocumentEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentEvent');
  add(value);
end;


function TFhirDocumentEventList.Append: TFhirDocumentEvent;
begin
  result := TFhirDocumentEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentEventList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentEventList.Clone: TFhirDocumentEventList;
begin
  result := TFhirDocumentEventList(inherited Clone);
end;

function TFhirDocumentEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentEventList.GetItemN(index: Integer): TFhirDocumentEvent;
begin
  result := TFhirDocumentEvent(ObjectByIndex[index]);
end;

function TFhirDocumentEventList.IndexOf(value: TFhirDocumentEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentEventList.Insert(index: Integer): TFhirDocumentEvent;
begin
  result := TFhirDocumentEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentEventList.InsertItem(index: Integer; value: TFhirDocumentEvent);
begin
  assert(value is TFhirDocumentEvent);
  Inherited Insert(index, value);
end;

function TFhirDocumentEventList.Item(index: Integer): TFhirDocumentEvent;
begin
  result := TFhirDocumentEvent(ObjectByIndex[index]);
end;

function TFhirDocumentEventList.Link: TFhirDocumentEventList;
begin
  result := TFhirDocumentEventList(inherited Link);
end;

procedure TFhirDocumentEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentEventList.SetItemByIndex(index: Integer; value: TFhirDocumentEvent);
begin
  assert(value is TFhirDocumentEvent);
  FhirDocumentEvents[index] := value;
end;

procedure TFhirDocumentEventList.SetItemN(index: Integer; value: TFhirDocumentEvent);
begin
  assert(value is TFhirDocumentEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentSection }

constructor TFhirDocumentSection.Create;
begin
  inherited;
  FSectionList := TFhirDocumentSectionList.Create;
end;

destructor TFhirDocumentSection.Destroy;
begin
  FCode.free;
  FSubject.free;
  FContent.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirDocumentSection.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDocumentSection(oSource).code.Clone;
  subject := TFhirDocumentSection(oSource).subject.Clone;
  content := TFhirDocumentSection(oSource).content.Clone;
  FSectionList.Assign(TFhirDocumentSection(oSource).FSectionList);
end;

procedure TFhirDocumentSection.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'subject') Then
     list.add(Subject.Link);
  if (child_name = 'content') Then
     list.add(Content.Link);
  if (child_name = 'section') Then
     list.addAll(FSectionList);
end;

procedure TFhirDocumentSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Resource(Patient|Group|Device)', FSubject.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'Resource(Any)', FContent.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'section', '@Document.section', FSectionList.Link)){3};
end;

function TFhirDocumentSection.Link : TFhirDocumentSection;
begin
  result := TFhirDocumentSection(inherited Link);
end;

function TFhirDocumentSection.Clone : TFhirDocumentSection;
begin
  result := TFhirDocumentSection(inherited Clone);
end;

{ TFhirDocumentSection }

Procedure TFhirDocumentSection.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDocumentSection.SetSubject(value : TFhirResourceReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDocumentSection.SetContent(value : TFhirResourceReference{Resource});
begin
  FContent.free;
  FContent := value;
end;


{ TFhirDocumentSectionList }
procedure TFhirDocumentSectionList.AddItem(value: TFhirDocumentSection);
begin
  assert(value.ClassName = 'TFhirDocumentSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentSection');
  add(value);
end;


function TFhirDocumentSectionList.Append: TFhirDocumentSection;
begin
  result := TFhirDocumentSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentSectionList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentSectionList.Clone: TFhirDocumentSectionList;
begin
  result := TFhirDocumentSectionList(inherited Clone);
end;

function TFhirDocumentSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentSectionList.GetItemN(index: Integer): TFhirDocumentSection;
begin
  result := TFhirDocumentSection(ObjectByIndex[index]);
end;

function TFhirDocumentSectionList.IndexOf(value: TFhirDocumentSection): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentSectionList.Insert(index: Integer): TFhirDocumentSection;
begin
  result := TFhirDocumentSection.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentSectionList.InsertItem(index: Integer; value: TFhirDocumentSection);
begin
  assert(value is TFhirDocumentSection);
  Inherited Insert(index, value);
end;

function TFhirDocumentSectionList.Item(index: Integer): TFhirDocumentSection;
begin
  result := TFhirDocumentSection(ObjectByIndex[index]);
end;

function TFhirDocumentSectionList.Link: TFhirDocumentSectionList;
begin
  result := TFhirDocumentSectionList(inherited Link);
end;

procedure TFhirDocumentSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentSectionList.SetItemByIndex(index: Integer; value: TFhirDocumentSection);
begin
  assert(value is TFhirDocumentSection);
  FhirDocumentSections[index] := value;
end;

procedure TFhirDocumentSectionList.SetItemN(index: Integer; value: TFhirDocumentSection);
begin
  assert(value is TFhirDocumentSection);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceService }

constructor TFhirDocumentReferenceService.Create;
begin
  inherited;
  FParameterList := TFhirDocumentReferenceServiceParameterList.Create;
end;

destructor TFhirDocumentReferenceService.Destroy;
begin
  FType_.free;
  FAddress.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirDocumentReferenceService.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirDocumentReferenceService(oSource).type_.Clone;
  address := TFhirDocumentReferenceService(oSource).address.Clone;
  FParameterList.Assign(TFhirDocumentReferenceService(oSource).FParameterList);
end;

procedure TFhirDocumentReferenceService.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'address') Then
     list.add(Address.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirDocumentReferenceService.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'address', 'string', FAddress.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '', FParameterList.Link)){3};
end;

function TFhirDocumentReferenceService.Link : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(inherited Link);
end;

function TFhirDocumentReferenceService.Clone : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(inherited Clone);
end;

{ TFhirDocumentReferenceService }

Procedure TFhirDocumentReferenceService.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDocumentReferenceService.SetAddress(value : TFhirString);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirDocumentReferenceService.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := Address.value;
end;

Procedure TFhirDocumentReferenceService.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirString.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;


{ TFhirDocumentReferenceServiceList }
procedure TFhirDocumentReferenceServiceList.AddItem(value: TFhirDocumentReferenceService);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceService', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceService');
  add(value);
end;


function TFhirDocumentReferenceServiceList.Append: TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceServiceList.Clone: TFhirDocumentReferenceServiceList;
begin
  result := TFhirDocumentReferenceServiceList(inherited Clone);
end;

function TFhirDocumentReferenceServiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceServiceList.GetItemN(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceList.IndexOf(value: TFhirDocumentReferenceService): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceServiceList.Insert(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceList.InsertItem(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceServiceList.Item(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceList.Link: TFhirDocumentReferenceServiceList;
begin
  result := TFhirDocumentReferenceServiceList(inherited Link);
end;

procedure TFhirDocumentReferenceServiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceServiceList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  FhirDocumentReferenceServices[index] := value;
end;

procedure TFhirDocumentReferenceServiceList.SetItemN(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceServiceParameter }

constructor TFhirDocumentReferenceServiceParameter.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceServiceParameter.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirDocumentReferenceServiceParameter.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirDocumentReferenceServiceParameter(oSource).name.Clone;
  value := TFhirDocumentReferenceServiceParameter(oSource).value.Clone;
end;

procedure TFhirDocumentReferenceServiceParameter.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirDocumentReferenceServiceParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', FValue.Link.Link));{2}
end;

function TFhirDocumentReferenceServiceParameter.Link : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(inherited Link);
end;

function TFhirDocumentReferenceServiceParameter.Clone : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(inherited Clone);
end;

{ TFhirDocumentReferenceServiceParameter }

Procedure TFhirDocumentReferenceServiceParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDocumentReferenceServiceParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirDocumentReferenceServiceParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirDocumentReferenceServiceParameter.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirDocumentReferenceServiceParameter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := Value.value;
end;

Procedure TFhirDocumentReferenceServiceParameter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirDocumentReferenceServiceParameterList }
procedure TFhirDocumentReferenceServiceParameterList.AddItem(value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceServiceParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceServiceParameter');
  add(value);
end;


function TFhirDocumentReferenceServiceParameterList.Append: TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceParameterList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceServiceParameterList.Clone: TFhirDocumentReferenceServiceParameterList;
begin
  result := TFhirDocumentReferenceServiceParameterList(inherited Clone);
end;

function TFhirDocumentReferenceServiceParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceServiceParameterList.GetItemN(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceParameterList.IndexOf(value: TFhirDocumentReferenceServiceParameter): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceServiceParameterList.Insert(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceParameterList.InsertItem(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceServiceParameterList.Item(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceParameterList.Link: TFhirDocumentReferenceServiceParameterList;
begin
  result := TFhirDocumentReferenceServiceParameterList(inherited Link);
end;

procedure TFhirDocumentReferenceServiceParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceServiceParameterList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  FhirDocumentReferenceServiceParameters[index] := value;
end;

procedure TFhirDocumentReferenceServiceParameterList.SetItemN(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContext }

constructor TFhirDocumentReferenceContext.Create;
begin
  inherited;
  FCodeList := TFhirCodeableConceptList.Create;
end;

destructor TFhirDocumentReferenceContext.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FFacilityType.free;
  inherited;
end;

procedure TFhirDocumentReferenceContext.Assign(oSource : TAdvObject);
begin
  inherited;
  FCodeList.Assign(TFhirDocumentReferenceContext(oSource).FCodeList);
  period := TFhirDocumentReferenceContext(oSource).period.Clone;
  facilityType := TFhirDocumentReferenceContext(oSource).facilityType.Clone;
end;

procedure TFhirDocumentReferenceContext.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.addAll(FCodeList);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'facilityType') Then
     list.add(FacilityType.Link);
end;

procedure TFhirDocumentReferenceContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facilityType', 'CodeableConcept', FFacilityType.Link.Link));{2}
end;

function TFhirDocumentReferenceContext.Link : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Link);
end;

function TFhirDocumentReferenceContext.Clone : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Clone);
end;

{ TFhirDocumentReferenceContext }

Procedure TFhirDocumentReferenceContext.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirDocumentReferenceContext.SetFacilityType(value : TFhirCodeableConcept);
begin
  FFacilityType.free;
  FFacilityType := value;
end;


{ TFhirDocumentReferenceContextList }
procedure TFhirDocumentReferenceContextList.AddItem(value: TFhirDocumentReferenceContext);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContext');
  add(value);
end;


function TFhirDocumentReferenceContextList.Append: TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceContextList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextList.Clone: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Clone);
end;

function TFhirDocumentReferenceContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextList.GetItemN(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.IndexOf(value: TFhirDocumentReferenceContext): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceContextList.Insert(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceContextList.InsertItem(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextList.Item(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.Link: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Link);
end;

procedure TFhirDocumentReferenceContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  FhirDocumentReferenceContexts[index] := value;
end;

procedure TFhirDocumentReferenceContextList.SetItemN(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterParticipant }

constructor TFhirEncounterParticipant.Create;
begin
  inherited;
  FType_ := TFHIREnumList.Create;
end;

destructor TFhirEncounterParticipant.Destroy;
begin
  FType_.Free;
  FPractitioner.free;
  inherited;
end;

procedure TFhirEncounterParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_.Assign(TFhirEncounterParticipant(oSource).FType_);
  practitioner := TFhirEncounterParticipant(oSource).practitioner.Clone;
end;

procedure TFhirEncounterParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.addAll(FType_);
  if (child_name = 'practitioner') Then
     list.add(Practitioner.Link);
end;

procedure TFhirEncounterParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link)){3};
  oList.add(TFHIRProperty.create(self, 'practitioner', 'Resource(Practitioner)', FPractitioner.Link.Link));{2}
end;

function TFhirEncounterParticipant.Link : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Link);
end;

function TFhirEncounterParticipant.Clone : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Clone);
end;

{ TFhirEncounterParticipant }

Function TFhirEncounterParticipant.GetType_ST : TFhirParticipantTypeList;
  var i : integer;
begin
  result := [];
  for i := 0 to type_.count - 1 do
    result := result + [TFhirParticipantType(StringArrayIndexOf(CODES_TFhirParticipantType, type_[i].value))];
end;

Procedure TFhirEncounterParticipant.SetType_ST(value : TFhirParticipantTypeList);
var a : TFhirParticipantType;
begin
  type_.clear;
  for a := low(TFhirParticipantType) to high(TFhirParticipantType) do
    if a in value then
      type_.add(TFhirEnum.create(CODES_TFhirParticipantType[a]));
end;

Procedure TFhirEncounterParticipant.SetPractitioner(value : TFhirResourceReference{TFhirPractitioner});
begin
  FPractitioner.free;
  FPractitioner := value;
end;


{ TFhirEncounterParticipantList }
procedure TFhirEncounterParticipantList.AddItem(value: TFhirEncounterParticipant);
begin
  assert(value.ClassName = 'TFhirEncounterParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterParticipant');
  add(value);
end;


function TFhirEncounterParticipantList.Append: TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterParticipantList.Clone: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Clone);
end;

function TFhirEncounterParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterParticipantList.GetItemN(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.IndexOf(value: TFhirEncounterParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterParticipantList.Insert(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterParticipantList.InsertItem(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  Inherited Insert(index, value);
end;

function TFhirEncounterParticipantList.Item(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.Link: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Link);
end;

procedure TFhirEncounterParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterParticipantList.SetItemByIndex(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  FhirEncounterParticipants[index] := value;
end;

procedure TFhirEncounterParticipantList.SetItemN(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalization }

constructor TFhirEncounterHospitalization.Create;
begin
  inherited;
  FAccomodationList := TFhirEncounterHospitalizationAccomodationList.Create;
  FSpecialCourtesyList := TFhirCodeableConceptList.Create;
  FSpecialArrangementList := TFhirCodeableConceptList.Create;
end;

destructor TFhirEncounterHospitalization.Destroy;
begin
  FPreAdmissionIdentifier.free;
  FOrigin.free;
  FAdmitSource.free;
  FPeriod.free;
  FAccomodationList.Free;
  FDiet.free;
  FSpecialCourtesyList.Free;
  FSpecialArrangementList.Free;
  FDestination.free;
  FDischargeDisposition.free;
  FReAdmission.free;
  inherited;
end;

procedure TFhirEncounterHospitalization.Assign(oSource : TAdvObject);
begin
  inherited;
  preAdmissionIdentifier := TFhirEncounterHospitalization(oSource).preAdmissionIdentifier.Clone;
  origin := TFhirEncounterHospitalization(oSource).origin.Clone;
  admitSource := TFhirEncounterHospitalization(oSource).admitSource.Clone;
  period := TFhirEncounterHospitalization(oSource).period.Clone;
  FAccomodationList.Assign(TFhirEncounterHospitalization(oSource).FAccomodationList);
  diet := TFhirEncounterHospitalization(oSource).diet.Clone;
  FSpecialCourtesyList.Assign(TFhirEncounterHospitalization(oSource).FSpecialCourtesyList);
  FSpecialArrangementList.Assign(TFhirEncounterHospitalization(oSource).FSpecialArrangementList);
  destination := TFhirEncounterHospitalization(oSource).destination.Clone;
  dischargeDisposition := TFhirEncounterHospitalization(oSource).dischargeDisposition.Clone;
  reAdmission := TFhirEncounterHospitalization(oSource).reAdmission.Clone;
end;

procedure TFhirEncounterHospitalization.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'preAdmissionIdentifier') Then
     list.add(PreAdmissionIdentifier.Link);
  if (child_name = 'origin') Then
     list.add(Origin.Link);
  if (child_name = 'admitSource') Then
     list.add(AdmitSource.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'accomodation') Then
     list.addAll(FAccomodationList);
  if (child_name = 'diet') Then
     list.add(Diet.Link);
  if (child_name = 'specialCourtesy') Then
     list.addAll(FSpecialCourtesyList);
  if (child_name = 'specialArrangement') Then
     list.addAll(FSpecialArrangementList);
  if (child_name = 'destination') Then
     list.add(Destination.Link);
  if (child_name = 'dischargeDisposition') Then
     list.add(DischargeDisposition.Link);
  if (child_name = 'reAdmission') Then
     list.add(ReAdmission.Link);
end;

procedure TFhirEncounterHospitalization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'preAdmissionIdentifier', 'Identifier', FPreAdmissionIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'origin', 'Resource(Location)', FOrigin.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'admitSource', 'CodeableConcept', FAdmitSource.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accomodation', '', FAccomodationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diet', 'CodeableConcept', FDiet.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specialCourtesy', 'CodeableConcept', FSpecialCourtesyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specialArrangement', 'CodeableConcept', FSpecialArrangementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dischargeDisposition', 'CodeableConcept', FDischargeDisposition.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reAdmission', 'boolean', FReAdmission.Link.Link));{2}
end;

function TFhirEncounterHospitalization.Link : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Link);
end;

function TFhirEncounterHospitalization.Clone : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Clone);
end;

{ TFhirEncounterHospitalization }

Procedure TFhirEncounterHospitalization.SetPreAdmissionIdentifier(value : TFhirIdentifier);
begin
  FPreAdmissionIdentifier.free;
  FPreAdmissionIdentifier := value;
end;

Procedure TFhirEncounterHospitalization.SetOrigin(value : TFhirResourceReference{TFhirLocation});
begin
  FOrigin.free;
  FOrigin := value;
end;

Procedure TFhirEncounterHospitalization.SetAdmitSource(value : TFhirCodeableConcept);
begin
  FAdmitSource.free;
  FAdmitSource := value;
end;

Procedure TFhirEncounterHospitalization.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirEncounterHospitalization.SetDiet(value : TFhirCodeableConcept);
begin
  FDiet.free;
  FDiet := value;
end;

Procedure TFhirEncounterHospitalization.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Procedure TFhirEncounterHospitalization.SetDischargeDisposition(value : TFhirCodeableConcept);
begin
  FDischargeDisposition.free;
  FDischargeDisposition := value;
end;

Procedure TFhirEncounterHospitalization.SetReAdmission(value : TFhirBoolean);
begin
  FReAdmission.free;
  FReAdmission := value;
end;

Function TFhirEncounterHospitalization.GetReAdmissionST : String;
begin
  if FReAdmission = nil then
    result := ''
  else
    result := ReAdmission.value;
end;

Procedure TFhirEncounterHospitalization.SetReAdmissionST(value : String);
begin
  if value <> '' then
  begin
    if FReAdmission = nil then
      FReAdmission := TFhirBoolean.create;
    FReAdmission.value := value
  end
  else if FReAdmission <> nil then
    FReAdmission.value := '';
end;


{ TFhirEncounterHospitalizationList }
procedure TFhirEncounterHospitalizationList.AddItem(value: TFhirEncounterHospitalization);
begin
  assert(value.ClassName = 'TFhirEncounterHospitalization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalization');
  add(value);
end;


function TFhirEncounterHospitalizationList.Append: TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationList.Clone: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Clone);
end;

function TFhirEncounterHospitalizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationList.GetItemN(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.IndexOf(value: TFhirEncounterHospitalization): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterHospitalizationList.Insert(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationList.InsertItem(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationList.Item(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.Link: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  FhirEncounterHospitalizations[index] := value;
end;

procedure TFhirEncounterHospitalizationList.SetItemN(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalizationAccomodation }

constructor TFhirEncounterHospitalizationAccomodation.Create;
begin
  inherited;
end;

destructor TFhirEncounterHospitalizationAccomodation.Destroy;
begin
  FBed.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterHospitalizationAccomodation.Assign(oSource : TAdvObject);
begin
  inherited;
  bed := TFhirEncounterHospitalizationAccomodation(oSource).bed.Clone;
  period := TFhirEncounterHospitalizationAccomodation(oSource).period.Clone;
end;

procedure TFhirEncounterHospitalizationAccomodation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'bed') Then
     list.add(Bed.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
end;

procedure TFhirEncounterHospitalizationAccomodation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'bed', 'Resource(Location)', FBed.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
end;

function TFhirEncounterHospitalizationAccomodation.Link : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(inherited Link);
end;

function TFhirEncounterHospitalizationAccomodation.Clone : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(inherited Clone);
end;

{ TFhirEncounterHospitalizationAccomodation }

Procedure TFhirEncounterHospitalizationAccomodation.SetBed(value : TFhirResourceReference{TFhirLocation});
begin
  FBed.free;
  FBed := value;
end;

Procedure TFhirEncounterHospitalizationAccomodation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirEncounterHospitalizationAccomodationList }
procedure TFhirEncounterHospitalizationAccomodationList.AddItem(value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value.ClassName = 'TFhirEncounterHospitalizationAccomodation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalizationAccomodation');
  add(value);
end;


function TFhirEncounterHospitalizationAccomodationList.Append: TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationAccomodationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationAccomodationList.Clone: TFhirEncounterHospitalizationAccomodationList;
begin
  result := TFhirEncounterHospitalizationAccomodationList(inherited Clone);
end;

function TFhirEncounterHospitalizationAccomodationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationAccomodationList.GetItemN(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationAccomodationList.IndexOf(value: TFhirEncounterHospitalizationAccomodation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterHospitalizationAccomodationList.Insert(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationAccomodationList.InsertItem(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationAccomodationList.Item(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationAccomodationList.Link: TFhirEncounterHospitalizationAccomodationList;
begin
  result := TFhirEncounterHospitalizationAccomodationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationAccomodationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationAccomodationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  FhirEncounterHospitalizationAccomodations[index] := value;
end;

procedure TFhirEncounterHospitalizationAccomodationList.SetItemN(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterLocation }

constructor TFhirEncounterLocation.Create;
begin
  inherited;
end;

destructor TFhirEncounterLocation.Destroy;
begin
  FLocation.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterLocation.Assign(oSource : TAdvObject);
begin
  inherited;
  location := TFhirEncounterLocation(oSource).location.Clone;
  period := TFhirEncounterLocation(oSource).period.Clone;
end;

procedure TFhirEncounterLocation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(Location.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
end;

procedure TFhirEncounterLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'location', 'Resource(Location)', FLocation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
end;

function TFhirEncounterLocation.Link : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Link);
end;

function TFhirEncounterLocation.Clone : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Clone);
end;

{ TFhirEncounterLocation }

Procedure TFhirEncounterLocation.SetLocation(value : TFhirResourceReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirEncounterLocation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirEncounterLocationList }
procedure TFhirEncounterLocationList.AddItem(value: TFhirEncounterLocation);
begin
  assert(value.ClassName = 'TFhirEncounterLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterLocation');
  add(value);
end;


function TFhirEncounterLocationList.Append: TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterLocationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterLocationList.Clone: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Clone);
end;

function TFhirEncounterLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterLocationList.GetItemN(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.IndexOf(value: TFhirEncounterLocation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterLocationList.Insert(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterLocationList.InsertItem(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  Inherited Insert(index, value);
end;

function TFhirEncounterLocationList.Item(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.Link: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Link);
end;

procedure TFhirEncounterLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterLocationList.SetItemByIndex(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  FhirEncounterLocations[index] := value;
end;

procedure TFhirEncounterLocationList.SetItemN(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyHistoryRelation }

constructor TFhirFamilyHistoryRelation.Create;
begin
  inherited;
  FConditionList := TFhirFamilyHistoryRelationConditionList.Create;
end;

destructor TFhirFamilyHistoryRelation.Destroy;
begin
  FName.free;
  FRelationship.free;
  FDeceased.free;
  FNote.free;
  FConditionList.Free;
  inherited;
end;

procedure TFhirFamilyHistoryRelation.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirFamilyHistoryRelation(oSource).name.Clone;
  relationship := TFhirFamilyHistoryRelation(oSource).relationship.Clone;
  deceased := TFhirFamilyHistoryRelation(oSource).deceased.Clone;
  note := TFhirFamilyHistoryRelation(oSource).note.Clone;
  FConditionList.Assign(TFhirFamilyHistoryRelation(oSource).FConditionList);
end;

procedure TFhirFamilyHistoryRelation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'relationship') Then
     list.add(Relationship.Link);
  if (child_name = 'deceased') Then
     list.add(Deceased.Link);
  if (child_name = 'note') Then
     list.add(Note.Link);
  if (child_name = 'condition') Then
     list.addAll(FConditionList);
end;

procedure TFhirFamilyHistoryRelation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', FRelationship.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|Age|Range|string', FDeceased.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', FNote.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', '', FConditionList.Link)){3};
end;

function TFhirFamilyHistoryRelation.Link : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(inherited Link);
end;

function TFhirFamilyHistoryRelation.Clone : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(inherited Clone);
end;

{ TFhirFamilyHistoryRelation }

Procedure TFhirFamilyHistoryRelation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirFamilyHistoryRelation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirFamilyHistoryRelation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirFamilyHistoryRelation.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirFamilyHistoryRelation.SetDeceased(value : TFhirType);
begin
  FDeceased.free;
  FDeceased := value;
end;

Procedure TFhirFamilyHistoryRelation.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirFamilyHistoryRelation.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := Note.value;
end;

Procedure TFhirFamilyHistoryRelation.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;


{ TFhirFamilyHistoryRelationList }
procedure TFhirFamilyHistoryRelationList.AddItem(value: TFhirFamilyHistoryRelation);
begin
  assert(value.ClassName = 'TFhirFamilyHistoryRelation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyHistoryRelation');
  add(value);
end;


function TFhirFamilyHistoryRelationList.Append: TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyHistoryRelationList.Clone: TFhirFamilyHistoryRelationList;
begin
  result := TFhirFamilyHistoryRelationList(inherited Clone);
end;

function TFhirFamilyHistoryRelationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyHistoryRelationList.GetItemN(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationList.IndexOf(value: TFhirFamilyHistoryRelation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirFamilyHistoryRelationList.Insert(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationList.InsertItem(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  Inherited Insert(index, value);
end;

function TFhirFamilyHistoryRelationList.Item(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationList.Link: TFhirFamilyHistoryRelationList;
begin
  result := TFhirFamilyHistoryRelationList(inherited Link);
end;

procedure TFhirFamilyHistoryRelationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyHistoryRelationList.SetItemByIndex(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  FhirFamilyHistoryRelations[index] := value;
end;

procedure TFhirFamilyHistoryRelationList.SetItemN(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyHistoryRelationCondition }

constructor TFhirFamilyHistoryRelationCondition.Create;
begin
  inherited;
end;

destructor TFhirFamilyHistoryRelationCondition.Destroy;
begin
  FType_.free;
  FOutcome.free;
  FOnset.free;
  FNote.free;
  inherited;
end;

procedure TFhirFamilyHistoryRelationCondition.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirFamilyHistoryRelationCondition(oSource).type_.Clone;
  outcome := TFhirFamilyHistoryRelationCondition(oSource).outcome.Clone;
  onset := TFhirFamilyHistoryRelationCondition(oSource).onset.Clone;
  note := TFhirFamilyHistoryRelationCondition(oSource).note.Clone;
end;

procedure TFhirFamilyHistoryRelationCondition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'outcome') Then
     list.add(Outcome.Link);
  if (child_name = 'onset') Then
     list.add(Onset.Link);
  if (child_name = 'note') Then
     list.add(Note.Link);
end;

procedure TFhirFamilyHistoryRelationCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', FOutcome.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'Age|Range|string', FOnset.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', FNote.Link.Link));{2}
end;

function TFhirFamilyHistoryRelationCondition.Link : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(inherited Link);
end;

function TFhirFamilyHistoryRelationCondition.Clone : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(inherited Clone);
end;

{ TFhirFamilyHistoryRelationCondition }

Procedure TFhirFamilyHistoryRelationCondition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirFamilyHistoryRelationCondition.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := Note.value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;


{ TFhirFamilyHistoryRelationConditionList }
procedure TFhirFamilyHistoryRelationConditionList.AddItem(value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value.ClassName = 'TFhirFamilyHistoryRelationCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyHistoryRelationCondition');
  add(value);
end;


function TFhirFamilyHistoryRelationConditionList.Append: TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationConditionList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyHistoryRelationConditionList.Clone: TFhirFamilyHistoryRelationConditionList;
begin
  result := TFhirFamilyHistoryRelationConditionList(inherited Clone);
end;

function TFhirFamilyHistoryRelationConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyHistoryRelationConditionList.GetItemN(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationConditionList.IndexOf(value: TFhirFamilyHistoryRelationCondition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirFamilyHistoryRelationConditionList.Insert(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationConditionList.InsertItem(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  Inherited Insert(index, value);
end;

function TFhirFamilyHistoryRelationConditionList.Item(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationConditionList.Link: TFhirFamilyHistoryRelationConditionList;
begin
  result := TFhirFamilyHistoryRelationConditionList(inherited Link);
end;

procedure TFhirFamilyHistoryRelationConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyHistoryRelationConditionList.SetItemByIndex(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  FhirFamilyHistoryRelationConditions[index] := value;
end;

procedure TFhirFamilyHistoryRelationConditionList.SetItemN(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirGroupCharacteristic }

constructor TFhirGroupCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirGroupCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  FExclude.free;
  inherited;
end;

procedure TFhirGroupCharacteristic.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirGroupCharacteristic(oSource).type_.Clone;
  value := TFhirGroupCharacteristic(oSource).value.Clone;
  exclude := TFhirGroupCharacteristic(oSource).exclude.Clone;
end;

procedure TFhirGroupCharacteristic.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
  if (child_name = 'exclude') Then
     list.add(Exclude.Link);
end;

procedure TFhirGroupCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|boolean|Quantity|Range', FValue.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', FExclude.Link.Link));{2}
end;

function TFhirGroupCharacteristic.Link : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Link);
end;

function TFhirGroupCharacteristic.Clone : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Clone);
end;

{ TFhirGroupCharacteristic }

Procedure TFhirGroupCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirGroupCharacteristic.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirGroupCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

Function TFhirGroupCharacteristic.GetExcludeST : String;
begin
  if FExclude = nil then
    result := ''
  else
    result := Exclude.value;
end;

Procedure TFhirGroupCharacteristic.SetExcludeST(value : String);
begin
  if value <> '' then
  begin
    if FExclude = nil then
      FExclude := TFhirBoolean.create;
    FExclude.value := value
  end
  else if FExclude <> nil then
    FExclude.value := '';
end;


{ TFhirGroupCharacteristicList }
procedure TFhirGroupCharacteristicList.AddItem(value: TFhirGroupCharacteristic);
begin
  assert(value.ClassName = 'TFhirGroupCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupCharacteristic');
  add(value);
end;


function TFhirGroupCharacteristicList.Append: TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirGroupCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirGroupCharacteristicList.Clone: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Clone);
end;

function TFhirGroupCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupCharacteristicList.GetItemN(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.IndexOf(value: TFhirGroupCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirGroupCharacteristicList.Insert(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirGroupCharacteristicList.InsertItem(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirGroupCharacteristicList.Item(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.Link: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Link);
end;

procedure TFhirGroupCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupCharacteristicList.SetItemByIndex(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  FhirGroupCharacteristics[index] := value;
end;

procedure TFhirGroupCharacteristicList.SetItemN(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeries }

constructor TFhirImagingStudySeries.Create;
begin
  inherited;
  FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
end;

destructor TFhirImagingStudySeries.Destroy;
begin
  FNumber.free;
  FModality.free;
  FUid.free;
  FDescription.free;
  FNumberOfInstances.free;
  FAvailability.free;
  FUrl.free;
  FBodySite.free;
  FDateTime.free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingStudySeries.Assign(oSource : TAdvObject);
begin
  inherited;
  number := TFhirImagingStudySeries(oSource).number.Clone;
  FModality := TFhirImagingStudySeries(oSource).FModality.Link;
  uid := TFhirImagingStudySeries(oSource).uid.Clone;
  description := TFhirImagingStudySeries(oSource).description.Clone;
  numberOfInstances := TFhirImagingStudySeries(oSource).numberOfInstances.Clone;
  FAvailability := TFhirImagingStudySeries(oSource).FAvailability.Link;
  url := TFhirImagingStudySeries(oSource).url.Clone;
  bodySite := TFhirImagingStudySeries(oSource).bodySite.Clone;
  dateTime := TFhirImagingStudySeries(oSource).dateTime.Clone;
  FInstanceList.Assign(TFhirImagingStudySeries(oSource).FInstanceList);
end;

procedure TFhirImagingStudySeries.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(Number.Link);
  if (child_name = 'modality') Then
     list.add(FModality.Link);
  if (child_name = 'uid') Then
     list.add(Uid.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(NumberOfInstances.Link);
  if (child_name = 'availability') Then
     list.add(FAvailability.Link);
  if (child_name = 'url') Then
     list.add(Url.Link);
  if (child_name = 'bodySite') Then
     list.add(BodySite.Link);
  if (child_name = 'dateTime') Then
     list.add(DateTime.Link);
  if (child_name = 'instance') Then
     list.addAll(FInstanceList);
end;

procedure TFhirImagingStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'integer', FNumber.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modality', 'code', FModality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', FUid.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'integer', FNumberOfInstances.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'availability', 'code', FAvailability.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', FBodySite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', FDateTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instance', '', FInstanceList.Link)){3};
end;

function TFhirImagingStudySeries.Link : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Link);
end;

function TFhirImagingStudySeries.Clone : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Clone);
end;

{ TFhirImagingStudySeries }

Procedure TFhirImagingStudySeries.SetNumber(value : TFhirInteger);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeries.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := Number.value;
end;

Procedure TFhirImagingStudySeries.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirInteger.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeries.SetModality(value : TFhirEnum);
begin
  FModality.free;
  FModality := value;
end;

Function TFhirImagingStudySeries.GetModalityST : TFhirModality;
begin
  if FModality = nil then
    result := TFhirModality(0)
  else
    result := TFhirModality(StringArrayIndexOf(CODES_TFhirModality, Modality.value));
end;

Procedure TFhirImagingStudySeries.SetModalityST(value : TFhirModality);
begin
  if ord(value) = 0 then
    Modality := nil
  else
    Modality := TFhirEnum.create(CODES_TFhirModality[value]);
end;

Procedure TFhirImagingStudySeries.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := Uid.value;
end;

Procedure TFhirImagingStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeries.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingStudySeries.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirImagingStudySeries.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstances(value : TFhirInteger);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

Function TFhirImagingStudySeries.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := NumberOfInstances.value;
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirInteger.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

Procedure TFhirImagingStudySeries.SetAvailability(value : TFhirEnum);
begin
  FAvailability.free;
  FAvailability := value;
end;

Function TFhirImagingStudySeries.GetAvailabilityST : TFhirInstanceAvailability;
begin
  if FAvailability = nil then
    result := TFhirInstanceAvailability(0)
  else
    result := TFhirInstanceAvailability(StringArrayIndexOf(CODES_TFhirInstanceAvailability, Availability.value));
end;

Procedure TFhirImagingStudySeries.SetAvailabilityST(value : TFhirInstanceAvailability);
begin
  if ord(value) = 0 then
    Availability := nil
  else
    Availability := TFhirEnum.create(CODES_TFhirInstanceAvailability[value]);
end;

Procedure TFhirImagingStudySeries.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudySeries.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := Url.value;
end;

Procedure TFhirImagingStudySeries.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudySeries.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirImagingStudySeries.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirImagingStudySeries.GetDateTimeST : TDateAndTime;
begin
  if FDateTime = nil then
    result := nil
  else
    result := DateTime.value;
end;

Procedure TFhirImagingStudySeries.SetDateTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirDateTime.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;


{ TFhirImagingStudySeriesList }
procedure TFhirImagingStudySeriesList.AddItem(value: TFhirImagingStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeries');
  add(value);
end;


function TFhirImagingStudySeriesList.Append: TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesList.Clone: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Clone);
end;

function TFhirImagingStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesList.GetItemN(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.IndexOf(value: TFhirImagingStudySeries): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImagingStudySeriesList.Insert(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesList.InsertItem(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesList.Item(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.Link: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Link);
end;

procedure TFhirImagingStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  FhirImagingStudySeries[index] := value;
end;

procedure TFhirImagingStudySeriesList.SetItemN(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesInstance }

constructor TFhirImagingStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesInstance.Destroy;
begin
  FNumber.free;
  FUid.free;
  FSopclass.free;
  FType_.free;
  FTitle.free;
  FUrl.free;
  FAttachment.free;
  inherited;
end;

procedure TFhirImagingStudySeriesInstance.Assign(oSource : TAdvObject);
begin
  inherited;
  number := TFhirImagingStudySeriesInstance(oSource).number.Clone;
  uid := TFhirImagingStudySeriesInstance(oSource).uid.Clone;
  sopclass := TFhirImagingStudySeriesInstance(oSource).sopclass.Clone;
  type_ := TFhirImagingStudySeriesInstance(oSource).type_.Clone;
  title := TFhirImagingStudySeriesInstance(oSource).title.Clone;
  url := TFhirImagingStudySeriesInstance(oSource).url.Clone;
  attachment := TFhirImagingStudySeriesInstance(oSource).attachment.Clone;
end;

procedure TFhirImagingStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(Number.Link);
  if (child_name = 'uid') Then
     list.add(Uid.Link);
  if (child_name = 'sopclass') Then
     list.add(Sopclass.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'title') Then
     list.add(Title.Link);
  if (child_name = 'url') Then
     list.add(Url.Link);
  if (child_name = 'attachment') Then
     list.add(Attachment.Link);
end;

procedure TFhirImagingStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'integer', FNumber.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', FUid.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sopclass', 'oid', FSopclass.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'string', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', FTitle.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'attachment', 'Resource(Any)', FAttachment.Link.Link));{2}
end;

function TFhirImagingStudySeriesInstance.Link : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Link);
end;

function TFhirImagingStudySeriesInstance.Clone : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Clone);
end;

{ TFhirImagingStudySeriesInstance }

Procedure TFhirImagingStudySeriesInstance.SetNumber(value : TFhirInteger);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeriesInstance.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := Number.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirInteger.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := Uid.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetSopclass(value : TFhirOid);
begin
  FSopclass.free;
  FSopclass := value;
end;

Function TFhirImagingStudySeriesInstance.GetSopclassST : String;
begin
  if FSopclass = nil then
    result := ''
  else
    result := Sopclass.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetSopclassST(value : String);
begin
  if value <> '' then
  begin
    if FSopclass = nil then
      FSopclass := TFhirOid.create;
    FSopclass.value := value
  end
  else if FSopclass <> nil then
    FSopclass.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImagingStudySeriesInstance.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirImagingStudySeriesInstance.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := Title.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudySeriesInstance.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := Url.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetAttachment(value : TFhirResourceReference{Resource});
begin
  FAttachment.free;
  FAttachment := value;
end;


{ TFhirImagingStudySeriesInstanceList }
procedure TFhirImagingStudySeriesInstanceList.AddItem(value: TFhirImagingStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesInstance');
  add(value);
end;


function TFhirImagingStudySeriesInstanceList.Append: TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesInstanceList.Clone: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.IndexOf(value: TFhirImagingStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImagingStudySeriesInstanceList.Insert(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesInstanceList.Item(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.Link: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  FhirImagingStudySeriesInstances[index] := value;
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationExplanation }

constructor TFhirImmunizationExplanation.Create;
begin
  inherited;
  FReasonList := TFhirCodeableConceptList.Create;
  FRefusalReasonList := TFhirCodeableConceptList.Create;
end;

destructor TFhirImmunizationExplanation.Destroy;
begin
  FReasonList.Free;
  FRefusalReasonList.Free;
  inherited;
end;

procedure TFhirImmunizationExplanation.Assign(oSource : TAdvObject);
begin
  inherited;
  FReasonList.Assign(TFhirImmunizationExplanation(oSource).FReasonList);
  FRefusalReasonList.Assign(TFhirImmunizationExplanation(oSource).FRefusalReasonList);
end;

procedure TFhirImmunizationExplanation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'reason') Then
     list.addAll(FReasonList);
  if (child_name = 'refusalReason') Then
     list.addAll(FRefusalReasonList);
end;

procedure TFhirImmunizationExplanation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'refusalReason', 'CodeableConcept', FRefusalReasonList.Link)){3};
end;

function TFhirImmunizationExplanation.Link : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Link);
end;

function TFhirImmunizationExplanation.Clone : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Clone);
end;

{ TFhirImmunizationExplanation }


{ TFhirImmunizationExplanationList }
procedure TFhirImmunizationExplanationList.AddItem(value: TFhirImmunizationExplanation);
begin
  assert(value.ClassName = 'TFhirImmunizationExplanation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationExplanation');
  add(value);
end;


function TFhirImmunizationExplanationList.Append: TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationExplanationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationExplanationList.Clone: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Clone);
end;

function TFhirImmunizationExplanationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationExplanationList.GetItemN(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.IndexOf(value: TFhirImmunizationExplanation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationExplanationList.Insert(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationExplanationList.InsertItem(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationExplanationList.Item(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.Link: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Link);
end;

procedure TFhirImmunizationExplanationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationExplanationList.SetItemByIndex(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  FhirImmunizationExplanations[index] := value;
end;

procedure TFhirImmunizationExplanationList.SetItemN(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationReaction }

constructor TFhirImmunizationReaction.Create;
begin
  inherited;
end;

destructor TFhirImmunizationReaction.Destroy;
begin
  FDate.free;
  FDetail.free;
  FReported.free;
  inherited;
end;

procedure TFhirImmunizationReaction.Assign(oSource : TAdvObject);
begin
  inherited;
  date := TFhirImmunizationReaction(oSource).date.Clone;
  detail := TFhirImmunizationReaction(oSource).detail.Clone;
  reported := TFhirImmunizationReaction(oSource).reported.Clone;
end;

procedure TFhirImmunizationReaction.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(Date.Link);
  if (child_name = 'detail') Then
     list.add(Detail.Link);
  if (child_name = 'reported') Then
     list.add(Reported.Link);
end;

procedure TFhirImmunizationReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(AdverseReaction|Observation)', FDetail.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', FReported.Link.Link));{2}
end;

function TFhirImmunizationReaction.Link : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Link);
end;

function TFhirImmunizationReaction.Clone : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Clone);
end;

{ TFhirImmunizationReaction }

Procedure TFhirImmunizationReaction.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationReaction.GetDateST : TDateAndTime;
begin
  if FDate = nil then
    result := nil
  else
    result := Date.value;
end;

Procedure TFhirImmunizationReaction.SetDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirImmunizationReaction.SetDetail(value : TFhirResourceReference{Resource});
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirImmunizationReaction.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value;
end;

Function TFhirImmunizationReaction.GetReportedST : String;
begin
  if FReported = nil then
    result := ''
  else
    result := Reported.value;
end;

Procedure TFhirImmunizationReaction.SetReportedST(value : String);
begin
  if value <> '' then
  begin
    if FReported = nil then
      FReported := TFhirBoolean.create;
    FReported.value := value
  end
  else if FReported <> nil then
    FReported.value := '';
end;


{ TFhirImmunizationReactionList }
procedure TFhirImmunizationReactionList.AddItem(value: TFhirImmunizationReaction);
begin
  assert(value.ClassName = 'TFhirImmunizationReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationReaction');
  add(value);
end;


function TFhirImmunizationReactionList.Append: TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationReactionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationReactionList.Clone: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Clone);
end;

function TFhirImmunizationReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationReactionList.GetItemN(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.IndexOf(value: TFhirImmunizationReaction): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationReactionList.Insert(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationReactionList.InsertItem(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  Inherited Insert(index, value);
end;

function TFhirImmunizationReactionList.Item(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.Link: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Link);
end;

procedure TFhirImmunizationReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationReactionList.SetItemByIndex(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  FhirImmunizationReactions[index] := value;
end;

procedure TFhirImmunizationReactionList.SetItemN(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationVaccinationProtocol }

constructor TFhirImmunizationVaccinationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationVaccinationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  FSeriesDoses.free;
  FDoseTarget.free;
  FDoseStatus.free;
  FDoseStatusReason.free;
  inherited;
end;

procedure TFhirImmunizationVaccinationProtocol.Assign(oSource : TAdvObject);
begin
  inherited;
  doseSequence := TFhirImmunizationVaccinationProtocol(oSource).doseSequence.Clone;
  description := TFhirImmunizationVaccinationProtocol(oSource).description.Clone;
  authority := TFhirImmunizationVaccinationProtocol(oSource).authority.Clone;
  series := TFhirImmunizationVaccinationProtocol(oSource).series.Clone;
  seriesDoses := TFhirImmunizationVaccinationProtocol(oSource).seriesDoses.Clone;
  doseTarget := TFhirImmunizationVaccinationProtocol(oSource).doseTarget.Clone;
  doseStatus := TFhirImmunizationVaccinationProtocol(oSource).doseStatus.Clone;
  doseStatusReason := TFhirImmunizationVaccinationProtocol(oSource).doseStatusReason.Clone;
end;

procedure TFhirImmunizationVaccinationProtocol.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(DoseSequence.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'authority') Then
     list.add(Authority.Link);
  if (child_name = 'series') Then
     list.add(Series.Link);
  if (child_name = 'seriesDoses') Then
     list.add(SeriesDoses.Link);
  if (child_name = 'doseTarget') Then
     list.add(DoseTarget.Link);
  if (child_name = 'doseStatus') Then
     list.add(DoseStatus.Link);
  if (child_name = 'doseStatusReason') Then
     list.add(DoseStatusReason.Link);
end;

procedure TFhirImmunizationVaccinationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'integer', FDoseSequence.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Resource(Organization)', FAuthority.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', FSeries.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'integer', FSeriesDoses.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseTarget', 'CodeableConcept', FDoseTarget.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatus', 'CodeableConcept', FDoseStatus.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatusReason', 'CodeableConcept', FDoseStatusReason.Link.Link));{2}
end;

function TFhirImmunizationVaccinationProtocol.Link : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Link);
end;

function TFhirImmunizationVaccinationProtocol.Clone : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Clone);
end;

{ TFhirImmunizationVaccinationProtocol }

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequence(value : TFhirInteger);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := DoseSequence.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirInteger.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetAuthority(value : TFhirResourceReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := Series.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDoses(value : TFhirInteger);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := SeriesDoses.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirInteger.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseTarget(value : TFhirCodeableConcept);
begin
  FDoseTarget.free;
  FDoseTarget := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatus(value : TFhirCodeableConcept);
begin
  FDoseStatus.free;
  FDoseStatus := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatusReason(value : TFhirCodeableConcept);
begin
  FDoseStatusReason.free;
  FDoseStatusReason := value;
end;


{ TFhirImmunizationVaccinationProtocolList }
procedure TFhirImmunizationVaccinationProtocolList.AddItem(value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationVaccinationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationVaccinationProtocol');
  add(value);
end;


function TFhirImmunizationVaccinationProtocolList.Append: TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationVaccinationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationVaccinationProtocolList.Clone: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Clone);
end;

function TFhirImmunizationVaccinationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationVaccinationProtocolList.GetItemN(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.IndexOf(value: TFhirImmunizationVaccinationProtocol): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationVaccinationProtocolList.Insert(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationVaccinationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationVaccinationProtocolList.Item(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.Link: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Link);
end;

procedure TFhirImmunizationVaccinationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  FhirImmunizationVaccinationProtocols[index] := value;
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationProfileRecommendation }

constructor TFhirImmunizationProfileRecommendation.Create;
begin
  inherited;
  FDateCriterionList := TFhirImmunizationProfileRecommendationDateCriterionList.Create;
  FSupportingImmunizationList := TFhirResourceReferenceList{TFhirImmunization}.Create;
  FSupportingAdverseEventReportList := TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Create;
  FSupportingPatientObservationList := TFhirResourceReferenceList{TFhirObservation}.Create;
end;

destructor TFhirImmunizationProfileRecommendation.Destroy;
begin
  FRecommendationDate.free;
  FVaccineType.free;
  FDoseNumber.free;
  FForecastStatus.free;
  FDateCriterionList.Free;
  FProtocol.free;
  FSupportingImmunizationList.Free;
  FSupportingAdverseEventReportList.Free;
  FSupportingPatientObservationList.Free;
  inherited;
end;

procedure TFhirImmunizationProfileRecommendation.Assign(oSource : TAdvObject);
begin
  inherited;
  recommendationDate := TFhirImmunizationProfileRecommendation(oSource).recommendationDate.Clone;
  vaccineType := TFhirImmunizationProfileRecommendation(oSource).vaccineType.Clone;
  doseNumber := TFhirImmunizationProfileRecommendation(oSource).doseNumber.Clone;
  FForecastStatus := TFhirImmunizationProfileRecommendation(oSource).FForecastStatus.Link;
  FDateCriterionList.Assign(TFhirImmunizationProfileRecommendation(oSource).FDateCriterionList);
  protocol := TFhirImmunizationProfileRecommendation(oSource).protocol.Clone;
  FSupportingImmunizationList.Assign(TFhirImmunizationProfileRecommendation(oSource).FSupportingImmunizationList);
  FSupportingAdverseEventReportList.Assign(TFhirImmunizationProfileRecommendation(oSource).FSupportingAdverseEventReportList);
  FSupportingPatientObservationList.Assign(TFhirImmunizationProfileRecommendation(oSource).FSupportingPatientObservationList);
end;

procedure TFhirImmunizationProfileRecommendation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'recommendationDate') Then
     list.add(RecommendationDate.Link);
  if (child_name = 'vaccineType') Then
     list.add(VaccineType.Link);
  if (child_name = 'doseNumber') Then
     list.add(DoseNumber.Link);
  if (child_name = 'forecastStatus') Then
     list.add(FForecastStatus.Link);
  if (child_name = 'dateCriterion') Then
     list.addAll(FDateCriterionList);
  if (child_name = 'protocol') Then
     list.add(Protocol.Link);
  if (child_name = 'supportingImmunization') Then
     list.addAll(FSupportingImmunizationList);
  if (child_name = 'supportingAdverseEventReport') Then
     list.addAll(FSupportingAdverseEventReportList);
  if (child_name = 'supportingPatientObservation') Then
     list.addAll(FSupportingPatientObservationList);
end;

procedure TFhirImmunizationProfileRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'recommendationDate', 'dateTime', FRecommendationDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'vaccineType', 'CodeableConcept', FVaccineType.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'integer', FDoseNumber.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'forecastStatus', 'code', FForecastStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'dateCriterion', '', FDateCriterionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'protocol', '', FProtocol.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingImmunization', 'Resource(Immunization)', FSupportingImmunizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingAdverseEventReport', '', FSupportingAdverseEventReportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingPatientObservation', 'Resource(Observation)', FSupportingPatientObservationList.Link)){3};
end;

function TFhirImmunizationProfileRecommendation.Link : TFhirImmunizationProfileRecommendation;
begin
  result := TFhirImmunizationProfileRecommendation(inherited Link);
end;

function TFhirImmunizationProfileRecommendation.Clone : TFhirImmunizationProfileRecommendation;
begin
  result := TFhirImmunizationProfileRecommendation(inherited Clone);
end;

{ TFhirImmunizationProfileRecommendation }

Procedure TFhirImmunizationProfileRecommendation.SetRecommendationDate(value : TFhirDateTime);
begin
  FRecommendationDate.free;
  FRecommendationDate := value;
end;

Function TFhirImmunizationProfileRecommendation.GetRecommendationDateST : TDateAndTime;
begin
  if FRecommendationDate = nil then
    result := nil
  else
    result := RecommendationDate.value;
end;

Procedure TFhirImmunizationProfileRecommendation.SetRecommendationDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FRecommendationDate = nil then
      FRecommendationDate := TFhirDateTime.create;
    FRecommendationDate.value := value
  end
  else if FRecommendationDate <> nil then
    FRecommendationDate.value := nil;
end;

Procedure TFhirImmunizationProfileRecommendation.SetVaccineType(value : TFhirCodeableConcept);
begin
  FVaccineType.free;
  FVaccineType := value;
end;

Procedure TFhirImmunizationProfileRecommendation.SetDoseNumber(value : TFhirInteger);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

Function TFhirImmunizationProfileRecommendation.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := DoseNumber.value;
end;

Procedure TFhirImmunizationProfileRecommendation.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirInteger.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

Procedure TFhirImmunizationProfileRecommendation.SetForecastStatus(value : TFhirEnum);
begin
  FForecastStatus.free;
  FForecastStatus := value;
end;

Function TFhirImmunizationProfileRecommendation.GetForecastStatusST : TFhirImmunizationForecastStatus;
begin
  if FForecastStatus = nil then
    result := TFhirImmunizationForecastStatus(0)
  else
    result := TFhirImmunizationForecastStatus(StringArrayIndexOf(CODES_TFhirImmunizationForecastStatus, ForecastStatus.value));
end;

Procedure TFhirImmunizationProfileRecommendation.SetForecastStatusST(value : TFhirImmunizationForecastStatus);
begin
  if ord(value) = 0 then
    ForecastStatus := nil
  else
    ForecastStatus := TFhirEnum.create(CODES_TFhirImmunizationForecastStatus[value]);
end;

Procedure TFhirImmunizationProfileRecommendation.SetProtocol(value : TFhirImmunizationProfileRecommendationProtocol);
begin
  FProtocol.free;
  FProtocol := value;
end;


{ TFhirImmunizationProfileRecommendationList }
procedure TFhirImmunizationProfileRecommendationList.AddItem(value: TFhirImmunizationProfileRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationProfileRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationProfileRecommendation');
  add(value);
end;


function TFhirImmunizationProfileRecommendationList.Append: TFhirImmunizationProfileRecommendation;
begin
  result := TFhirImmunizationProfileRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationProfileRecommendationList.Clone: TFhirImmunizationProfileRecommendationList;
begin
  result := TFhirImmunizationProfileRecommendationList(inherited Clone);
end;

function TFhirImmunizationProfileRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationProfileRecommendationList.GetItemN(index: Integer): TFhirImmunizationProfileRecommendation;
begin
  result := TFhirImmunizationProfileRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationList.IndexOf(value: TFhirImmunizationProfileRecommendation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationProfileRecommendationList.Insert(index: Integer): TFhirImmunizationProfileRecommendation;
begin
  result := TFhirImmunizationProfileRecommendation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationProfileRecommendation);
begin
  assert(value is TFhirImmunizationProfileRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationProfileRecommendationList.Item(index: Integer): TFhirImmunizationProfileRecommendation;
begin
  result := TFhirImmunizationProfileRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationList.Link: TFhirImmunizationProfileRecommendationList;
begin
  result := TFhirImmunizationProfileRecommendationList(inherited Link);
end;

procedure TFhirImmunizationProfileRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationProfileRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationProfileRecommendation);
begin
  assert(value is TFhirImmunizationProfileRecommendation);
  FhirImmunizationProfileRecommendations[index] := value;
end;

procedure TFhirImmunizationProfileRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationProfileRecommendation);
begin
  assert(value is TFhirImmunizationProfileRecommendation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationProfileRecommendationDateCriterion }

constructor TFhirImmunizationProfileRecommendationDateCriterion.Create;
begin
  inherited;
end;

destructor TFhirImmunizationProfileRecommendationDateCriterion.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImmunizationProfileRecommendationDateCriterion.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirImmunizationProfileRecommendationDateCriterion(oSource).code.Clone;
  value := TFhirImmunizationProfileRecommendationDateCriterion(oSource).value.Clone;
end;

procedure TFhirImmunizationProfileRecommendationDateCriterion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirImmunizationProfileRecommendationDateCriterion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'dateTime', FValue.Link.Link));{2}
end;

function TFhirImmunizationProfileRecommendationDateCriterion.Link : TFhirImmunizationProfileRecommendationDateCriterion;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterion(inherited Link);
end;

function TFhirImmunizationProfileRecommendationDateCriterion.Clone : TFhirImmunizationProfileRecommendationDateCriterion;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterion(inherited Clone);
end;

{ TFhirImmunizationProfileRecommendationDateCriterion }

Procedure TFhirImmunizationProfileRecommendationDateCriterion.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirImmunizationProfileRecommendationDateCriterion.SetValue(value : TFhirDateTime);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirImmunizationProfileRecommendationDateCriterion.GetValueST : TDateAndTime;
begin
  if FValue = nil then
    result := nil
  else
    result := Value.value;
end;

Procedure TFhirImmunizationProfileRecommendationDateCriterion.SetValueST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FValue = nil then
      FValue := TFhirDateTime.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := nil;
end;


{ TFhirImmunizationProfileRecommendationDateCriterionList }
procedure TFhirImmunizationProfileRecommendationDateCriterionList.AddItem(value: TFhirImmunizationProfileRecommendationDateCriterion);
begin
  assert(value.ClassName = 'TFhirImmunizationProfileRecommendationDateCriterion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationProfileRecommendationDateCriterion');
  add(value);
end;


function TFhirImmunizationProfileRecommendationDateCriterionList.Append: TFhirImmunizationProfileRecommendationDateCriterion;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationDateCriterionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationProfileRecommendationDateCriterionList.Clone: TFhirImmunizationProfileRecommendationDateCriterionList;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterionList(inherited Clone);
end;

function TFhirImmunizationProfileRecommendationDateCriterionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationProfileRecommendationDateCriterionList.GetItemN(index: Integer): TFhirImmunizationProfileRecommendationDateCriterion;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationDateCriterionList.IndexOf(value: TFhirImmunizationProfileRecommendationDateCriterion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationProfileRecommendationDateCriterionList.Insert(index: Integer): TFhirImmunizationProfileRecommendationDateCriterion;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationDateCriterionList.InsertItem(index: Integer; value: TFhirImmunizationProfileRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationProfileRecommendationDateCriterion);
  Inherited Insert(index, value);
end;

function TFhirImmunizationProfileRecommendationDateCriterionList.Item(index: Integer): TFhirImmunizationProfileRecommendationDateCriterion;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationDateCriterionList.Link: TFhirImmunizationProfileRecommendationDateCriterionList;
begin
  result := TFhirImmunizationProfileRecommendationDateCriterionList(inherited Link);
end;

procedure TFhirImmunizationProfileRecommendationDateCriterionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationProfileRecommendationDateCriterionList.SetItemByIndex(index: Integer; value: TFhirImmunizationProfileRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationProfileRecommendationDateCriterion);
  FhirImmunizationProfileRecommendationDateCriterions[index] := value;
end;

procedure TFhirImmunizationProfileRecommendationDateCriterionList.SetItemN(index: Integer; value: TFhirImmunizationProfileRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationProfileRecommendationDateCriterion);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationProfileRecommendationProtocol }

constructor TFhirImmunizationProfileRecommendationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationProfileRecommendationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  inherited;
end;

procedure TFhirImmunizationProfileRecommendationProtocol.Assign(oSource : TAdvObject);
begin
  inherited;
  doseSequence := TFhirImmunizationProfileRecommendationProtocol(oSource).doseSequence.Clone;
  description := TFhirImmunizationProfileRecommendationProtocol(oSource).description.Clone;
  authority := TFhirImmunizationProfileRecommendationProtocol(oSource).authority.Clone;
  series := TFhirImmunizationProfileRecommendationProtocol(oSource).series.Clone;
end;

procedure TFhirImmunizationProfileRecommendationProtocol.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(DoseSequence.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'authority') Then
     list.add(Authority.Link);
  if (child_name = 'series') Then
     list.add(Series.Link);
end;

procedure TFhirImmunizationProfileRecommendationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'integer', FDoseSequence.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Resource(Organization)', FAuthority.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', FSeries.Link.Link));{2}
end;

function TFhirImmunizationProfileRecommendationProtocol.Link : TFhirImmunizationProfileRecommendationProtocol;
begin
  result := TFhirImmunizationProfileRecommendationProtocol(inherited Link);
end;

function TFhirImmunizationProfileRecommendationProtocol.Clone : TFhirImmunizationProfileRecommendationProtocol;
begin
  result := TFhirImmunizationProfileRecommendationProtocol(inherited Clone);
end;

{ TFhirImmunizationProfileRecommendationProtocol }

Procedure TFhirImmunizationProfileRecommendationProtocol.SetDoseSequence(value : TFhirInteger);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationProfileRecommendationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := DoseSequence.value;
end;

Procedure TFhirImmunizationProfileRecommendationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirInteger.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationProfileRecommendationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationProfileRecommendationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirImmunizationProfileRecommendationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationProfileRecommendationProtocol.SetAuthority(value : TFhirResourceReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationProfileRecommendationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationProfileRecommendationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := Series.value;
end;

Procedure TFhirImmunizationProfileRecommendationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;


{ TFhirImmunizationProfileRecommendationProtocolList }
procedure TFhirImmunizationProfileRecommendationProtocolList.AddItem(value: TFhirImmunizationProfileRecommendationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationProfileRecommendationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationProfileRecommendationProtocol');
  add(value);
end;


function TFhirImmunizationProfileRecommendationProtocolList.Append: TFhirImmunizationProfileRecommendationProtocol;
begin
  result := TFhirImmunizationProfileRecommendationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationProfileRecommendationProtocolList.Clone: TFhirImmunizationProfileRecommendationProtocolList;
begin
  result := TFhirImmunizationProfileRecommendationProtocolList(inherited Clone);
end;

function TFhirImmunizationProfileRecommendationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationProfileRecommendationProtocolList.GetItemN(index: Integer): TFhirImmunizationProfileRecommendationProtocol;
begin
  result := TFhirImmunizationProfileRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationProtocolList.IndexOf(value: TFhirImmunizationProfileRecommendationProtocol): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationProfileRecommendationProtocolList.Insert(index: Integer): TFhirImmunizationProfileRecommendationProtocol;
begin
  result := TFhirImmunizationProfileRecommendationProtocol.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationProfileRecommendationProtocol);
begin
  assert(value is TFhirImmunizationProfileRecommendationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationProfileRecommendationProtocolList.Item(index: Integer): TFhirImmunizationProfileRecommendationProtocol;
begin
  result := TFhirImmunizationProfileRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationProtocolList.Link: TFhirImmunizationProfileRecommendationProtocolList;
begin
  result := TFhirImmunizationProfileRecommendationProtocolList(inherited Link);
end;

procedure TFhirImmunizationProfileRecommendationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationProfileRecommendationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationProfileRecommendationProtocol);
begin
  assert(value is TFhirImmunizationProfileRecommendationProtocol);
  FhirImmunizationProfileRecommendationProtocols[index] := value;
end;

procedure TFhirImmunizationProfileRecommendationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationProfileRecommendationProtocol);
begin
  assert(value is TFhirImmunizationProfileRecommendationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationProfileRecommendationSupportingAdverseEventReport }

constructor TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.Create;
begin
  inherited;
  FIdentifierList := TFhirIdList.Create;
  FReactionList := TFhirResourceReferenceList{TFhirAdverseReaction}.Create;
end;

destructor TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.Destroy;
begin
  FIdentifierList.Free;
  FReportType.free;
  FReportDate.free;
  FText.free;
  FReactionList.Free;
  inherited;
end;

procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.Assign(oSource : TAdvObject);
begin
  inherited;
  FIdentifierList.Assign(TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(oSource).FIdentifierList);
  reportType := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(oSource).reportType.Clone;
  reportDate := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(oSource).reportDate.Clone;
  text := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(oSource).text.Clone;
  FReactionList.Assign(TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(oSource).FReactionList);
end;

procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.addAll(FIdentifierList);
  if (child_name = 'reportType') Then
     list.add(ReportType.Link);
  if (child_name = 'reportDate') Then
     list.add(ReportDate.Link);
  if (child_name = 'text') Then
     list.add(Text.Link);
  if (child_name = 'reaction') Then
     list.addAll(FReactionList);
end;

procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reportType', 'CodeableConcept', FReportType.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reportDate', 'dateTime', FReportDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reaction', 'Resource(AdverseReaction)', FReactionList.Link)){3};
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.Link : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(inherited Link);
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.Clone : TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(inherited Clone);
end;

{ TFhirImmunizationProfileRecommendationSupportingAdverseEventReport }

Procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.SetReportType(value : TFhirCodeableConcept);
begin
  FReportType.free;
  FReportType := value;
end;

Procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.SetReportDate(value : TFhirDateTime);
begin
  FReportDate.free;
  FReportDate := value;
end;

Function TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.GetReportDateST : TDateAndTime;
begin
  if FReportDate = nil then
    result := nil
  else
    result := ReportDate.value;
end;

Procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.SetReportDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FReportDate = nil then
      FReportDate := TFhirDateTime.create;
    FReportDate.value := value
  end
  else if FReportDate <> nil then
    FReportDate.value := nil;
end;

Procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := Text.value;
end;

Procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;


{ TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList }
procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.AddItem(value: TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
begin
  assert(value.ClassName = 'TFhirImmunizationProfileRecommendationSupportingAdverseEventReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationProfileRecommendationSupportingAdverseEventReport');
  add(value);
end;


function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Append: TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Clone: TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList(inherited Clone);
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.GetItemN(index: Integer): TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.IndexOf(value: TFhirImmunizationProfileRecommendationSupportingAdverseEventReport): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Insert(index: Integer): TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.InsertItem(index: Integer; value: TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
begin
  assert(value is TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
  Inherited Insert(index, value);
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Item(index: Integer): TFhirImmunizationProfileRecommendationSupportingAdverseEventReport;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReport(ObjectByIndex[index]);
end;

function TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Link: TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList;
begin
  result := TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList(inherited Link);
end;

procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.SetItemByIndex(index: Integer; value: TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
begin
  assert(value is TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
  FhirImmunizationProfileRecommendationSupportingAdverseEventReports[index] := value;
end;

procedure TFhirImmunizationProfileRecommendationSupportingAdverseEventReportList.SetItemN(index: Integer; value: TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
begin
  assert(value is TFhirImmunizationProfileRecommendationSupportingAdverseEventReport);
  ObjectByIndex[index] := value;
end;

{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
  FFlagList := TFhirCodeableConceptList.Create;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlagList.Free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TAdvObject);
begin
  inherited;
  FFlagList.Assign(TFhirListEntry(oSource).FFlagList);
  deleted := TFhirListEntry(oSource).deleted.Clone;
  date := TFhirListEntry(oSource).date.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.addAll(FFlagList);
  if (child_name = 'deleted') Then
     list.add(Deleted.Link);
  if (child_name = 'date') Then
     list.add(Date.Link);
  if (child_name = 'item') Then
     list.add(Item.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', FFlagList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', FDeleted.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Any)', FItem.Link.Link));{2}
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

{ TFhirListEntry }

Procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

Function TFhirListEntry.GetDeletedST : String;
begin
  if FDeleted = nil then
    result := ''
  else
    result := Deleted.value;
end;

Procedure TFhirListEntry.SetDeletedST(value : String);
begin
  if value <> '' then
  begin
    if FDeleted = nil then
      FDeleted := TFhirBoolean.create;
    FDeleted.value := value
  end
  else if FDeleted <> nil then
    FDeleted.value := '';
end;

Procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirListEntry.GetDateST : TDateAndTime;
begin
  if FDate = nil then
    result := nil
  else
    result := Date.value;
end;

Procedure TFhirListEntry.SetDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirListEntry.SetItem(value : TFhirResourceReference{Resource});
begin
  FItem.free;
  FItem := value;
end;


{ TFhirListEntryList }
procedure TFhirListEntryList.AddItem(value: TFhirListEntry);
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
end;


function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirLocationPosition }

constructor TFhirLocationPosition.Create;
begin
  inherited;
end;

destructor TFhirLocationPosition.Destroy;
begin
  FLongitude.free;
  FLatitude.free;
  FAltitude.free;
  inherited;
end;

procedure TFhirLocationPosition.Assign(oSource : TAdvObject);
begin
  inherited;
  longitude := TFhirLocationPosition(oSource).longitude.Clone;
  latitude := TFhirLocationPosition(oSource).latitude.Clone;
  altitude := TFhirLocationPosition(oSource).altitude.Clone;
end;

procedure TFhirLocationPosition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'longitude') Then
     list.add(Longitude.Link);
  if (child_name = 'latitude') Then
     list.add(Latitude.Link);
  if (child_name = 'altitude') Then
     list.add(Altitude.Link);
end;

procedure TFhirLocationPosition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'longitude', 'decimal', FLongitude.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'latitude', 'decimal', FLatitude.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altitude', 'decimal', FAltitude.Link.Link));{2}
end;

function TFhirLocationPosition.Link : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Link);
end;

function TFhirLocationPosition.Clone : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Clone);
end;

{ TFhirLocationPosition }

Procedure TFhirLocationPosition.SetLongitude(value : TFhirDecimal);
begin
  FLongitude.free;
  FLongitude := value;
end;

Function TFhirLocationPosition.GetLongitudeST : String;
begin
  if FLongitude = nil then
    result := ''
  else
    result := Longitude.value;
end;

Procedure TFhirLocationPosition.SetLongitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLongitude = nil then
      FLongitude := TFhirDecimal.create;
    FLongitude.value := value
  end
  else if FLongitude <> nil then
    FLongitude.value := '';
end;

Procedure TFhirLocationPosition.SetLatitude(value : TFhirDecimal);
begin
  FLatitude.free;
  FLatitude := value;
end;

Function TFhirLocationPosition.GetLatitudeST : String;
begin
  if FLatitude = nil then
    result := ''
  else
    result := Latitude.value;
end;

Procedure TFhirLocationPosition.SetLatitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLatitude = nil then
      FLatitude := TFhirDecimal.create;
    FLatitude.value := value
  end
  else if FLatitude <> nil then
    FLatitude.value := '';
end;

Procedure TFhirLocationPosition.SetAltitude(value : TFhirDecimal);
begin
  FAltitude.free;
  FAltitude := value;
end;

Function TFhirLocationPosition.GetAltitudeST : String;
begin
  if FAltitude = nil then
    result := ''
  else
    result := Altitude.value;
end;

Procedure TFhirLocationPosition.SetAltitudeST(value : String);
begin
  if value <> '' then
  begin
    if FAltitude = nil then
      FAltitude := TFhirDecimal.create;
    FAltitude.value := value
  end
  else if FAltitude <> nil then
    FAltitude.value := '';
end;


{ TFhirLocationPositionList }
procedure TFhirLocationPositionList.AddItem(value: TFhirLocationPosition);
begin
  assert(value.ClassName = 'TFhirLocationPosition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationPosition');
  add(value);
end;


function TFhirLocationPositionList.Append: TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirLocationPositionList.ClearItems;
begin
  Clear;
end;

function TFhirLocationPositionList.Clone: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Clone);
end;

function TFhirLocationPositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationPositionList.GetItemN(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.IndexOf(value: TFhirLocationPosition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirLocationPositionList.Insert(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirLocationPositionList.InsertItem(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  Inherited Insert(index, value);
end;

function TFhirLocationPositionList.Item(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.Link: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Link);
end;

procedure TFhirLocationPositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationPositionList.SetItemByIndex(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  FhirLocationPositions[index] := value;
end;

procedure TFhirLocationPositionList.SetItemN(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProduct }

constructor TFhirMedicationProduct.Create;
begin
  inherited;
  FIngredientList := TFhirMedicationProductIngredientList.Create;
end;

destructor TFhirMedicationProduct.Destroy;
begin
  FForm.free;
  FIngredientList.Free;
  inherited;
end;

procedure TFhirMedicationProduct.Assign(oSource : TAdvObject);
begin
  inherited;
  form := TFhirMedicationProduct(oSource).form.Clone;
  FIngredientList.Assign(TFhirMedicationProduct(oSource).FIngredientList);
end;

procedure TFhirMedicationProduct.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'form') Then
     list.add(Form.Link);
  if (child_name = 'ingredient') Then
     list.addAll(FIngredientList);
end;

procedure TFhirMedicationProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', FForm.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ingredient', '', FIngredientList.Link)){3};
end;

function TFhirMedicationProduct.Link : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Link);
end;

function TFhirMedicationProduct.Clone : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Clone);
end;

{ TFhirMedicationProduct }

Procedure TFhirMedicationProduct.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;


{ TFhirMedicationProductList }
procedure TFhirMedicationProductList.AddItem(value: TFhirMedicationProduct);
begin
  assert(value.ClassName = 'TFhirMedicationProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProduct');
  add(value);
end;


function TFhirMedicationProductList.Append: TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductList.Clone: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Clone);
end;

function TFhirMedicationProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductList.GetItemN(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.IndexOf(value: TFhirMedicationProduct): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationProductList.Insert(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductList.InsertItem(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductList.Item(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.Link: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Link);
end;

procedure TFhirMedicationProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductList.SetItemByIndex(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  FhirMedicationProducts[index] := value;
end;

procedure TFhirMedicationProductList.SetItemN(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProductIngredient }

constructor TFhirMedicationProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationProductIngredient.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationProductIngredient.Assign(oSource : TAdvObject);
begin
  inherited;
  item := TFhirMedicationProductIngredient(oSource).item.Clone;
  amount := TFhirMedicationProductIngredient(oSource).amount.Clone;
end;

procedure TFhirMedicationProductIngredient.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(Item.Link);
  if (child_name = 'amount') Then
     list.add(Amount.Link);
end;

procedure TFhirMedicationProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Substance|Medication)', FItem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', FAmount.Link.Link));{2}
end;

function TFhirMedicationProductIngredient.Link : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Link);
end;

function TFhirMedicationProductIngredient.Clone : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Clone);
end;

{ TFhirMedicationProductIngredient }

Procedure TFhirMedicationProductIngredient.SetItem(value : TFhirResourceReference{Resource});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationProductIngredient.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value;
end;


{ TFhirMedicationProductIngredientList }
procedure TFhirMedicationProductIngredientList.AddItem(value: TFhirMedicationProductIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProductIngredient');
  add(value);
end;


function TFhirMedicationProductIngredientList.Append: TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductIngredientList.Clone: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Clone);
end;

function TFhirMedicationProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductIngredientList.GetItemN(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.IndexOf(value: TFhirMedicationProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationProductIngredientList.Insert(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductIngredientList.InsertItem(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductIngredientList.Item(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.Link: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Link);
end;

procedure TFhirMedicationProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  FhirMedicationProductIngredients[index] := value;
end;

procedure TFhirMedicationProductIngredientList.SetItemN(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackage }

constructor TFhirMedicationPackage.Create;
begin
  inherited;
  FContentList := TFhirMedicationPackageContentList.Create;
end;

destructor TFhirMedicationPackage.Destroy;
begin
  FContainer.free;
  FContentList.Free;
  inherited;
end;

procedure TFhirMedicationPackage.Assign(oSource : TAdvObject);
begin
  inherited;
  container := TFhirMedicationPackage(oSource).container.Clone;
  FContentList.Assign(TFhirMedicationPackage(oSource).FContentList);
end;

procedure TFhirMedicationPackage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'container') Then
     list.add(Container.Link);
  if (child_name = 'content') Then
     list.addAll(FContentList);
end;

procedure TFhirMedicationPackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'container', 'CodeableConcept', FContainer.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', '', FContentList.Link)){3};
end;

function TFhirMedicationPackage.Link : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Link);
end;

function TFhirMedicationPackage.Clone : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Clone);
end;

{ TFhirMedicationPackage }

Procedure TFhirMedicationPackage.SetContainer(value : TFhirCodeableConcept);
begin
  FContainer.free;
  FContainer := value;
end;


{ TFhirMedicationPackageList }
procedure TFhirMedicationPackageList.AddItem(value: TFhirMedicationPackage);
begin
  assert(value.ClassName = 'TFhirMedicationPackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackage');
  add(value);
end;


function TFhirMedicationPackageList.Append: TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageList.Clone: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Clone);
end;

function TFhirMedicationPackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageList.GetItemN(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.IndexOf(value: TFhirMedicationPackage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPackageList.Insert(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageList.InsertItem(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageList.Item(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.Link: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Link);
end;

procedure TFhirMedicationPackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageList.SetItemByIndex(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  FhirMedicationPackages[index] := value;
end;

procedure TFhirMedicationPackageList.SetItemN(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackageContent }

constructor TFhirMedicationPackageContent.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackageContent.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationPackageContent.Assign(oSource : TAdvObject);
begin
  inherited;
  item := TFhirMedicationPackageContent(oSource).item.Clone;
  amount := TFhirMedicationPackageContent(oSource).amount.Clone;
end;

procedure TFhirMedicationPackageContent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(Item.Link);
  if (child_name = 'amount') Then
     list.add(Amount.Link);
end;

procedure TFhirMedicationPackageContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Medication)', FItem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', FAmount.Link.Link));{2}
end;

function TFhirMedicationPackageContent.Link : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Link);
end;

function TFhirMedicationPackageContent.Clone : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Clone);
end;

{ TFhirMedicationPackageContent }

Procedure TFhirMedicationPackageContent.SetItem(value : TFhirResourceReference{TFhirMedication});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationPackageContent.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;


{ TFhirMedicationPackageContentList }
procedure TFhirMedicationPackageContentList.AddItem(value: TFhirMedicationPackageContent);
begin
  assert(value.ClassName = 'TFhirMedicationPackageContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackageContent');
  add(value);
end;


function TFhirMedicationPackageContentList.Append: TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageContentList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageContentList.Clone: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Clone);
end;

function TFhirMedicationPackageContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageContentList.GetItemN(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.IndexOf(value: TFhirMedicationPackageContent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPackageContentList.Insert(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageContentList.InsertItem(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageContentList.Item(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.Link: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Link);
end;

procedure TFhirMedicationPackageContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageContentList.SetItemByIndex(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  FhirMedicationPackageContents[index] := value;
end;

procedure TFhirMedicationPackageContentList.SetItemN(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministrationDosage }

constructor TFhirMedicationAdministrationDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationDosage.Destroy;
begin
  FTiming.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationAdministrationDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  timing := TFhirMedicationAdministrationDosage(oSource).timing.Clone;
  site := TFhirMedicationAdministrationDosage(oSource).site.Clone;
  route := TFhirMedicationAdministrationDosage(oSource).route.Clone;
  method := TFhirMedicationAdministrationDosage(oSource).method.Clone;
  quantity := TFhirMedicationAdministrationDosage(oSource).quantity.Clone;
  rate := TFhirMedicationAdministrationDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationAdministrationDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationAdministrationDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationAdministrationDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timing', 'Schedule', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationAdministrationDosage.Link : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Link);
end;

function TFhirMedicationAdministrationDosage.Clone : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Clone);
end;

{ TFhirMedicationAdministrationDosage }

Procedure TFhirMedicationAdministrationDosage.SetTiming(value : TFhirSchedule);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationAdministrationDosageList }
procedure TFhirMedicationAdministrationDosageList.AddItem(value: TFhirMedicationAdministrationDosage);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationDosage');
  add(value);
end;


function TFhirMedicationAdministrationDosageList.Append: TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationAdministrationDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationDosageList.Clone: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Clone);
end;

function TFhirMedicationAdministrationDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationDosageList.GetItemN(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.IndexOf(value: TFhirMedicationAdministrationDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationAdministrationDosageList.Insert(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationAdministrationDosageList.InsertItem(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationDosageList.Item(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.Link: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Link);
end;

procedure TFhirMedicationAdministrationDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  FhirMedicationAdministrationDosages[index] := value;
end;

procedure TFhirMedicationAdministrationDosageList.SetItemN(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseDispense }

constructor TFhirMedicationDispenseDispense.Create;
begin
  inherited;
  FReceiverList := TFhirResourceReferenceList{TFhirPractitioner}.Create;
  FDosageList := TFhirMedicationDispenseDispenseDosageList.Create;
end;

destructor TFhirMedicationDispenseDispense.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FQuantity.free;
  FMedication.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirMedicationDispenseDispense(oSource).identifier.Clone;
  FStatus := TFhirMedicationDispenseDispense(oSource).FStatus.Link;
  type_ := TFhirMedicationDispenseDispense(oSource).type_.Clone;
  quantity := TFhirMedicationDispenseDispense(oSource).quantity.Clone;
  medication := TFhirMedicationDispenseDispense(oSource).medication.Clone;
  whenPrepared := TFhirMedicationDispenseDispense(oSource).whenPrepared.Clone;
  whenHandedOver := TFhirMedicationDispenseDispense(oSource).whenHandedOver.Clone;
  destination := TFhirMedicationDispenseDispense(oSource).destination.Clone;
  FReceiverList.Assign(TFhirMedicationDispenseDispense(oSource).FReceiverList);
  FDosageList.Assign(TFhirMedicationDispenseDispense(oSource).FDosageList);
end;

procedure TFhirMedicationDispenseDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'medication') Then
     list.add(Medication.Link);
  if (child_name = 'whenPrepared') Then
     list.add(WhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(WhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(Destination.Link);
  if (child_name = 'receiver') Then
     list.addAll(FReceiverList);
  if (child_name = 'dosage') Then
     list.addAll(FDosageList);
end;

procedure TFhirMedicationDispenseDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication', 'Resource(Medication)', FMedication.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'Period', FWhenPrepared.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'Period', FWhenHandedOver.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Resource(Practitioner)', FReceiverList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dosage', '', FDosageList.Link)){3};
end;

function TFhirMedicationDispenseDispense.Link : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(inherited Link);
end;

function TFhirMedicationDispenseDispense.Clone : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(inherited Clone);
end;

{ TFhirMedicationDispenseDispense }

Procedure TFhirMedicationDispenseDispense.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMedicationDispenseDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationDispenseDispense.GetStatusST : TFhirMedicationDispenseStatus;
begin
  if FStatus = nil then
    result := TFhirMedicationDispenseStatus(0)
  else
    result := TFhirMedicationDispenseStatus(StringArrayIndexOf(CODES_TFhirMedicationDispenseStatus, Status.value));
end;

Procedure TFhirMedicationDispenseDispense.SetStatusST(value : TFhirMedicationDispenseStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirMedicationDispenseStatus[value]);
end;

Procedure TFhirMedicationDispenseDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationDispenseDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispenseDispense.SetMedication(value : TFhirResourceReference{TFhirMedication});
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenPrepared(value : TFhirPeriod);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenHandedOver(value : TFhirPeriod);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Procedure TFhirMedicationDispenseDispense.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;


{ TFhirMedicationDispenseDispenseList }
procedure TFhirMedicationDispenseDispenseList.AddItem(value: TFhirMedicationDispenseDispense);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseDispense');
  add(value);
end;


function TFhirMedicationDispenseDispenseList.Append: TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseDispenseList.Clone: TFhirMedicationDispenseDispenseList;
begin
  result := TFhirMedicationDispenseDispenseList(inherited Clone);
end;

function TFhirMedicationDispenseDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseDispenseList.GetItemN(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseList.IndexOf(value: TFhirMedicationDispenseDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseDispenseList.Insert(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseList.InsertItem(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseDispenseList.Item(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseList.Link: TFhirMedicationDispenseDispenseList;
begin
  result := TFhirMedicationDispenseDispenseList(inherited Link);
end;

procedure TFhirMedicationDispenseDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  FhirMedicationDispenseDispenses[index] := value;
end;

procedure TFhirMedicationDispenseDispenseList.SetItemN(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseDispenseDosage }

constructor TFhirMedicationDispenseDispenseDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseDispenseDosage.Destroy;
begin
  FAdditionalInstructions.free;
  FTiming.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationDispenseDispenseDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  additionalInstructions := TFhirMedicationDispenseDispenseDosage(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationDispenseDispenseDosage(oSource).timing.Clone;
  site := TFhirMedicationDispenseDispenseDosage(oSource).site.Clone;
  route := TFhirMedicationDispenseDispenseDosage(oSource).route.Clone;
  method := TFhirMedicationDispenseDispenseDosage(oSource).method.Clone;
  quantity := TFhirMedicationDispenseDispenseDosage(oSource).quantity.Clone;
  rate := TFhirMedicationDispenseDispenseDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationDispenseDispenseDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationDispenseDispenseDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'additionalInstructions') Then
     list.add(AdditionalInstructions.Link);
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationDispenseDispenseDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'additionalInstructions[x]', 'string|CodeableConcept', FAdditionalInstructions.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Schedule', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationDispenseDispenseDosage.Link : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(inherited Link);
end;

function TFhirMedicationDispenseDispenseDosage.Clone : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(inherited Clone);
end;

{ TFhirMedicationDispenseDispenseDosage }

Procedure TFhirMedicationDispenseDispenseDosage.SetAdditionalInstructions(value : TFhirType);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationDispenseDispenseDosageList }
procedure TFhirMedicationDispenseDispenseDosageList.AddItem(value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseDispenseDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseDispenseDosage');
  add(value);
end;


function TFhirMedicationDispenseDispenseDosageList.Append: TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseDispenseDosageList.Clone: TFhirMedicationDispenseDispenseDosageList;
begin
  result := TFhirMedicationDispenseDispenseDosageList(inherited Clone);
end;

function TFhirMedicationDispenseDispenseDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseDispenseDosageList.GetItemN(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseDosageList.IndexOf(value: TFhirMedicationDispenseDispenseDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseDispenseDosageList.Insert(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseDosageList.InsertItem(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseDispenseDosageList.Item(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseDosageList.Link: TFhirMedicationDispenseDispenseDosageList;
begin
  result := TFhirMedicationDispenseDispenseDosageList(inherited Link);
end;

procedure TFhirMedicationDispenseDispenseDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseDispenseDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  FhirMedicationDispenseDispenseDosages[index] := value;
end;

procedure TFhirMedicationDispenseDispenseDosageList.SetItemN(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseSubstitution }

constructor TFhirMedicationDispenseSubstitution.Create;
begin
  inherited;
  FReasonList := TFhirCodeableConceptList.Create;
  FResponsiblePartyList := TFhirResourceReferenceList{TFhirPractitioner}.Create;
end;

destructor TFhirMedicationDispenseSubstitution.Destroy;
begin
  FType_.free;
  FReasonList.Free;
  FResponsiblePartyList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseSubstitution.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirMedicationDispenseSubstitution(oSource).type_.Clone;
  FReasonList.Assign(TFhirMedicationDispenseSubstitution(oSource).FReasonList);
  FResponsiblePartyList.Assign(TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reason') Then
     list.addAll(FReasonList);
  if (child_name = 'responsibleParty') Then
     list.addAll(FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responsibleParty', 'Resource(Practitioner)', FResponsiblePartyList.Link)){3};
end;

function TFhirMedicationDispenseSubstitution.Link : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Link);
end;

function TFhirMedicationDispenseSubstitution.Clone : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Clone);
end;

{ TFhirMedicationDispenseSubstitution }

Procedure TFhirMedicationDispenseSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;


{ TFhirMedicationDispenseSubstitutionList }
procedure TFhirMedicationDispenseSubstitutionList.AddItem(value: TFhirMedicationDispenseSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseSubstitution');
  add(value);
end;


function TFhirMedicationDispenseSubstitutionList.Append: TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseSubstitutionList.Clone: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Clone);
end;

function TFhirMedicationDispenseSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseSubstitutionList.GetItemN(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.IndexOf(value: TFhirMedicationDispenseSubstitution): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseSubstitutionList.Insert(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseSubstitutionList.Item(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.Link: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Link);
end;

procedure TFhirMedicationDispenseSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  FhirMedicationDispenseSubstitutions[index] := value;
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionDosageInstruction }

constructor TFhirMedicationPrescriptionDosageInstruction.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionDosageInstruction.Destroy;
begin
  FDosageInstructionsText.free;
  FAdditionalInstructions.free;
  FTiming.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDoseQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionDosageInstruction.Assign(oSource : TAdvObject);
begin
  inherited;
  dosageInstructionsText := TFhirMedicationPrescriptionDosageInstruction(oSource).dosageInstructionsText.Clone;
  additionalInstructions := TFhirMedicationPrescriptionDosageInstruction(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationPrescriptionDosageInstruction(oSource).timing.Clone;
  site := TFhirMedicationPrescriptionDosageInstruction(oSource).site.Clone;
  route := TFhirMedicationPrescriptionDosageInstruction(oSource).route.Clone;
  method := TFhirMedicationPrescriptionDosageInstruction(oSource).method.Clone;
  doseQuantity := TFhirMedicationPrescriptionDosageInstruction(oSource).doseQuantity.Clone;
  rate := TFhirMedicationPrescriptionDosageInstruction(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationPrescriptionDosageInstruction(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationPrescriptionDosageInstruction.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'dosageInstructionsText') Then
     list.add(DosageInstructionsText.Link);
  if (child_name = 'additionalInstructions') Then
     list.add(AdditionalInstructions.Link);
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'doseQuantity') Then
     list.add(DoseQuantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationPrescriptionDosageInstruction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'dosageInstructionsText', 'string', FDosageInstructionsText.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additionalInstructions[x]', 'string|CodeableConcept', FAdditionalInstructions.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Schedule', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseQuantity', 'Quantity', FDoseQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationPrescriptionDosageInstruction.Link : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(inherited Link);
end;

function TFhirMedicationPrescriptionDosageInstruction.Clone : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(inherited Clone);
end;

{ TFhirMedicationPrescriptionDosageInstruction }

Procedure TFhirMedicationPrescriptionDosageInstruction.SetDosageInstructionsText(value : TFhirString);
begin
  FDosageInstructionsText.free;
  FDosageInstructionsText := value;
end;

Function TFhirMedicationPrescriptionDosageInstruction.GetDosageInstructionsTextST : String;
begin
  if FDosageInstructionsText = nil then
    result := ''
  else
    result := DosageInstructionsText.value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetDosageInstructionsTextST(value : String);
begin
  if value <> '' then
  begin
    if FDosageInstructionsText = nil then
      FDosageInstructionsText := TFhirString.create;
    FDosageInstructionsText.value := value
  end
  else if FDosageInstructionsText <> nil then
    FDosageInstructionsText.value := '';
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetAdditionalInstructions(value : TFhirType);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetDoseQuantity(value : TFhirQuantity);
begin
  FDoseQuantity.free;
  FDoseQuantity := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationPrescriptionDosageInstructionList }
procedure TFhirMedicationPrescriptionDosageInstructionList.AddItem(value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionDosageInstruction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionDosageInstruction');
  add(value);
end;


function TFhirMedicationPrescriptionDosageInstructionList.Append: TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDosageInstructionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionDosageInstructionList.Clone: TFhirMedicationPrescriptionDosageInstructionList;
begin
  result := TFhirMedicationPrescriptionDosageInstructionList(inherited Clone);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionDosageInstructionList.GetItemN(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDosageInstructionList.IndexOf(value: TFhirMedicationPrescriptionDosageInstruction): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionDosageInstructionList.Insert(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDosageInstructionList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Item(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Link: TFhirMedicationPrescriptionDosageInstructionList;
begin
  result := TFhirMedicationPrescriptionDosageInstructionList(inherited Link);
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  FhirMedicationPrescriptionDosageInstructions[index] := value;
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionDispense }

constructor TFhirMedicationPrescriptionDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionDispense.Destroy;
begin
  FMedication.free;
  FValidityPeriod.free;
  FNumberOfRepeatsAllowed.free;
  FQuantity.free;
  FExpectedSupplyDuration.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  medication := TFhirMedicationPrescriptionDispense(oSource).medication.Clone;
  validityPeriod := TFhirMedicationPrescriptionDispense(oSource).validityPeriod.Clone;
  numberOfRepeatsAllowed := TFhirMedicationPrescriptionDispense(oSource).numberOfRepeatsAllowed.Clone;
  quantity := TFhirMedicationPrescriptionDispense(oSource).quantity.Clone;
  expectedSupplyDuration := TFhirMedicationPrescriptionDispense(oSource).expectedSupplyDuration.Clone;
end;

procedure TFhirMedicationPrescriptionDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'medication') Then
     list.add(Medication.Link);
  if (child_name = 'validityPeriod') Then
     list.add(ValidityPeriod.Link);
  if (child_name = 'numberOfRepeatsAllowed') Then
     list.add(NumberOfRepeatsAllowed.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'expectedSupplyDuration') Then
     list.add(ExpectedSupplyDuration.Link);
end;

procedure TFhirMedicationPrescriptionDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'medication', 'Resource(Medication)', FMedication.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', FValidityPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfRepeatsAllowed', 'integer', FNumberOfRepeatsAllowed.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expectedSupplyDuration', 'Duration', FExpectedSupplyDuration.Link.Link));{2}
end;

function TFhirMedicationPrescriptionDispense.Link : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(inherited Link);
end;

function TFhirMedicationPrescriptionDispense.Clone : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(inherited Clone);
end;

{ TFhirMedicationPrescriptionDispense }

Procedure TFhirMedicationPrescriptionDispense.SetMedication(value : TFhirResourceReference{TFhirMedication});
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetNumberOfRepeatsAllowed(value : TFhirInteger);
begin
  FNumberOfRepeatsAllowed.free;
  FNumberOfRepeatsAllowed := value;
end;

Function TFhirMedicationPrescriptionDispense.GetNumberOfRepeatsAllowedST : String;
begin
  if FNumberOfRepeatsAllowed = nil then
    result := ''
  else
    result := NumberOfRepeatsAllowed.value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetNumberOfRepeatsAllowedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfRepeatsAllowed = nil then
      FNumberOfRepeatsAllowed := TFhirInteger.create;
    FNumberOfRepeatsAllowed.value := value
  end
  else if FNumberOfRepeatsAllowed <> nil then
    FNumberOfRepeatsAllowed.value := '';
end;

Procedure TFhirMedicationPrescriptionDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetExpectedSupplyDuration(value : TFhirQuantity);
begin
  FExpectedSupplyDuration.free;
  FExpectedSupplyDuration := value;
end;


{ TFhirMedicationPrescriptionDispenseList }
procedure TFhirMedicationPrescriptionDispenseList.AddItem(value: TFhirMedicationPrescriptionDispense);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionDispense');
  add(value);
end;


function TFhirMedicationPrescriptionDispenseList.Append: TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionDispenseList.Clone: TFhirMedicationPrescriptionDispenseList;
begin
  result := TFhirMedicationPrescriptionDispenseList(inherited Clone);
end;

function TFhirMedicationPrescriptionDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionDispenseList.GetItemN(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDispenseList.IndexOf(value: TFhirMedicationPrescriptionDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionDispenseList.Insert(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDispenseList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionDispenseList.Item(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDispenseList.Link: TFhirMedicationPrescriptionDispenseList;
begin
  result := TFhirMedicationPrescriptionDispenseList(inherited Link);
end;

procedure TFhirMedicationPrescriptionDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  FhirMedicationPrescriptionDispenses[index] := value;
end;

procedure TFhirMedicationPrescriptionDispenseList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionSubstitution }

constructor TFhirMedicationPrescriptionSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionSubstitution.Destroy;
begin
  FType_.free;
  FReason.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionSubstitution.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirMedicationPrescriptionSubstitution(oSource).type_.Clone;
  reason := TFhirMedicationPrescriptionSubstitution(oSource).reason.Clone;
end;

procedure TFhirMedicationPrescriptionSubstitution.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reason') Then
     list.add(Reason.Link);
end;

procedure TFhirMedicationPrescriptionSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReason.Link.Link));{2}
end;

function TFhirMedicationPrescriptionSubstitution.Link : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(inherited Link);
end;

function TFhirMedicationPrescriptionSubstitution.Clone : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(inherited Clone);
end;

{ TFhirMedicationPrescriptionSubstitution }

Procedure TFhirMedicationPrescriptionSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationPrescriptionSubstitution.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;


{ TFhirMedicationPrescriptionSubstitutionList }
procedure TFhirMedicationPrescriptionSubstitutionList.AddItem(value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionSubstitution');
  add(value);
end;


function TFhirMedicationPrescriptionSubstitutionList.Append: TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionSubstitutionList.Clone: TFhirMedicationPrescriptionSubstitutionList;
begin
  result := TFhirMedicationPrescriptionSubstitutionList(inherited Clone);
end;

function TFhirMedicationPrescriptionSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionSubstitutionList.GetItemN(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionSubstitutionList.IndexOf(value: TFhirMedicationPrescriptionSubstitution): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionSubstitutionList.Insert(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionSubstitutionList.Item(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionSubstitutionList.Link: TFhirMedicationPrescriptionSubstitutionList;
begin
  result := TFhirMedicationPrescriptionSubstitutionList(inherited Link);
end;

procedure TFhirMedicationPrescriptionSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  FhirMedicationPrescriptionSubstitutions[index] := value;
end;

procedure TFhirMedicationPrescriptionSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationStatementDosage }

constructor TFhirMedicationStatementDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationStatementDosage.Destroy;
begin
  FTiming.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationStatementDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  timing := TFhirMedicationStatementDosage(oSource).timing.Clone;
  site := TFhirMedicationStatementDosage(oSource).site.Clone;
  route := TFhirMedicationStatementDosage(oSource).route.Clone;
  method := TFhirMedicationStatementDosage(oSource).method.Clone;
  quantity := TFhirMedicationStatementDosage(oSource).quantity.Clone;
  rate := TFhirMedicationStatementDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationStatementDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationStatementDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationStatementDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timing', 'Schedule', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationStatementDosage.Link : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Link);
end;

function TFhirMedicationStatementDosage.Clone : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Clone);
end;

{ TFhirMedicationStatementDosage }

Procedure TFhirMedicationStatementDosage.SetTiming(value : TFhirSchedule);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationStatementDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationStatementDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationStatementDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationStatementDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationStatementDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationStatementDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationStatementDosageList }
procedure TFhirMedicationStatementDosageList.AddItem(value: TFhirMedicationStatementDosage);
begin
  assert(value.ClassName = 'TFhirMedicationStatementDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationStatementDosage');
  add(value);
end;


function TFhirMedicationStatementDosageList.Append: TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationStatementDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationStatementDosageList.Clone: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Clone);
end;

function TFhirMedicationStatementDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationStatementDosageList.GetItemN(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.IndexOf(value: TFhirMedicationStatementDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationStatementDosageList.Insert(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationStatementDosageList.InsertItem(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationStatementDosageList.Item(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.Link: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Link);
end;

procedure TFhirMedicationStatementDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationStatementDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  FhirMedicationStatementDosages[index] := value;
end;

procedure TFhirMedicationStatementDosageList.SetItemN(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageResponse }

constructor TFhirMessageResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageResponse.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirMessageResponse(oSource).identifier.Clone;
  FCode := TFhirMessageResponse(oSource).FCode.Link;
  details := TFhirMessageResponse(oSource).details.Clone;
end;

procedure TFhirMessageResponse.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'details') Then
     list.add(Details.Link);
end;

procedure TFhirMessageResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'Resource(OperationOutcome)', FDetails.Link.Link));{2}
end;

function TFhirMessageResponse.Link : TFhirMessageResponse;
begin
  result := TFhirMessageResponse(inherited Link);
end;

function TFhirMessageResponse.Clone : TFhirMessageResponse;
begin
  result := TFhirMessageResponse(inherited Clone);
end;

{ TFhirMessageResponse }

Procedure TFhirMessageResponse.SetIdentifier(value : TFhirId);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMessageResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirMessageResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirId.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirMessageResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMessageResponse.GetCodeST : TFhirResponseCode;
begin
  if FCode = nil then
    result := TFhirResponseCode(0)
  else
    result := TFhirResponseCode(StringArrayIndexOf(CODES_TFhirResponseCode, Code.value));
end;

Procedure TFhirMessageResponse.SetCodeST(value : TFhirResponseCode);
begin
  if ord(value) = 0 then
    Code := nil
  else
    Code := TFhirEnum.create(CODES_TFhirResponseCode[value]);
end;

Procedure TFhirMessageResponse.SetDetails(value : TFhirResourceReference{TFhirOperationOutcome});
begin
  FDetails.free;
  FDetails := value;
end;


{ TFhirMessageResponseList }
procedure TFhirMessageResponseList.AddItem(value: TFhirMessageResponse);
begin
  assert(value.ClassName = 'TFhirMessageResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageResponse');
  add(value);
end;


function TFhirMessageResponseList.Append: TFhirMessageResponse;
begin
  result := TFhirMessageResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageResponseList.Clone: TFhirMessageResponseList;
begin
  result := TFhirMessageResponseList(inherited Clone);
end;

function TFhirMessageResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageResponseList.GetItemN(index: Integer): TFhirMessageResponse;
begin
  result := TFhirMessageResponse(ObjectByIndex[index]);
end;

function TFhirMessageResponseList.IndexOf(value: TFhirMessageResponse): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageResponseList.Insert(index: Integer): TFhirMessageResponse;
begin
  result := TFhirMessageResponse.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageResponseList.InsertItem(index: Integer; value: TFhirMessageResponse);
begin
  assert(value is TFhirMessageResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageResponseList.Item(index: Integer): TFhirMessageResponse;
begin
  result := TFhirMessageResponse(ObjectByIndex[index]);
end;

function TFhirMessageResponseList.Link: TFhirMessageResponseList;
begin
  result := TFhirMessageResponseList(inherited Link);
end;

procedure TFhirMessageResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageResponseList.SetItemByIndex(index: Integer; value: TFhirMessageResponse);
begin
  assert(value is TFhirMessageResponse);
  FhirMessageResponses[index] := value;
end;

procedure TFhirMessageResponseList.SetItemN(index: Integer; value: TFhirMessageResponse);
begin
  assert(value is TFhirMessageResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageSource }

constructor TFhirMessageSource.Create;
begin
  inherited;
end;

destructor TFhirMessageSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageSource.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirMessageSource(oSource).name.Clone;
  software := TFhirMessageSource(oSource).software.Clone;
  version := TFhirMessageSource(oSource).version.Clone;
  contact := TFhirMessageSource(oSource).contact.Clone;
  endpoint := TFhirMessageSource(oSource).endpoint.Clone;
end;

procedure TFhirMessageSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'software') Then
     list.add(Software.Link);
  if (child_name = 'version') Then
     list.add(Version.Link);
  if (child_name = 'contact') Then
     list.add(Contact.Link);
  if (child_name = 'endpoint') Then
     list.add(Endpoint.Link);
end;

procedure TFhirMessageSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'software', 'string', FSoftware.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'Contact', FContact.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link.Link));{2}
end;

function TFhirMessageSource.Link : TFhirMessageSource;
begin
  result := TFhirMessageSource(inherited Link);
end;

function TFhirMessageSource.Clone : TFhirMessageSource;
begin
  result := TFhirMessageSource(inherited Clone);
end;

{ TFhirMessageSource }

Procedure TFhirMessageSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirMessageSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

Function TFhirMessageSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := Software.value;
end;

Procedure TFhirMessageSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

Procedure TFhirMessageSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirMessageSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := Version.value;
end;

Procedure TFhirMessageSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirMessageSource.SetContact(value : TFhirContact);
begin
  FContact.free;
  FContact := value;
end;

Procedure TFhirMessageSource.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := Endpoint.value;
end;

Procedure TFhirMessageSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;


{ TFhirMessageSourceList }
procedure TFhirMessageSourceList.AddItem(value: TFhirMessageSource);
begin
  assert(value.ClassName = 'TFhirMessageSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageSource');
  add(value);
end;


function TFhirMessageSourceList.Append: TFhirMessageSource;
begin
  result := TFhirMessageSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageSourceList.Clone: TFhirMessageSourceList;
begin
  result := TFhirMessageSourceList(inherited Clone);
end;

function TFhirMessageSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageSourceList.GetItemN(index: Integer): TFhirMessageSource;
begin
  result := TFhirMessageSource(ObjectByIndex[index]);
end;

function TFhirMessageSourceList.IndexOf(value: TFhirMessageSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageSourceList.Insert(index: Integer): TFhirMessageSource;
begin
  result := TFhirMessageSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageSourceList.InsertItem(index: Integer; value: TFhirMessageSource);
begin
  assert(value is TFhirMessageSource);
  Inherited Insert(index, value);
end;

function TFhirMessageSourceList.Item(index: Integer): TFhirMessageSource;
begin
  result := TFhirMessageSource(ObjectByIndex[index]);
end;

function TFhirMessageSourceList.Link: TFhirMessageSourceList;
begin
  result := TFhirMessageSourceList(inherited Link);
end;

procedure TFhirMessageSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageSourceList.SetItemByIndex(index: Integer; value: TFhirMessageSource);
begin
  assert(value is TFhirMessageSource);
  FhirMessageSources[index] := value;
end;

procedure TFhirMessageSourceList.SetItemN(index: Integer; value: TFhirMessageSource);
begin
  assert(value is TFhirMessageSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageDestination }

constructor TFhirMessageDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageDestination.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirMessageDestination(oSource).name.Clone;
  target := TFhirMessageDestination(oSource).target.Clone;
  endpoint := TFhirMessageDestination(oSource).endpoint.Clone;
end;

procedure TFhirMessageDestination.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
  if (child_name = 'endpoint') Then
     list.add(Endpoint.Link);
end;

procedure TFhirMessageDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Device)', FTarget.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link.Link));{2}
end;

function TFhirMessageDestination.Link : TFhirMessageDestination;
begin
  result := TFhirMessageDestination(inherited Link);
end;

function TFhirMessageDestination.Clone : TFhirMessageDestination;
begin
  result := TFhirMessageDestination(inherited Clone);
end;

{ TFhirMessageDestination }

Procedure TFhirMessageDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirMessageDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageDestination.SetTarget(value : TFhirResourceReference{TFhirDevice});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirMessageDestination.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := Endpoint.value;
end;

Procedure TFhirMessageDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;


{ TFhirMessageDestinationList }
procedure TFhirMessageDestinationList.AddItem(value: TFhirMessageDestination);
begin
  assert(value.ClassName = 'TFhirMessageDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageDestination');
  add(value);
end;


function TFhirMessageDestinationList.Append: TFhirMessageDestination;
begin
  result := TFhirMessageDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageDestinationList.Clone: TFhirMessageDestinationList;
begin
  result := TFhirMessageDestinationList(inherited Clone);
end;

function TFhirMessageDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageDestinationList.GetItemN(index: Integer): TFhirMessageDestination;
begin
  result := TFhirMessageDestination(ObjectByIndex[index]);
end;

function TFhirMessageDestinationList.IndexOf(value: TFhirMessageDestination): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageDestinationList.Insert(index: Integer): TFhirMessageDestination;
begin
  result := TFhirMessageDestination.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageDestinationList.InsertItem(index: Integer; value: TFhirMessageDestination);
begin
  assert(value is TFhirMessageDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageDestinationList.Item(index: Integer): TFhirMessageDestination;
begin
  result := TFhirMessageDestination(ObjectByIndex[index]);
end;

function TFhirMessageDestinationList.Link: TFhirMessageDestinationList;
begin
  result := TFhirMessageDestinationList(inherited Link);
end;

procedure TFhirMessageDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageDestination);
begin
  assert(value is TFhirMessageDestination);
  FhirMessageDestinations[index] := value;
end;

procedure TFhirMessageDestinationList.SetItemN(index: Integer; value: TFhirMessageDestination);
begin
  assert(value is TFhirMessageDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationReferenceRange }

constructor TFhirObservationReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirObservationReferenceRange.Destroy;
begin
  FMeaning.free;
  FRange.free;
  inherited;
end;

procedure TFhirObservationReferenceRange.Assign(oSource : TAdvObject);
begin
  inherited;
  meaning := TFhirObservationReferenceRange(oSource).meaning.Clone;
  range := TFhirObservationReferenceRange(oSource).range.Clone;
end;

procedure TFhirObservationReferenceRange.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'meaning') Then
     list.add(Meaning.Link);
  if (child_name = 'range') Then
     list.add(Range.Link);
end;

procedure TFhirObservationReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'meaning', 'CodeableConcept', FMeaning.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'range[x]', 'Quantity|Range|string', FRange.Link.Link));{2}
end;

function TFhirObservationReferenceRange.Link : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Link);
end;

function TFhirObservationReferenceRange.Clone : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Clone);
end;

{ TFhirObservationReferenceRange }

Procedure TFhirObservationReferenceRange.SetMeaning(value : TFhirCodeableConcept);
begin
  FMeaning.free;
  FMeaning := value;
end;

Procedure TFhirObservationReferenceRange.SetRange(value : TFhirType);
begin
  FRange.free;
  FRange := value;
end;


{ TFhirObservationReferenceRangeList }
procedure TFhirObservationReferenceRangeList.AddItem(value: TFhirObservationReferenceRange);
begin
  assert(value.ClassName = 'TFhirObservationReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationReferenceRange');
  add(value);
end;


function TFhirObservationReferenceRangeList.Append: TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirObservationReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirObservationReferenceRangeList.Clone: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Clone);
end;

function TFhirObservationReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationReferenceRangeList.GetItemN(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.IndexOf(value: TFhirObservationReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirObservationReferenceRangeList.Insert(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirObservationReferenceRangeList.InsertItem(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirObservationReferenceRangeList.Item(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.Link: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Link);
end;

procedure TFhirObservationReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  FhirObservationReferenceRanges[index] := value;
end;

procedure TFhirObservationReferenceRangeList.SetItemN(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationComponent }

constructor TFhirObservationComponent.Create;
begin
  inherited;
end;

destructor TFhirObservationComponent.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirObservationComponent.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirObservationComponent(oSource).name.Clone;
  value := TFhirObservationComponent(oSource).value.Clone;
end;

procedure TFhirObservationComponent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirObservationComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|Attachment|Ratio|Choice|Period|SampledData|string', FValue.Link.Link));{2}
end;

function TFhirObservationComponent.Link : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Link);
end;

function TFhirObservationComponent.Clone : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Clone);
end;

{ TFhirObservationComponent }

Procedure TFhirObservationComponent.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirObservationComponent.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;


{ TFhirObservationComponentList }
procedure TFhirObservationComponentList.AddItem(value: TFhirObservationComponent);
begin
  assert(value.ClassName = 'TFhirObservationComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationComponent');
  add(value);
end;


function TFhirObservationComponentList.Append: TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirObservationComponentList.ClearItems;
begin
  Clear;
end;

function TFhirObservationComponentList.Clone: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Clone);
end;

function TFhirObservationComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationComponentList.GetItemN(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.IndexOf(value: TFhirObservationComponent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirObservationComponentList.Insert(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirObservationComponentList.InsertItem(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  Inherited Insert(index, value);
end;

function TFhirObservationComponentList.Item(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.Link: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Link);
end;

procedure TFhirObservationComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationComponentList.SetItemByIndex(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  FhirObservationComponents[index] := value;
end;

procedure TFhirObservationComponentList.SetItemN(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
  FLocationList := TFhirStringList.Create;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FType_.free;
  FDetails.free;
  FLocationList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TAdvObject);
begin
  inherited;
  FSeverity := TFhirOperationOutcomeIssue(oSource).FSeverity.Link;
  type_ := TFhirOperationOutcomeIssue(oSource).type_.Clone;
  details := TFhirOperationOutcomeIssue(oSource).details.Clone;
  FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'details') Then
     list.add(Details.Link);
  if (child_name = 'location') Then
     list.addAll(FLocationList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'details', 'string', FDetails.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'string', FLocationList.Link)){3};
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

{ TFhirOperationOutcomeIssue }

Procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverity;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverity(0)
  else
    result := TFhirIssueSeverity(StringArrayIndexOf(CODES_TFhirIssueSeverity, Severity.value));
end;

Procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverity);
begin
  if ord(value) = 0 then
    Severity := nil
  else
    Severity := TFhirEnum.create(CODES_TFhirIssueSeverity[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirString);
begin
  FDetails.free;
  FDetails := value;
end;

Function TFhirOperationOutcomeIssue.GetDetailsST : String;
begin
  if FDetails = nil then
    result := ''
  else
    result := Details.value;
end;

Procedure TFhirOperationOutcomeIssue.SetDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FDetails = nil then
      FDetails := TFhirString.create;
    FDetails.value := value
  end
  else if FDetails <> nil then
    FDetails.value := '';
end;


{ TFhirOperationOutcomeIssueList }
procedure TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue);
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
end;


function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOrderWhen }

constructor TFhirOrderWhen.Create;
begin
  inherited;
end;

destructor TFhirOrderWhen.Destroy;
begin
  FCode.free;
  FSchedule.free;
  inherited;
end;

procedure TFhirOrderWhen.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirOrderWhen(oSource).code.Clone;
  schedule := TFhirOrderWhen(oSource).schedule.Clone;
end;

procedure TFhirOrderWhen.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'schedule') Then
     list.add(Schedule.Link);
end;

procedure TFhirOrderWhen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Schedule', FSchedule.Link.Link));{2}
end;

function TFhirOrderWhen.Link : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Link);
end;

function TFhirOrderWhen.Clone : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Clone);
end;

{ TFhirOrderWhen }

Procedure TFhirOrderWhen.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirOrderWhen.SetSchedule(value : TFhirSchedule);
begin
  FSchedule.free;
  FSchedule := value;
end;


{ TFhirOrderWhenList }
procedure TFhirOrderWhenList.AddItem(value: TFhirOrderWhen);
begin
  assert(value.ClassName = 'TFhirOrderWhen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrderWhen');
  add(value);
end;


function TFhirOrderWhenList.Append: TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOrderWhenList.ClearItems;
begin
  Clear;
end;

function TFhirOrderWhenList.Clone: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Clone);
end;

function TFhirOrderWhenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrderWhenList.GetItemN(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.IndexOf(value: TFhirOrderWhen): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOrderWhenList.Insert(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOrderWhenList.InsertItem(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  Inherited Insert(index, value);
end;

function TFhirOrderWhenList.Item(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.Link: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Link);
end;

procedure TFhirOrderWhenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrderWhenList.SetItemByIndex(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  FhirOrderWhens[index] := value;
end;

procedure TFhirOrderWhenList.SetItemN(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  ObjectByIndex[index] := value;
end;

{ TFhirOrganizationContact }

constructor TFhirOrganizationContact.Create;
begin
  inherited;
  FTelecomList := TFhirContactList.Create;
end;

destructor TFhirOrganizationContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  inherited;
end;

procedure TFhirOrganizationContact.Assign(oSource : TAdvObject);
begin
  inherited;
  purpose := TFhirOrganizationContact(oSource).purpose.Clone;
  name := TFhirOrganizationContact(oSource).name.Clone;
  FTelecomList.Assign(TFhirOrganizationContact(oSource).FTelecomList);
  address := TFhirOrganizationContact(oSource).address.Clone;
  gender := TFhirOrganizationContact(oSource).gender.Clone;
end;

procedure TFhirOrganizationContact.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(Purpose.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'telecom') Then
     list.addAll(FTelecomList);
  if (child_name = 'address') Then
     list.add(Address.Link);
  if (child_name = 'gender') Then
     list.add(Gender.Link);
end;

procedure TFhirOrganizationContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', FPurpose.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'Contact', FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', FAddress.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'CodeableConcept', FGender.Link.Link));{2}
end;

function TFhirOrganizationContact.Link : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Link);
end;

function TFhirOrganizationContact.Clone : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Clone);
end;

{ TFhirOrganizationContact }

Procedure TFhirOrganizationContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value;
end;

Procedure TFhirOrganizationContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirOrganizationContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirOrganizationContact.SetGender(value : TFhirCodeableConcept);
begin
  FGender.free;
  FGender := value;
end;


{ TFhirOrganizationContactList }
procedure TFhirOrganizationContactList.AddItem(value: TFhirOrganizationContact);
begin
  assert(value.ClassName = 'TFhirOrganizationContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationContact');
  add(value);
end;


function TFhirOrganizationContactList.Append: TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOrganizationContactList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationContactList.Clone: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Clone);
end;

function TFhirOrganizationContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationContactList.GetItemN(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.IndexOf(value: TFhirOrganizationContact): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOrganizationContactList.Insert(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOrganizationContactList.InsertItem(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  Inherited Insert(index, value);
end;

function TFhirOrganizationContactList.Item(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.Link: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Link);
end;

procedure TFhirOrganizationContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationContactList.SetItemByIndex(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  FhirOrganizationContacts[index] := value;
end;

procedure TFhirOrganizationContactList.SetItemN(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientContact }

constructor TFhirPatientContact.Create;
begin
  inherited;
  FRelationshipList := TFhirCodeableConceptList.Create;
  FTelecomList := TFhirContactList.Create;
end;

destructor TFhirPatientContact.Destroy;
begin
  FRelationshipList.Free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  FOrganization.free;
  inherited;
end;

procedure TFhirPatientContact.Assign(oSource : TAdvObject);
begin
  inherited;
  FRelationshipList.Assign(TFhirPatientContact(oSource).FRelationshipList);
  name := TFhirPatientContact(oSource).name.Clone;
  FTelecomList.Assign(TFhirPatientContact(oSource).FTelecomList);
  address := TFhirPatientContact(oSource).address.Clone;
  gender := TFhirPatientContact(oSource).gender.Clone;
  organization := TFhirPatientContact(oSource).organization.Clone;
end;

procedure TFhirPatientContact.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'relationship') Then
     list.addAll(FRelationshipList);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'telecom') Then
     list.addAll(FTelecomList);
  if (child_name = 'address') Then
     list.add(Address.Link);
  if (child_name = 'gender') Then
     list.add(Gender.Link);
  if (child_name = 'organization') Then
     list.add(Organization.Link);
end;

procedure TFhirPatientContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', FRelationshipList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'Contact', FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', FAddress.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'CodeableConcept', FGender.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Resource(Organization)', FOrganization.Link.Link));{2}
end;

function TFhirPatientContact.Link : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Link);
end;

function TFhirPatientContact.Clone : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Clone);
end;

{ TFhirPatientContact }

Procedure TFhirPatientContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirPatientContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirPatientContact.SetGender(value : TFhirCodeableConcept);
begin
  FGender.free;
  FGender := value;
end;

Procedure TFhirPatientContact.SetOrganization(value : TFhirResourceReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;


{ TFhirPatientContactList }
procedure TFhirPatientContactList.AddItem(value: TFhirPatientContact);
begin
  assert(value.ClassName = 'TFhirPatientContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientContact');
  add(value);
end;


function TFhirPatientContactList.Append: TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientContactList.ClearItems;
begin
  Clear;
end;

function TFhirPatientContactList.Clone: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Clone);
end;

function TFhirPatientContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientContactList.GetItemN(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.IndexOf(value: TFhirPatientContact): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientContactList.Insert(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientContactList.InsertItem(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  Inherited Insert(index, value);
end;

function TFhirPatientContactList.Item(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.Link: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Link);
end;

procedure TFhirPatientContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientContactList.SetItemByIndex(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  FhirPatientContacts[index] := value;
end;

procedure TFhirPatientContactList.SetItemN(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientAnimal }

constructor TFhirPatientAnimal.Create;
begin
  inherited;
end;

destructor TFhirPatientAnimal.Destroy;
begin
  FSpecies.free;
  FBreed.free;
  FGenderStatus.free;
  inherited;
end;

procedure TFhirPatientAnimal.Assign(oSource : TAdvObject);
begin
  inherited;
  species := TFhirPatientAnimal(oSource).species.Clone;
  breed := TFhirPatientAnimal(oSource).breed.Clone;
  genderStatus := TFhirPatientAnimal(oSource).genderStatus.Clone;
end;

procedure TFhirPatientAnimal.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'species') Then
     list.add(Species.Link);
  if (child_name = 'breed') Then
     list.add(Breed.Link);
  if (child_name = 'genderStatus') Then
     list.add(GenderStatus.Link);
end;

procedure TFhirPatientAnimal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', FSpecies.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'breed', 'CodeableConcept', FBreed.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'genderStatus', 'CodeableConcept', FGenderStatus.Link.Link));{2}
end;

function TFhirPatientAnimal.Link : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(inherited Link);
end;

function TFhirPatientAnimal.Clone : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(inherited Clone);
end;

{ TFhirPatientAnimal }

Procedure TFhirPatientAnimal.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

Procedure TFhirPatientAnimal.SetBreed(value : TFhirCodeableConcept);
begin
  FBreed.free;
  FBreed := value;
end;

Procedure TFhirPatientAnimal.SetGenderStatus(value : TFhirCodeableConcept);
begin
  FGenderStatus.free;
  FGenderStatus := value;
end;


{ TFhirPatientAnimalList }
procedure TFhirPatientAnimalList.AddItem(value: TFhirPatientAnimal);
begin
  assert(value.ClassName = 'TFhirPatientAnimal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientAnimal');
  add(value);
end;


function TFhirPatientAnimalList.Append: TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientAnimalList.ClearItems;
begin
  Clear;
end;

function TFhirPatientAnimalList.Clone: TFhirPatientAnimalList;
begin
  result := TFhirPatientAnimalList(inherited Clone);
end;

function TFhirPatientAnimalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientAnimalList.GetItemN(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(ObjectByIndex[index]);
end;

function TFhirPatientAnimalList.IndexOf(value: TFhirPatientAnimal): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientAnimalList.Insert(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientAnimalList.InsertItem(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  Inherited Insert(index, value);
end;

function TFhirPatientAnimalList.Item(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(ObjectByIndex[index]);
end;

function TFhirPatientAnimalList.Link: TFhirPatientAnimalList;
begin
  result := TFhirPatientAnimalList(inherited Link);
end;

procedure TFhirPatientAnimalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientAnimalList.SetItemByIndex(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  FhirPatientAnimals[index] := value;
end;

procedure TFhirPatientAnimalList.SetItemN(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerQualification }

constructor TFhirPractitionerQualification.Create;
begin
  inherited;
end;

destructor TFhirPractitionerQualification.Destroy;
begin
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirPractitionerQualification.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirPractitionerQualification(oSource).code.Clone;
  period := TFhirPractitionerQualification(oSource).period.Clone;
  issuer := TFhirPractitionerQualification(oSource).issuer.Clone;
end;

procedure TFhirPractitionerQualification.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'issuer') Then
     list.add(Issuer.Link);
end;

procedure TFhirPractitionerQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issuer', 'Resource(Organization)', FIssuer.Link.Link));{2}
end;

function TFhirPractitionerQualification.Link : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Link);
end;

function TFhirPractitionerQualification.Clone : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Clone);
end;

{ TFhirPractitionerQualification }

Procedure TFhirPractitionerQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirPractitionerQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPractitionerQualification.SetIssuer(value : TFhirResourceReference{TFhirOrganization});
begin
  FIssuer.free;
  FIssuer := value;
end;


{ TFhirPractitionerQualificationList }
procedure TFhirPractitionerQualificationList.AddItem(value: TFhirPractitionerQualification);
begin
  assert(value.ClassName = 'TFhirPractitionerQualification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerQualification');
  add(value);
end;


function TFhirPractitionerQualificationList.Append: TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPractitionerQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerQualificationList.Clone: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Clone);
end;

function TFhirPractitionerQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerQualificationList.GetItemN(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.IndexOf(value: TFhirPractitionerQualification): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPractitionerQualificationList.Insert(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPractitionerQualificationList.InsertItem(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  Inherited Insert(index, value);
end;

function TFhirPractitionerQualificationList.Item(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.Link: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Link);
end;

procedure TFhirPractitionerQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerQualificationList.SetItemByIndex(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  FhirPractitionerQualifications[index] := value;
end;

procedure TFhirPractitionerQualificationList.SetItemN(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedurePerformer }

constructor TFhirProcedurePerformer.Create;
begin
  inherited;
end;

destructor TFhirProcedurePerformer.Destroy;
begin
  FPerson.free;
  FRole.free;
  inherited;
end;

procedure TFhirProcedurePerformer.Assign(oSource : TAdvObject);
begin
  inherited;
  person := TFhirProcedurePerformer(oSource).person.Clone;
  role := TFhirProcedurePerformer(oSource).role.Clone;
end;

procedure TFhirProcedurePerformer.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'person') Then
     list.add(Person.Link);
  if (child_name = 'role') Then
     list.add(Role.Link);
end;

procedure TFhirProcedurePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'person', 'Resource(Practitioner)', FPerson.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRole.Link.Link));{2}
end;

function TFhirProcedurePerformer.Link : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Link);
end;

function TFhirProcedurePerformer.Clone : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Clone);
end;

{ TFhirProcedurePerformer }

Procedure TFhirProcedurePerformer.SetPerson(value : TFhirResourceReference{TFhirPractitioner});
begin
  FPerson.free;
  FPerson := value;
end;

Procedure TFhirProcedurePerformer.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;


{ TFhirProcedurePerformerList }
procedure TFhirProcedurePerformerList.AddItem(value: TFhirProcedurePerformer);
begin
  assert(value.ClassName = 'TFhirProcedurePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedurePerformer');
  add(value);
end;


function TFhirProcedurePerformerList.Append: TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProcedurePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirProcedurePerformerList.Clone: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Clone);
end;

function TFhirProcedurePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedurePerformerList.GetItemN(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.IndexOf(value: TFhirProcedurePerformer): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProcedurePerformerList.Insert(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProcedurePerformerList.InsertItem(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  Inherited Insert(index, value);
end;

function TFhirProcedurePerformerList.Item(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.Link: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Link);
end;

procedure TFhirProcedurePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedurePerformerList.SetItemByIndex(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  FhirProcedurePerformers[index] := value;
end;

procedure TFhirProcedurePerformerList.SetItemN(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureRelatedItem }

constructor TFhirProcedureRelatedItem.Create;
begin
  inherited;
end;

destructor TFhirProcedureRelatedItem.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirProcedureRelatedItem.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirProcedureRelatedItem(oSource).FType_.Link;
  target := TFhirProcedureRelatedItem(oSource).target.Clone;
end;

procedure TFhirProcedureRelatedItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
end;

procedure TFhirProcedureRelatedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Procedure|MedicationPrescription)', FTarget.Link.Link));{2}
end;

function TFhirProcedureRelatedItem.Link : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(inherited Link);
end;

function TFhirProcedureRelatedItem.Clone : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(inherited Clone);
end;

{ TFhirProcedureRelatedItem }

Procedure TFhirProcedureRelatedItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProcedureRelatedItem.GetType_ST : TFhirProcedureRelationshipType;
begin
  if FType_ = nil then
    result := TFhirProcedureRelationshipType(0)
  else
    result := TFhirProcedureRelationshipType(StringArrayIndexOf(CODES_TFhirProcedureRelationshipType, Type_.value));
end;

Procedure TFhirProcedureRelatedItem.SetType_ST(value : TFhirProcedureRelationshipType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirProcedureRelationshipType[value]);
end;

Procedure TFhirProcedureRelatedItem.SetTarget(value : TFhirResourceReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirProcedureRelatedItemList }
procedure TFhirProcedureRelatedItemList.AddItem(value: TFhirProcedureRelatedItem);
begin
  assert(value.ClassName = 'TFhirProcedureRelatedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureRelatedItem');
  add(value);
end;


function TFhirProcedureRelatedItemList.Append: TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProcedureRelatedItemList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureRelatedItemList.Clone: TFhirProcedureRelatedItemList;
begin
  result := TFhirProcedureRelatedItemList(inherited Clone);
end;

function TFhirProcedureRelatedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureRelatedItemList.GetItemN(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(ObjectByIndex[index]);
end;

function TFhirProcedureRelatedItemList.IndexOf(value: TFhirProcedureRelatedItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProcedureRelatedItemList.Insert(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProcedureRelatedItemList.InsertItem(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  Inherited Insert(index, value);
end;

function TFhirProcedureRelatedItemList.Item(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(ObjectByIndex[index]);
end;

function TFhirProcedureRelatedItemList.Link: TFhirProcedureRelatedItemList;
begin
  result := TFhirProcedureRelatedItemList(inherited Link);
end;

procedure TFhirProcedureRelatedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureRelatedItemList.SetItemByIndex(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  FhirProcedureRelatedItems[index] := value;
end;

procedure TFhirProcedureRelatedItemList.SetItemN(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructure }

constructor TFhirProfileStructure.Create;
begin
  inherited;
  FElementList := TFhirProfileStructureElementList.Create;
end;

destructor TFhirProfileStructure.Destroy;
begin
  FType_.free;
  FName.free;
  FPublish.free;
  FPurpose.free;
  FElementList.Free;
  inherited;
end;

procedure TFhirProfileStructure.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirProfileStructure(oSource).type_.Clone;
  name := TFhirProfileStructure(oSource).name.Clone;
  publish := TFhirProfileStructure(oSource).publish.Clone;
  purpose := TFhirProfileStructure(oSource).purpose.Clone;
  FElementList.Assign(TFhirProfileStructure(oSource).FElementList);
end;

procedure TFhirProfileStructure.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'publish') Then
     list.add(Publish.Link);
  if (child_name = 'purpose') Then
     list.add(Purpose.Link);
  if (child_name = 'element') Then
     list.addAll(FElementList);
end;

procedure TFhirProfileStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publish', 'boolean', FPublish.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'string', FPurpose.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'element', '', FElementList.Link)){3};
end;

function TFhirProfileStructure.Link : TFhirProfileStructure;
begin
  result := TFhirProfileStructure(inherited Link);
end;

function TFhirProfileStructure.Clone : TFhirProfileStructure;
begin
  result := TFhirProfileStructure(inherited Clone);
end;

{ TFhirProfileStructure }

Procedure TFhirProfileStructure.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProfileStructure.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirProfileStructure.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirProfileStructure.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructure.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructure.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructure.SetPublish(value : TFhirBoolean);
begin
  FPublish.free;
  FPublish := value;
end;

Function TFhirProfileStructure.GetPublishST : String;
begin
  if FPublish = nil then
    result := ''
  else
    result := Publish.value;
end;

Procedure TFhirProfileStructure.SetPublishST(value : String);
begin
  if value <> '' then
  begin
    if FPublish = nil then
      FPublish := TFhirBoolean.create;
    FPublish.value := value
  end
  else if FPublish <> nil then
    FPublish.value := '';
end;

Procedure TFhirProfileStructure.SetPurpose(value : TFhirString);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirProfileStructure.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := Purpose.value;
end;

Procedure TFhirProfileStructure.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirString.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;


{ TFhirProfileStructureList }
procedure TFhirProfileStructureList.AddItem(value: TFhirProfileStructure);
begin
  assert(value.ClassName = 'TFhirProfileStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructure');
  add(value);
end;


function TFhirProfileStructureList.Append: TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureList.Clone: TFhirProfileStructureList;
begin
  result := TFhirProfileStructureList(inherited Clone);
end;

function TFhirProfileStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureList.GetItemN(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure(ObjectByIndex[index]);
end;

function TFhirProfileStructureList.IndexOf(value: TFhirProfileStructure): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureList.Insert(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureList.InsertItem(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureList.Item(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure(ObjectByIndex[index]);
end;

function TFhirProfileStructureList.Link: TFhirProfileStructureList;
begin
  result := TFhirProfileStructureList(inherited Link);
end;

procedure TFhirProfileStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureList.SetItemByIndex(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  FhirProfileStructures[index] := value;
end;

procedure TFhirProfileStructureList.SetItemN(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElement }

constructor TFhirProfileStructureElement.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElement.Destroy;
begin
  FPath.free;
  FName.free;
  FSlicing.free;
  FDefinition.free;
  inherited;
end;

procedure TFhirProfileStructureElement.Assign(oSource : TAdvObject);
begin
  inherited;
  path := TFhirProfileStructureElement(oSource).path.Clone;
  name := TFhirProfileStructureElement(oSource).name.Clone;
  slicing := TFhirProfileStructureElement(oSource).slicing.Clone;
  definition := TFhirProfileStructureElement(oSource).definition.Clone;
end;

procedure TFhirProfileStructureElement.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(Path.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'slicing') Then
     list.add(Slicing.Link);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
end;

procedure TFhirProfileStructureElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', FPath.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'slicing', '', FSlicing.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', '', FDefinition.Link.Link));{2}
end;

function TFhirProfileStructureElement.Link : TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(inherited Link);
end;

function TFhirProfileStructureElement.Clone : TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(inherited Clone);
end;

{ TFhirProfileStructureElement }

Procedure TFhirProfileStructureElement.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirProfileStructureElement.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := Path.value;
end;

Procedure TFhirProfileStructureElement.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirProfileStructureElement.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElement.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructureElement.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElement.SetSlicing(value : TFhirProfileStructureElementSlicing);
begin
  FSlicing.free;
  FSlicing := value;
end;

Procedure TFhirProfileStructureElement.SetDefinition(value : TFhirProfileStructureElementDefinition);
begin
  FDefinition.free;
  FDefinition := value;
end;


{ TFhirProfileStructureElementList }
procedure TFhirProfileStructureElementList.AddItem(value: TFhirProfileStructureElement);
begin
  assert(value.ClassName = 'TFhirProfileStructureElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElement');
  add(value);
end;


function TFhirProfileStructureElementList.Append: TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementList.Clone: TFhirProfileStructureElementList;
begin
  result := TFhirProfileStructureElementList(inherited Clone);
end;

function TFhirProfileStructureElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementList.GetItemN(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementList.IndexOf(value: TFhirProfileStructureElement): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementList.Insert(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementList.InsertItem(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementList.Item(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementList.Link: TFhirProfileStructureElementList;
begin
  result := TFhirProfileStructureElementList(inherited Link);
end;

procedure TFhirProfileStructureElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  FhirProfileStructureElements[index] := value;
end;

procedure TFhirProfileStructureElementList.SetItemN(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementSlicing }

constructor TFhirProfileStructureElementSlicing.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementSlicing.Destroy;
begin
  FDiscriminator.free;
  FOrdered.free;
  FRules.free;
  inherited;
end;

procedure TFhirProfileStructureElementSlicing.Assign(oSource : TAdvObject);
begin
  inherited;
  discriminator := TFhirProfileStructureElementSlicing(oSource).discriminator.Clone;
  ordered := TFhirProfileStructureElementSlicing(oSource).ordered.Clone;
  FRules := TFhirProfileStructureElementSlicing(oSource).FRules.Link;
end;

procedure TFhirProfileStructureElementSlicing.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'discriminator') Then
     list.add(Discriminator.Link);
  if (child_name = 'ordered') Then
     list.add(Ordered.Link);
  if (child_name = 'rules') Then
     list.add(FRules.Link);
end;

procedure TFhirProfileStructureElementSlicing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'discriminator', 'id', FDiscriminator.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ordered', 'boolean', FOrdered.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rules', 'code', FRules.Link));{1}
end;

function TFhirProfileStructureElementSlicing.Link : TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(inherited Link);
end;

function TFhirProfileStructureElementSlicing.Clone : TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(inherited Clone);
end;

{ TFhirProfileStructureElementSlicing }

Procedure TFhirProfileStructureElementSlicing.SetDiscriminator(value : TFhirId);
begin
  FDiscriminator.free;
  FDiscriminator := value;
end;

Function TFhirProfileStructureElementSlicing.GetDiscriminatorST : String;
begin
  if FDiscriminator = nil then
    result := ''
  else
    result := Discriminator.value;
end;

Procedure TFhirProfileStructureElementSlicing.SetDiscriminatorST(value : String);
begin
  if value <> '' then
  begin
    if FDiscriminator = nil then
      FDiscriminator := TFhirId.create;
    FDiscriminator.value := value
  end
  else if FDiscriminator <> nil then
    FDiscriminator.value := '';
end;

Procedure TFhirProfileStructureElementSlicing.SetOrdered(value : TFhirBoolean);
begin
  FOrdered.free;
  FOrdered := value;
end;

Function TFhirProfileStructureElementSlicing.GetOrderedST : String;
begin
  if FOrdered = nil then
    result := ''
  else
    result := Ordered.value;
end;

Procedure TFhirProfileStructureElementSlicing.SetOrderedST(value : String);
begin
  if value <> '' then
  begin
    if FOrdered = nil then
      FOrdered := TFhirBoolean.create;
    FOrdered.value := value
  end
  else if FOrdered <> nil then
    FOrdered.value := '';
end;

Procedure TFhirProfileStructureElementSlicing.SetRules(value : TFhirEnum);
begin
  FRules.free;
  FRules := value;
end;

Function TFhirProfileStructureElementSlicing.GetRulesST : TFhirResourceSlicingRules;
begin
  if FRules = nil then
    result := TFhirResourceSlicingRules(0)
  else
    result := TFhirResourceSlicingRules(StringArrayIndexOf(CODES_TFhirResourceSlicingRules, Rules.value));
end;

Procedure TFhirProfileStructureElementSlicing.SetRulesST(value : TFhirResourceSlicingRules);
begin
  if ord(value) = 0 then
    Rules := nil
  else
    Rules := TFhirEnum.create(CODES_TFhirResourceSlicingRules[value]);
end;


{ TFhirProfileStructureElementSlicingList }
procedure TFhirProfileStructureElementSlicingList.AddItem(value: TFhirProfileStructureElementSlicing);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementSlicing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementSlicing');
  add(value);
end;


function TFhirProfileStructureElementSlicingList.Append: TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementSlicingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementSlicingList.Clone: TFhirProfileStructureElementSlicingList;
begin
  result := TFhirProfileStructureElementSlicingList(inherited Clone);
end;

function TFhirProfileStructureElementSlicingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementSlicingList.GetItemN(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementSlicingList.IndexOf(value: TFhirProfileStructureElementSlicing): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementSlicingList.Insert(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementSlicingList.InsertItem(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementSlicingList.Item(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementSlicingList.Link: TFhirProfileStructureElementSlicingList;
begin
  result := TFhirProfileStructureElementSlicingList(inherited Link);
end;

procedure TFhirProfileStructureElementSlicingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementSlicingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  FhirProfileStructureElementSlicings[index] := value;
end;

procedure TFhirProfileStructureElementSlicingList.SetItemN(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinition }

constructor TFhirProfileStructureElementDefinition.Create;
begin
  inherited;
  FSynonymList := TFhirStringList.Create;
  FType_List := TFhirProfileStructureElementDefinitionTypeList.Create;
  FConditionList := TFhirIdList.Create;
  FConstraintList := TFhirProfileStructureElementDefinitionConstraintList.Create;
  FMappingList := TFhirProfileStructureElementDefinitionMappingList.Create;
end;

destructor TFhirProfileStructureElementDefinition.Destroy;
begin
  FShort.free;
  FFormal.free;
  FComments.free;
  FRequirements.free;
  FSynonymList.Free;
  FMin.free;
  FMax.free;
  FType_List.Free;
  FNameReference.free;
  FValue.free;
  FExample.free;
  FMaxLength.free;
  FConditionList.Free;
  FConstraintList.Free;
  FMustSupport.free;
  FIsModifier.free;
  FBinding.free;
  FMappingList.Free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinition.Assign(oSource : TAdvObject);
begin
  inherited;
  short := TFhirProfileStructureElementDefinition(oSource).short.Clone;
  formal := TFhirProfileStructureElementDefinition(oSource).formal.Clone;
  comments := TFhirProfileStructureElementDefinition(oSource).comments.Clone;
  requirements := TFhirProfileStructureElementDefinition(oSource).requirements.Clone;
  FSynonymList.Assign(TFhirProfileStructureElementDefinition(oSource).FSynonymList);
  min := TFhirProfileStructureElementDefinition(oSource).min.Clone;
  max := TFhirProfileStructureElementDefinition(oSource).max.Clone;
  FType_List.Assign(TFhirProfileStructureElementDefinition(oSource).FType_List);
  nameReference := TFhirProfileStructureElementDefinition(oSource).nameReference.Clone;
  value := TFhirProfileStructureElementDefinition(oSource).value.Clone;
  example := TFhirProfileStructureElementDefinition(oSource).example.Clone;
  maxLength := TFhirProfileStructureElementDefinition(oSource).maxLength.Clone;
  FConditionList.Assign(TFhirProfileStructureElementDefinition(oSource).FConditionList);
  FConstraintList.Assign(TFhirProfileStructureElementDefinition(oSource).FConstraintList);
  mustSupport := TFhirProfileStructureElementDefinition(oSource).mustSupport.Clone;
  isModifier := TFhirProfileStructureElementDefinition(oSource).isModifier.Clone;
  binding := TFhirProfileStructureElementDefinition(oSource).binding.Clone;
  FMappingList.Assign(TFhirProfileStructureElementDefinition(oSource).FMappingList);
end;

procedure TFhirProfileStructureElementDefinition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'short') Then
     list.add(Short.Link);
  if (child_name = 'formal') Then
     list.add(Formal.Link);
  if (child_name = 'comments') Then
     list.add(Comments.Link);
  if (child_name = 'requirements') Then
     list.add(Requirements.Link);
  if (child_name = 'synonym') Then
     list.addAll(FSynonymList);
  if (child_name = 'min') Then
     list.add(Min.Link);
  if (child_name = 'max') Then
     list.add(Max.Link);
  if (child_name = 'type_') Then
     list.addAll(FType_List);
  if (child_name = 'nameReference') Then
     list.add(NameReference.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
  if (child_name = 'example') Then
     list.add(Example.Link);
  if (child_name = 'maxLength') Then
     list.add(MaxLength.Link);
  if (child_name = 'condition') Then
     list.addAll(FConditionList);
  if (child_name = 'constraint') Then
     list.addAll(FConstraintList);
  if (child_name = 'mustSupport') Then
     list.add(MustSupport.Link);
  if (child_name = 'isModifier') Then
     list.add(IsModifier.Link);
  if (child_name = 'binding') Then
     list.add(Binding.Link);
  if (child_name = 'mapping') Then
     list.addAll(FMappingList);
end;

procedure TFhirProfileStructureElementDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'short', 'string', FShort.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'formal', 'string', FFormal.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', FComments.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', FRequirements.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'synonym', 'string', FSynonymList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'min', 'integer', FMin.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', FMax.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', '', FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'nameReference', 'string', FNameReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', '*', FValue.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'example[x]', '*', FExample.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxLength', 'integer', FMaxLength.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', 'id', FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'constraint', '', FConstraintList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'mustSupport', 'boolean', FMustSupport.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isModifier', 'boolean', FIsModifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'binding', 'uri', FBinding.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mapping', '', FMappingList.Link)){3};
end;

function TFhirProfileStructureElementDefinition.Link : TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(inherited Link);
end;

function TFhirProfileStructureElementDefinition.Clone : TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(inherited Clone);
end;

{ TFhirProfileStructureElementDefinition }

Procedure TFhirProfileStructureElementDefinition.SetShort(value : TFhirString);
begin
  FShort.free;
  FShort := value;
end;

Function TFhirProfileStructureElementDefinition.GetShortST : String;
begin
  if FShort = nil then
    result := ''
  else
    result := Short.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetShortST(value : String);
begin
  if value <> '' then
  begin
    if FShort = nil then
      FShort := TFhirString.create;
    FShort.value := value
  end
  else if FShort <> nil then
    FShort.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetFormal(value : TFhirString);
begin
  FFormal.free;
  FFormal := value;
end;

Function TFhirProfileStructureElementDefinition.GetFormalST : String;
begin
  if FFormal = nil then
    result := ''
  else
    result := Formal.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetFormalST(value : String);
begin
  if value <> '' then
  begin
    if FFormal = nil then
      FFormal := TFhirString.create;
    FFormal.value := value
  end
  else if FFormal <> nil then
    FFormal.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirProfileStructureElementDefinition.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := Comments.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirProfileStructureElementDefinition.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := Requirements.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirProfileStructureElementDefinition.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := Min.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirProfileStructureElementDefinition.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := Max.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetNameReference(value : TFhirString);
begin
  FNameReference.free;
  FNameReference := value;
end;

Function TFhirProfileStructureElementDefinition.GetNameReferenceST : String;
begin
  if FNameReference = nil then
    result := ''
  else
    result := NameReference.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetNameReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FNameReference = nil then
      FNameReference := TFhirString.create;
    FNameReference.value := value
  end
  else if FNameReference <> nil then
    FNameReference.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirProfileStructureElementDefinition.SetExample(value : TFhirType);
begin
  FExample.free;
  FExample := value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxLength(value : TFhirInteger);
begin
  FMaxLength.free;
  FMaxLength := value;
end;

Function TFhirProfileStructureElementDefinition.GetMaxLengthST : String;
begin
  if FMaxLength = nil then
    result := ''
  else
    result := MaxLength.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxLengthST(value : String);
begin
  if value <> '' then
  begin
    if FMaxLength = nil then
      FMaxLength := TFhirInteger.create;
    FMaxLength.value := value
  end
  else if FMaxLength <> nil then
    FMaxLength.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMustSupport(value : TFhirBoolean);
begin
  FMustSupport.free;
  FMustSupport := value;
end;

Function TFhirProfileStructureElementDefinition.GetMustSupportST : String;
begin
  if FMustSupport = nil then
    result := ''
  else
    result := MustSupport.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMustSupportST(value : String);
begin
  if value <> '' then
  begin
    if FMustSupport = nil then
      FMustSupport := TFhirBoolean.create;
    FMustSupport.value := value
  end
  else if FMustSupport <> nil then
    FMustSupport.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetIsModifier(value : TFhirBoolean);
begin
  FIsModifier.free;
  FIsModifier := value;
end;

Function TFhirProfileStructureElementDefinition.GetIsModifierST : String;
begin
  if FIsModifier = nil then
    result := ''
  else
    result := IsModifier.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetIsModifierST(value : String);
begin
  if value <> '' then
  begin
    if FIsModifier = nil then
      FIsModifier := TFhirBoolean.create;
    FIsModifier.value := value
  end
  else if FIsModifier <> nil then
    FIsModifier.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetBinding(value : TFhirUri);
begin
  FBinding.free;
  FBinding := value;
end;

Function TFhirProfileStructureElementDefinition.GetBindingST : String;
begin
  if FBinding = nil then
    result := ''
  else
    result := Binding.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetBindingST(value : String);
begin
  if value <> '' then
  begin
    if FBinding = nil then
      FBinding := TFhirUri.create;
    FBinding.value := value
  end
  else if FBinding <> nil then
    FBinding.value := '';
end;


{ TFhirProfileStructureElementDefinitionList }
procedure TFhirProfileStructureElementDefinitionList.AddItem(value: TFhirProfileStructureElementDefinition);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinition');
  add(value);
end;


function TFhirProfileStructureElementDefinitionList.Append: TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionList.Clone: TFhirProfileStructureElementDefinitionList;
begin
  result := TFhirProfileStructureElementDefinitionList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionList.GetItemN(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionList.IndexOf(value: TFhirProfileStructureElementDefinition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionList.Insert(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionList.Item(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionList.Link: TFhirProfileStructureElementDefinitionList;
begin
  result := TFhirProfileStructureElementDefinitionList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  FhirProfileStructureElementDefinitions[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionType }

constructor TFhirProfileStructureElementDefinitionType.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionType.Destroy;
begin
  FCode.free;
  FProfile.free;
  FBundled.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionType.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirProfileStructureElementDefinitionType(oSource).code.Clone;
  profile := TFhirProfileStructureElementDefinitionType(oSource).profile.Clone;
  bundled := TFhirProfileStructureElementDefinitionType(oSource).bundled.Clone;
end;

procedure TFhirProfileStructureElementDefinitionType.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'profile') Then
     list.add(Profile.Link);
  if (child_name = 'bundled') Then
     list.add(Bundled.Link);
end;

procedure TFhirProfileStructureElementDefinitionType.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'uri', FProfile.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bundled', 'boolean', FBundled.Link.Link));{2}
end;

function TFhirProfileStructureElementDefinitionType.Link : TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(inherited Link);
end;

function TFhirProfileStructureElementDefinitionType.Clone : TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionType }

Procedure TFhirProfileStructureElementDefinitionType.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirProfileStructureElementDefinitionType.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirProfileStructureElementDefinitionType.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionType.SetProfile(value : TFhirUri);
begin
  FProfile.free;
  FProfile := value;
end;

Function TFhirProfileStructureElementDefinitionType.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := Profile.value;
end;

Procedure TFhirProfileStructureElementDefinitionType.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirUri.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionType.SetBundled(value : TFhirBoolean);
begin
  FBundled.free;
  FBundled := value;
end;

Function TFhirProfileStructureElementDefinitionType.GetBundledST : String;
begin
  if FBundled = nil then
    result := ''
  else
    result := Bundled.value;
end;

Procedure TFhirProfileStructureElementDefinitionType.SetBundledST(value : String);
begin
  if value <> '' then
  begin
    if FBundled = nil then
      FBundled := TFhirBoolean.create;
    FBundled.value := value
  end
  else if FBundled <> nil then
    FBundled.value := '';
end;


{ TFhirProfileStructureElementDefinitionTypeList }
procedure TFhirProfileStructureElementDefinitionTypeList.AddItem(value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionType', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionType');
  add(value);
end;


function TFhirProfileStructureElementDefinitionTypeList.Append: TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionTypeList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionTypeList.Clone: TFhirProfileStructureElementDefinitionTypeList;
begin
  result := TFhirProfileStructureElementDefinitionTypeList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionTypeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionTypeList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionTypeList.IndexOf(value: TFhirProfileStructureElementDefinitionType): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionTypeList.Insert(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionTypeList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionTypeList.Item(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionTypeList.Link: TFhirProfileStructureElementDefinitionTypeList;
begin
  result := TFhirProfileStructureElementDefinitionTypeList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionTypeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionTypeList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  FhirProfileStructureElementDefinitionTypes[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionTypeList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionConstraint }

constructor TFhirProfileStructureElementDefinitionConstraint.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionConstraint.Destroy;
begin
  FKey.free;
  FName.free;
  FSeverity.free;
  FHuman.free;
  FXpath.free;
  FOcl.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionConstraint.Assign(oSource : TAdvObject);
begin
  inherited;
  key := TFhirProfileStructureElementDefinitionConstraint(oSource).key.Clone;
  name := TFhirProfileStructureElementDefinitionConstraint(oSource).name.Clone;
  FSeverity := TFhirProfileStructureElementDefinitionConstraint(oSource).FSeverity.Link;
  human := TFhirProfileStructureElementDefinitionConstraint(oSource).human.Clone;
  xpath := TFhirProfileStructureElementDefinitionConstraint(oSource).xpath.Clone;
  ocl := TFhirProfileStructureElementDefinitionConstraint(oSource).ocl.Clone;
end;

procedure TFhirProfileStructureElementDefinitionConstraint.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'key') Then
     list.add(Key.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
  if (child_name = 'human') Then
     list.add(Human.Link);
  if (child_name = 'xpath') Then
     list.add(Xpath.Link);
  if (child_name = 'ocl') Then
     list.add(Ocl.Link);
end;

procedure TFhirProfileStructureElementDefinitionConstraint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'key', 'id', FKey.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'human', 'string', FHuman.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', FXpath.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ocl', 'string', FOcl.Link.Link));{2}
end;

function TFhirProfileStructureElementDefinitionConstraint.Link : TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(inherited Link);
end;

function TFhirProfileStructureElementDefinitionConstraint.Clone : TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionConstraint }

Procedure TFhirProfileStructureElementDefinitionConstraint.SetKey(value : TFhirId);
begin
  FKey.free;
  FKey := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetKeyST : String;
begin
  if FKey = nil then
    result := ''
  else
    result := Key.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetKeyST(value : String);
begin
  if value <> '' then
  begin
    if FKey = nil then
      FKey := TFhirId.create;
    FKey.value := value
  end
  else if FKey <> nil then
    FKey.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetSeverityST : TFhirConstraintSeverity;
begin
  if FSeverity = nil then
    result := TFhirConstraintSeverity(0)
  else
    result := TFhirConstraintSeverity(StringArrayIndexOf(CODES_TFhirConstraintSeverity, Severity.value));
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetSeverityST(value : TFhirConstraintSeverity);
begin
  if ord(value) = 0 then
    Severity := nil
  else
    Severity := TFhirEnum.create(CODES_TFhirConstraintSeverity[value]);
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetHuman(value : TFhirString);
begin
  FHuman.free;
  FHuman := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetHumanST : String;
begin
  if FHuman = nil then
    result := ''
  else
    result := Human.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetHumanST(value : String);
begin
  if value <> '' then
  begin
    if FHuman = nil then
      FHuman := TFhirString.create;
    FHuman.value := value
  end
  else if FHuman <> nil then
    FHuman.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := Xpath.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetOcl(value : TFhirString);
begin
  FOcl.free;
  FOcl := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetOclST : String;
begin
  if FOcl = nil then
    result := ''
  else
    result := Ocl.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetOclST(value : String);
begin
  if value <> '' then
  begin
    if FOcl = nil then
      FOcl := TFhirString.create;
    FOcl.value := value
  end
  else if FOcl <> nil then
    FOcl.value := '';
end;


{ TFhirProfileStructureElementDefinitionConstraintList }
procedure TFhirProfileStructureElementDefinitionConstraintList.AddItem(value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionConstraint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionConstraint');
  add(value);
end;


function TFhirProfileStructureElementDefinitionConstraintList.Append: TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionConstraintList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionConstraintList.Clone: TFhirProfileStructureElementDefinitionConstraintList;
begin
  result := TFhirProfileStructureElementDefinitionConstraintList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionConstraintList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionConstraintList.IndexOf(value: TFhirProfileStructureElementDefinitionConstraint): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionConstraintList.Insert(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionConstraintList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Item(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Link: TFhirProfileStructureElementDefinitionConstraintList;
begin
  result := TFhirProfileStructureElementDefinitionConstraintList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  FhirProfileStructureElementDefinitionConstraints[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionMapping }

constructor TFhirProfileStructureElementDefinitionMapping.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionMapping.Destroy;
begin
  FTarget.free;
  FMap.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionMapping.Assign(oSource : TAdvObject);
begin
  inherited;
  target := TFhirProfileStructureElementDefinitionMapping(oSource).target.Clone;
  map := TFhirProfileStructureElementDefinitionMapping(oSource).map.Clone;
end;

procedure TFhirProfileStructureElementDefinitionMapping.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(Target.Link);
  if (child_name = 'map') Then
     list.add(Map.Link);
end;

procedure TFhirProfileStructureElementDefinitionMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'uri', FTarget.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'map', 'string', FMap.Link.Link));{2}
end;

function TFhirProfileStructureElementDefinitionMapping.Link : TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(inherited Link);
end;

function TFhirProfileStructureElementDefinitionMapping.Clone : TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionMapping }

Procedure TFhirProfileStructureElementDefinitionMapping.SetTarget(value : TFhirUri);
begin
  FTarget.free;
  FTarget := value;
end;

Function TFhirProfileStructureElementDefinitionMapping.GetTargetST : String;
begin
  if FTarget = nil then
    result := ''
  else
    result := Target.value;
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetTargetST(value : String);
begin
  if value <> '' then
  begin
    if FTarget = nil then
      FTarget := TFhirUri.create;
    FTarget.value := value
  end
  else if FTarget <> nil then
    FTarget.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetMap(value : TFhirString);
begin
  FMap.free;
  FMap := value;
end;

Function TFhirProfileStructureElementDefinitionMapping.GetMapST : String;
begin
  if FMap = nil then
    result := ''
  else
    result := Map.value;
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetMapST(value : String);
begin
  if value <> '' then
  begin
    if FMap = nil then
      FMap := TFhirString.create;
    FMap.value := value
  end
  else if FMap <> nil then
    FMap.value := '';
end;


{ TFhirProfileStructureElementDefinitionMappingList }
procedure TFhirProfileStructureElementDefinitionMappingList.AddItem(value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionMapping');
  add(value);
end;


function TFhirProfileStructureElementDefinitionMappingList.Append: TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionMappingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionMappingList.Clone: TFhirProfileStructureElementDefinitionMappingList;
begin
  result := TFhirProfileStructureElementDefinitionMappingList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionMappingList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionMappingList.IndexOf(value: TFhirProfileStructureElementDefinitionMapping): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionMappingList.Insert(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionMappingList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionMappingList.Item(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionMappingList.Link: TFhirProfileStructureElementDefinitionMappingList;
begin
  result := TFhirProfileStructureElementDefinitionMappingList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionMappingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  FhirProfileStructureElementDefinitionMappings[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionMappingList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileExtensionDefn }

constructor TFhirProfileExtensionDefn.Create;
begin
  inherited;
  FContextList := TFhirStringList.Create;
end;

destructor TFhirProfileExtensionDefn.Destroy;
begin
  FCode.free;
  FContextType.free;
  FContextList.Free;
  FDefinition.free;
  inherited;
end;

procedure TFhirProfileExtensionDefn.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirProfileExtensionDefn(oSource).code.Clone;
  FContextType := TFhirProfileExtensionDefn(oSource).FContextType.Link;
  FContextList.Assign(TFhirProfileExtensionDefn(oSource).FContextList);
  definition := TFhirProfileExtensionDefn(oSource).definition.Clone;
end;

procedure TFhirProfileExtensionDefn.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'contextType') Then
     list.add(FContextType.Link);
  if (child_name = 'context') Then
     list.addAll(FContextList);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
end;

procedure TFhirProfileExtensionDefn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contextType', 'code', FContextType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'context', 'string', FContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', '@Profile.structure.element.definition', FDefinition.Link.Link));{2}
end;

function TFhirProfileExtensionDefn.Link : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(inherited Link);
end;

function TFhirProfileExtensionDefn.Clone : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(inherited Clone);
end;

{ TFhirProfileExtensionDefn }

Procedure TFhirProfileExtensionDefn.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirProfileExtensionDefn.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirProfileExtensionDefn.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirProfileExtensionDefn.SetContextType(value : TFhirEnum);
begin
  FContextType.free;
  FContextType := value;
end;

Function TFhirProfileExtensionDefn.GetContextTypeST : TFhirExtensionContext;
begin
  if FContextType = nil then
    result := TFhirExtensionContext(0)
  else
    result := TFhirExtensionContext(StringArrayIndexOf(CODES_TFhirExtensionContext, ContextType.value));
end;

Procedure TFhirProfileExtensionDefn.SetContextTypeST(value : TFhirExtensionContext);
begin
  if ord(value) = 0 then
    ContextType := nil
  else
    ContextType := TFhirEnum.create(CODES_TFhirExtensionContext[value]);
end;

Procedure TFhirProfileExtensionDefn.SetDefinition(value : TFhirProfileStructureElementDefinition);
begin
  FDefinition.free;
  FDefinition := value;
end;


{ TFhirProfileExtensionDefnList }
procedure TFhirProfileExtensionDefnList.AddItem(value: TFhirProfileExtensionDefn);
begin
  assert(value.ClassName = 'TFhirProfileExtensionDefn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileExtensionDefn');
  add(value);
end;


function TFhirProfileExtensionDefnList.Append: TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileExtensionDefnList.ClearItems;
begin
  Clear;
end;

function TFhirProfileExtensionDefnList.Clone: TFhirProfileExtensionDefnList;
begin
  result := TFhirProfileExtensionDefnList(inherited Clone);
end;

function TFhirProfileExtensionDefnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileExtensionDefnList.GetItemN(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(ObjectByIndex[index]);
end;

function TFhirProfileExtensionDefnList.IndexOf(value: TFhirProfileExtensionDefn): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileExtensionDefnList.Insert(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileExtensionDefnList.InsertItem(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  Inherited Insert(index, value);
end;

function TFhirProfileExtensionDefnList.Item(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(ObjectByIndex[index]);
end;

function TFhirProfileExtensionDefnList.Link: TFhirProfileExtensionDefnList;
begin
  result := TFhirProfileExtensionDefnList(inherited Link);
end;

procedure TFhirProfileExtensionDefnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileExtensionDefnList.SetItemByIndex(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  FhirProfileExtensionDefns[index] := value;
end;

procedure TFhirProfileExtensionDefnList.SetItemN(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileBinding }

constructor TFhirProfileBinding.Create;
begin
  inherited;
end;

destructor TFhirProfileBinding.Destroy;
begin
  FName.free;
  FIsExtensible.free;
  FConformance.free;
  FDescription.free;
  FReference.free;
  inherited;
end;

procedure TFhirProfileBinding.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirProfileBinding(oSource).name.Clone;
  isExtensible := TFhirProfileBinding(oSource).isExtensible.Clone;
  FConformance := TFhirProfileBinding(oSource).FConformance.Link;
  description := TFhirProfileBinding(oSource).description.Clone;
  reference := TFhirProfileBinding(oSource).reference.Clone;
end;

procedure TFhirProfileBinding.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'isExtensible') Then
     list.add(IsExtensible.Link);
  if (child_name = 'conformance') Then
     list.add(FConformance.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
end;

procedure TFhirProfileBinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isExtensible', 'boolean', FIsExtensible.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conformance', 'code', FConformance.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference[x]', 'uri|Resource(ValueSet)', FReference.Link.Link));{2}
end;

function TFhirProfileBinding.Link : TFhirProfileBinding;
begin
  result := TFhirProfileBinding(inherited Link);
end;

function TFhirProfileBinding.Clone : TFhirProfileBinding;
begin
  result := TFhirProfileBinding(inherited Clone);
end;

{ TFhirProfileBinding }

Procedure TFhirProfileBinding.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileBinding.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileBinding.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileBinding.SetIsExtensible(value : TFhirBoolean);
begin
  FIsExtensible.free;
  FIsExtensible := value;
end;

Function TFhirProfileBinding.GetIsExtensibleST : String;
begin
  if FIsExtensible = nil then
    result := ''
  else
    result := IsExtensible.value;
end;

Procedure TFhirProfileBinding.SetIsExtensibleST(value : String);
begin
  if value <> '' then
  begin
    if FIsExtensible = nil then
      FIsExtensible := TFhirBoolean.create;
    FIsExtensible.value := value
  end
  else if FIsExtensible <> nil then
    FIsExtensible.value := '';
end;

Procedure TFhirProfileBinding.SetConformance(value : TFhirEnum);
begin
  FConformance.free;
  FConformance := value;
end;

Function TFhirProfileBinding.GetConformanceST : TFhirBindingConformance;
begin
  if FConformance = nil then
    result := TFhirBindingConformance(0)
  else
    result := TFhirBindingConformance(StringArrayIndexOf(CODES_TFhirBindingConformance, Conformance.value));
end;

Procedure TFhirProfileBinding.SetConformanceST(value : TFhirBindingConformance);
begin
  if ord(value) = 0 then
    Conformance := nil
  else
    Conformance := TFhirEnum.create(CODES_TFhirBindingConformance[value]);
end;

Procedure TFhirProfileBinding.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirProfileBinding.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirProfileBinding.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirProfileBinding.SetReference(value : TFhirType);
begin
  FReference.free;
  FReference := value;
end;


{ TFhirProfileBindingList }
procedure TFhirProfileBindingList.AddItem(value: TFhirProfileBinding);
begin
  assert(value.ClassName = 'TFhirProfileBinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileBinding');
  add(value);
end;


function TFhirProfileBindingList.Append: TFhirProfileBinding;
begin
  result := TFhirProfileBinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileBindingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileBindingList.Clone: TFhirProfileBindingList;
begin
  result := TFhirProfileBindingList(inherited Clone);
end;

function TFhirProfileBindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileBindingList.GetItemN(index: Integer): TFhirProfileBinding;
begin
  result := TFhirProfileBinding(ObjectByIndex[index]);
end;

function TFhirProfileBindingList.IndexOf(value: TFhirProfileBinding): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileBindingList.Insert(index: Integer): TFhirProfileBinding;
begin
  result := TFhirProfileBinding.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileBindingList.InsertItem(index: Integer; value: TFhirProfileBinding);
begin
  assert(value is TFhirProfileBinding);
  Inherited Insert(index, value);
end;

function TFhirProfileBindingList.Item(index: Integer): TFhirProfileBinding;
begin
  result := TFhirProfileBinding(ObjectByIndex[index]);
end;

function TFhirProfileBindingList.Link: TFhirProfileBindingList;
begin
  result := TFhirProfileBindingList(inherited Link);
end;

procedure TFhirProfileBindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileBindingList.SetItemByIndex(index: Integer; value: TFhirProfileBinding);
begin
  assert(value is TFhirProfileBinding);
  FhirProfileBindings[index] := value;
end;

procedure TFhirProfileBindingList.SetItemN(index: Integer; value: TFhirProfileBinding);
begin
  assert(value is TFhirProfileBinding);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FRole.free;
  FType_.free;
  FReference.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TAdvObject);
begin
  inherited;
  role := TFhirProvenanceAgent(oSource).role.Clone;
  type_ := TFhirProvenanceAgent(oSource).type_.Clone;
  reference := TFhirProvenanceAgent(oSource).reference.Clone;
  display := TFhirProvenanceAgent(oSource).display.Clone;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(Role.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', FRole.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

{ TFhirProvenanceAgent }

Procedure TFhirProvenanceAgent.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirProvenanceAgent.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceAgent.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProvenanceAgent.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := Reference.value;
end;

Procedure TFhirProvenanceAgent.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirProvenanceAgent.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProvenanceAgent.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirProvenanceAgent.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;


{ TFhirProvenanceAgentList }
procedure TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent);
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
end;


function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FType_.free;
  FReference.free;
  FDisplay.free;
  FAgent.free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TAdvObject);
begin
  inherited;
  FRole := TFhirProvenanceEntity(oSource).FRole.Link;
  type_ := TFhirProvenanceEntity(oSource).type_.Clone;
  reference := TFhirProvenanceEntity(oSource).reference.Clone;
  display := TFhirProvenanceEntity(oSource).display.Clone;
  agent := TFhirProvenanceEntity(oSource).agent.Clone;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
  if (child_name = 'agent') Then
     list.add(Agent.Link);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '@Provenance.agent', FAgent.Link.Link));{2}
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

{ TFhirProvenanceEntity }

Procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRole;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRole(0)
  else
    result := TFhirProvenanceEntityRole(StringArrayIndexOf(CODES_TFhirProvenanceEntityRole, Role.value));
end;

Procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRole);
begin
  if ord(value) = 0 then
    Role := nil
  else
    Role := TFhirEnum.create(CODES_TFhirProvenanceEntityRole[value]);
end;

Procedure TFhirProvenanceEntity.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceEntity.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProvenanceEntity.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := Reference.value;
end;

Procedure TFhirProvenanceEntity.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirProvenanceEntity.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProvenanceEntity.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirProvenanceEntity.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirProvenanceEntity.SetAgent(value : TFhirProvenanceAgent);
begin
  FAgent.free;
  FAgent := value;
end;


{ TFhirProvenanceEntityList }
procedure TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity);
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
end;


function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirQueryResponse }

constructor TFhirQueryResponse.Create;
begin
  inherited;
  FParameterList := TFhirExtensionList.Create;
  FFirstList := TFhirExtensionList.Create;
  FPreviousList := TFhirExtensionList.Create;
  FNextList := TFhirExtensionList.Create;
  FLastList := TFhirExtensionList.Create;
  FReferenceList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirQueryResponse.Destroy;
begin
  FIdentifier.free;
  FOutcome.free;
  FTotal.free;
  FParameterList.Free;
  FFirstList.Free;
  FPreviousList.Free;
  FNextList.Free;
  FLastList.Free;
  FReferenceList.Free;
  inherited;
end;

procedure TFhirQueryResponse.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirQueryResponse(oSource).identifier.Clone;
  FOutcome := TFhirQueryResponse(oSource).FOutcome.Link;
  total := TFhirQueryResponse(oSource).total.Clone;
  FParameterList.Assign(TFhirQueryResponse(oSource).FParameterList);
  FFirstList.Assign(TFhirQueryResponse(oSource).FFirstList);
  FPreviousList.Assign(TFhirQueryResponse(oSource).FPreviousList);
  FNextList.Assign(TFhirQueryResponse(oSource).FNextList);
  FLastList.Assign(TFhirQueryResponse(oSource).FLastList);
  FReferenceList.Assign(TFhirQueryResponse(oSource).FReferenceList);
end;

procedure TFhirQueryResponse.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'outcome') Then
     list.add(FOutcome.Link);
  if (child_name = 'total') Then
     list.add(Total.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
  if (child_name = 'first') Then
     list.addAll(FFirstList);
  if (child_name = 'previous') Then
     list.addAll(FPreviousList);
  if (child_name = 'next') Then
     list.addAll(FNextList);
  if (child_name = 'last') Then
     list.addAll(FLastList);
  if (child_name = 'reference') Then
     list.addAll(FReferenceList);
end;

procedure TFhirQueryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'uri', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'total', 'integer', FTotal.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', 'Extension', FParameterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'first', 'Extension', FFirstList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'previous', 'Extension', FPreviousList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'next', 'Extension', FNextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'last', 'Extension', FLastList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Any)', FReferenceList.Link)){3};
end;

function TFhirQueryResponse.Link : TFhirQueryResponse;
begin
  result := TFhirQueryResponse(inherited Link);
end;

function TFhirQueryResponse.Clone : TFhirQueryResponse;
begin
  result := TFhirQueryResponse(inherited Clone);
end;

{ TFhirQueryResponse }

Procedure TFhirQueryResponse.SetIdentifier(value : TFhirUri);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirQueryResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirQueryResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirUri.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirQueryResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirQueryResponse.GetOutcomeST : TFhirQueryOutcome;
begin
  if FOutcome = nil then
    result := TFhirQueryOutcome(0)
  else
    result := TFhirQueryOutcome(StringArrayIndexOf(CODES_TFhirQueryOutcome, Outcome.value));
end;

Procedure TFhirQueryResponse.SetOutcomeST(value : TFhirQueryOutcome);
begin
  if ord(value) = 0 then
    Outcome := nil
  else
    Outcome := TFhirEnum.create(CODES_TFhirQueryOutcome[value]);
end;

Procedure TFhirQueryResponse.SetTotal(value : TFhirInteger);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirQueryResponse.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := Total.value;
end;

Procedure TFhirQueryResponse.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirInteger.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;


{ TFhirQueryResponseList }
procedure TFhirQueryResponseList.AddItem(value: TFhirQueryResponse);
begin
  assert(value.ClassName = 'TFhirQueryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQueryResponse');
  add(value);
end;


function TFhirQueryResponseList.Append: TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQueryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirQueryResponseList.Clone: TFhirQueryResponseList;
begin
  result := TFhirQueryResponseList(inherited Clone);
end;

function TFhirQueryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQueryResponseList.GetItemN(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse(ObjectByIndex[index]);
end;

function TFhirQueryResponseList.IndexOf(value: TFhirQueryResponse): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQueryResponseList.Insert(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQueryResponseList.InsertItem(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  Inherited Insert(index, value);
end;

function TFhirQueryResponseList.Item(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse(ObjectByIndex[index]);
end;

function TFhirQueryResponseList.Link: TFhirQueryResponseList;
begin
  result := TFhirQueryResponseList(inherited Link);
end;

procedure TFhirQueryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQueryResponseList.SetItemByIndex(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  FhirQueryResponses[index] := value;
end;

procedure TFhirQueryResponseList.SetItemN(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireQuestion }

constructor TFhirQuestionnaireQuestion.Create;
begin
  inherited;
  FChoiceList := TFhirCodingList.Create;
end;

destructor TFhirQuestionnaireQuestion.Destroy;
begin
  FName.free;
  FText.free;
  FAnswer.free;
  FChoiceList.Free;
  FOptions.free;
  FData.free;
  FRemarks.free;
  inherited;
end;

procedure TFhirQuestionnaireQuestion.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirQuestionnaireQuestion(oSource).name.Clone;
  text := TFhirQuestionnaireQuestion(oSource).text.Clone;
  answer := TFhirQuestionnaireQuestion(oSource).answer.Clone;
  FChoiceList.Assign(TFhirQuestionnaireQuestion(oSource).FChoiceList);
  options := TFhirQuestionnaireQuestion(oSource).options.Clone;
  data := TFhirQuestionnaireQuestion(oSource).data.Clone;
  remarks := TFhirQuestionnaireQuestion(oSource).remarks.Clone;
end;

procedure TFhirQuestionnaireQuestion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'text') Then
     list.add(Text.Link);
  if (child_name = 'answer') Then
     list.add(Answer.Link);
  if (child_name = 'choice') Then
     list.addAll(FChoiceList);
  if (child_name = 'options') Then
     list.add(Options.Link);
  if (child_name = 'data') Then
     list.add(Data.Link);
  if (child_name = 'remarks') Then
     list.add(Remarks.Link);
end;

procedure TFhirQuestionnaireQuestion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'answer[x]', 'decimal|integer|boolean|date|string|dateTime|instant', FAnswer.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'choice', 'Coding', FChoiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'options[x]', 'uri|Resource(ValueSet)', FOptions.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data[x]', '*', FData.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'remarks', 'string', FRemarks.Link.Link));{2}
end;

function TFhirQuestionnaireQuestion.Link : TFhirQuestionnaireQuestion;
begin
  result := TFhirQuestionnaireQuestion(inherited Link);
end;

function TFhirQuestionnaireQuestion.Clone : TFhirQuestionnaireQuestion;
begin
  result := TFhirQuestionnaireQuestion(inherited Clone);
end;

{ TFhirQuestionnaireQuestion }

Procedure TFhirQuestionnaireQuestion.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirQuestionnaireQuestion.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireQuestion.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := Text.value;
end;

Procedure TFhirQuestionnaireQuestion.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireQuestion.SetAnswer(value : TFhirType);
begin
  FAnswer.free;
  FAnswer := value;
end;

Procedure TFhirQuestionnaireQuestion.SetOptions(value : TFhirType);
begin
  FOptions.free;
  FOptions := value;
end;

Procedure TFhirQuestionnaireQuestion.SetData(value : TFhirType);
begin
  FData.free;
  FData := value;
end;

Procedure TFhirQuestionnaireQuestion.SetRemarks(value : TFhirString);
begin
  FRemarks.free;
  FRemarks := value;
end;

Function TFhirQuestionnaireQuestion.GetRemarksST : String;
begin
  if FRemarks = nil then
    result := ''
  else
    result := Remarks.value;
end;

Procedure TFhirQuestionnaireQuestion.SetRemarksST(value : String);
begin
  if value <> '' then
  begin
    if FRemarks = nil then
      FRemarks := TFhirString.create;
    FRemarks.value := value
  end
  else if FRemarks <> nil then
    FRemarks.value := '';
end;


{ TFhirQuestionnaireQuestionList }
procedure TFhirQuestionnaireQuestionList.AddItem(value: TFhirQuestionnaireQuestion);
begin
  assert(value.ClassName = 'TFhirQuestionnaireQuestion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireQuestion');
  add(value);
end;


function TFhirQuestionnaireQuestionList.Append: TFhirQuestionnaireQuestion;
begin
  result := TFhirQuestionnaireQuestion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireQuestionList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireQuestionList.Clone: TFhirQuestionnaireQuestionList;
begin
  result := TFhirQuestionnaireQuestionList(inherited Clone);
end;

function TFhirQuestionnaireQuestionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireQuestionList.GetItemN(index: Integer): TFhirQuestionnaireQuestion;
begin
  result := TFhirQuestionnaireQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireQuestionList.IndexOf(value: TFhirQuestionnaireQuestion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQuestionnaireQuestionList.Insert(index: Integer): TFhirQuestionnaireQuestion;
begin
  result := TFhirQuestionnaireQuestion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireQuestionList.InsertItem(index: Integer; value: TFhirQuestionnaireQuestion);
begin
  assert(value is TFhirQuestionnaireQuestion);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireQuestionList.Item(index: Integer): TFhirQuestionnaireQuestion;
begin
  result := TFhirQuestionnaireQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireQuestionList.Link: TFhirQuestionnaireQuestionList;
begin
  result := TFhirQuestionnaireQuestionList(inherited Link);
end;

procedure TFhirQuestionnaireQuestionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireQuestionList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireQuestion);
begin
  assert(value is TFhirQuestionnaireQuestion);
  FhirQuestionnaireQuestions[index] := value;
end;

procedure TFhirQuestionnaireQuestionList.SetItemN(index: Integer; value: TFhirQuestionnaireQuestion);
begin
  assert(value is TFhirQuestionnaireQuestion);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireGroup }

constructor TFhirQuestionnaireGroup.Create;
begin
  inherited;
  FQuestionList := TFhirQuestionnaireQuestionList.Create;
  FGroupList := TFhirQuestionnaireGroupList.Create;
end;

destructor TFhirQuestionnaireGroup.Destroy;
begin
  FName.free;
  FHeader.free;
  FText.free;
  FSubject.free;
  FQuestionList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirQuestionnaireGroup.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirQuestionnaireGroup(oSource).name.Clone;
  header := TFhirQuestionnaireGroup(oSource).header.Clone;
  text := TFhirQuestionnaireGroup(oSource).text.Clone;
  subject := TFhirQuestionnaireGroup(oSource).subject.Clone;
  FQuestionList.Assign(TFhirQuestionnaireGroup(oSource).FQuestionList);
  FGroupList.Assign(TFhirQuestionnaireGroup(oSource).FGroupList);
end;

procedure TFhirQuestionnaireGroup.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'header') Then
     list.add(Header.Link);
  if (child_name = 'text') Then
     list.add(Text.Link);
  if (child_name = 'subject') Then
     list.add(Subject.Link);
  if (child_name = 'question') Then
     list.addAll(FQuestionList);
  if (child_name = 'group') Then
     list.addAll(FGroupList);
end;

procedure TFhirQuestionnaireGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'header', 'string', FHeader.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Resource(Any)', FSubject.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'question', '@Questionnaire.question', FQuestionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', '@Questionnaire.group', FGroupList.Link)){3};
end;

function TFhirQuestionnaireGroup.Link : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Link);
end;

function TFhirQuestionnaireGroup.Clone : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Clone);
end;

{ TFhirQuestionnaireGroup }

Procedure TFhirQuestionnaireGroup.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirQuestionnaireGroup.SetHeader(value : TFhirString);
begin
  FHeader.free;
  FHeader := value;
end;

Function TFhirQuestionnaireGroup.GetHeaderST : String;
begin
  if FHeader = nil then
    result := ''
  else
    result := Header.value;
end;

Procedure TFhirQuestionnaireGroup.SetHeaderST(value : String);
begin
  if value <> '' then
  begin
    if FHeader = nil then
      FHeader := TFhirString.create;
    FHeader.value := value
  end
  else if FHeader <> nil then
    FHeader.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireGroup.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := Text.value;
end;

Procedure TFhirQuestionnaireGroup.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetSubject(value : TFhirResourceReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;


{ TFhirQuestionnaireGroupList }
procedure TFhirQuestionnaireGroupList.AddItem(value: TFhirQuestionnaireGroup);
begin
  assert(value.ClassName = 'TFhirQuestionnaireGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireGroup');
  add(value);
end;


function TFhirQuestionnaireGroupList.Append: TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireGroupList.Clone: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Clone);
end;

function TFhirQuestionnaireGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireGroupList.GetItemN(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.IndexOf(value: TFhirQuestionnaireGroup): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQuestionnaireGroupList.Insert(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupList.InsertItem(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireGroupList.Item(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.Link: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Link);
end;

procedure TFhirQuestionnaireGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireGroupList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  FhirQuestionnaireGroups[index] := value;
end;

procedure TFhirQuestionnaireGroupList.SetItemN(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventEvent }

constructor TFhirSecurityEventEvent.Create;
begin
  inherited;
  FSubtypeList := TFhirCodeableConceptList.Create;
end;

destructor TFhirSecurityEventEvent.Destroy;
begin
  FType_.free;
  FSubtypeList.Free;
  FAction.free;
  FDateTime.free;
  FOutcome.free;
  FOutcomeDesc.free;
  inherited;
end;

procedure TFhirSecurityEventEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirSecurityEventEvent(oSource).type_.Clone;
  FSubtypeList.Assign(TFhirSecurityEventEvent(oSource).FSubtypeList);
  FAction := TFhirSecurityEventEvent(oSource).FAction.Link;
  dateTime := TFhirSecurityEventEvent(oSource).dateTime.Clone;
  FOutcome := TFhirSecurityEventEvent(oSource).FOutcome.Link;
  outcomeDesc := TFhirSecurityEventEvent(oSource).outcomeDesc.Clone;
end;

procedure TFhirSecurityEventEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'subtype') Then
     list.addAll(FSubtypeList);
  if (child_name = 'action') Then
     list.add(FAction.Link);
  if (child_name = 'dateTime') Then
     list.add(DateTime.Link);
  if (child_name = 'outcome') Then
     list.add(FOutcome.Link);
  if (child_name = 'outcomeDesc') Then
     list.add(OutcomeDesc.Link);
end;

procedure TFhirSecurityEventEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'code', FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'instant', FDateTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'outcomeDesc', 'string', FOutcomeDesc.Link.Link));{2}
end;

function TFhirSecurityEventEvent.Link : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(inherited Link);
end;

function TFhirSecurityEventEvent.Clone : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(inherited Clone);
end;

{ TFhirSecurityEventEvent }

Procedure TFhirSecurityEventEvent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSecurityEventEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirSecurityEventEvent.GetActionST : TFhirSecurityEventAction;
begin
  if FAction = nil then
    result := TFhirSecurityEventAction(0)
  else
    result := TFhirSecurityEventAction(StringArrayIndexOf(CODES_TFhirSecurityEventAction, Action.value));
end;

Procedure TFhirSecurityEventEvent.SetActionST(value : TFhirSecurityEventAction);
begin
  if ord(value) = 0 then
    Action := nil
  else
    Action := TFhirEnum.create(CODES_TFhirSecurityEventAction[value]);
end;

Procedure TFhirSecurityEventEvent.SetDateTime(value : TFhirInstant);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirSecurityEventEvent.GetDateTimeST : TDateAndTime;
begin
  if FDateTime = nil then
    result := nil
  else
    result := DateTime.value;
end;

Procedure TFhirSecurityEventEvent.SetDateTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirInstant.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;

Procedure TFhirSecurityEventEvent.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirSecurityEventEvent.GetOutcomeST : TFhirSecurityEventOutcome;
begin
  if FOutcome = nil then
    result := TFhirSecurityEventOutcome(0)
  else
    result := TFhirSecurityEventOutcome(StringArrayIndexOf(CODES_TFhirSecurityEventOutcome, Outcome.value));
end;

Procedure TFhirSecurityEventEvent.SetOutcomeST(value : TFhirSecurityEventOutcome);
begin
  if ord(value) = 0 then
    Outcome := nil
  else
    Outcome := TFhirEnum.create(CODES_TFhirSecurityEventOutcome[value]);
end;

Procedure TFhirSecurityEventEvent.SetOutcomeDesc(value : TFhirString);
begin
  FOutcomeDesc.free;
  FOutcomeDesc := value;
end;

Function TFhirSecurityEventEvent.GetOutcomeDescST : String;
begin
  if FOutcomeDesc = nil then
    result := ''
  else
    result := OutcomeDesc.value;
end;

Procedure TFhirSecurityEventEvent.SetOutcomeDescST(value : String);
begin
  if value <> '' then
  begin
    if FOutcomeDesc = nil then
      FOutcomeDesc := TFhirString.create;
    FOutcomeDesc.value := value
  end
  else if FOutcomeDesc <> nil then
    FOutcomeDesc.value := '';
end;


{ TFhirSecurityEventEventList }
procedure TFhirSecurityEventEventList.AddItem(value: TFhirSecurityEventEvent);
begin
  assert(value.ClassName = 'TFhirSecurityEventEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventEvent');
  add(value);
end;


function TFhirSecurityEventEventList.Append: TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventEventList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventEventList.Clone: TFhirSecurityEventEventList;
begin
  result := TFhirSecurityEventEventList(inherited Clone);
end;

function TFhirSecurityEventEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventEventList.GetItemN(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(ObjectByIndex[index]);
end;

function TFhirSecurityEventEventList.IndexOf(value: TFhirSecurityEventEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventEventList.Insert(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventEventList.InsertItem(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventEventList.Item(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(ObjectByIndex[index]);
end;

function TFhirSecurityEventEventList.Link: TFhirSecurityEventEventList;
begin
  result := TFhirSecurityEventEventList(inherited Link);
end;

procedure TFhirSecurityEventEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventEventList.SetItemByIndex(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  FhirSecurityEventEvents[index] := value;
end;

procedure TFhirSecurityEventEventList.SetItemN(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventParticipant }

constructor TFhirSecurityEventParticipant.Create;
begin
  inherited;
  FRoleList := TFhirCodeableConceptList.Create;
end;

destructor TFhirSecurityEventParticipant.Destroy;
begin
  FRoleList.Free;
  FReference.free;
  FUserId.free;
  FAuthId.free;
  FName.free;
  FRequestor.free;
  FMedia.free;
  FNetwork.free;
  inherited;
end;

procedure TFhirSecurityEventParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  FRoleList.Assign(TFhirSecurityEventParticipant(oSource).FRoleList);
  reference := TFhirSecurityEventParticipant(oSource).reference.Clone;
  userId := TFhirSecurityEventParticipant(oSource).userId.Clone;
  authId := TFhirSecurityEventParticipant(oSource).authId.Clone;
  name := TFhirSecurityEventParticipant(oSource).name.Clone;
  requestor := TFhirSecurityEventParticipant(oSource).requestor.Clone;
  media := TFhirSecurityEventParticipant(oSource).media.Clone;
  network := TFhirSecurityEventParticipant(oSource).network.Clone;
end;

procedure TFhirSecurityEventParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.addAll(FRoleList);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'userId') Then
     list.add(UserId.Link);
  if (child_name = 'authId') Then
     list.add(AuthId.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'requestor') Then
     list.add(Requestor.Link);
  if (child_name = 'media') Then
     list.add(Media.Link);
  if (child_name = 'network') Then
     list.add(Network.Link);
end;

procedure TFhirSecurityEventParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Practitioner|Patient|Device)', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'userId', 'string', FUserId.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authId', 'string', FAuthId.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', FRequestor.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'media', 'Coding', FMedia.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', '', FNetwork.Link.Link));{2}
end;

function TFhirSecurityEventParticipant.Link : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(inherited Link);
end;

function TFhirSecurityEventParticipant.Clone : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(inherited Clone);
end;

{ TFhirSecurityEventParticipant }

Procedure TFhirSecurityEventParticipant.SetReference(value : TFhirResourceReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirSecurityEventParticipant.SetUserId(value : TFhirString);
begin
  FUserId.free;
  FUserId := value;
end;

Function TFhirSecurityEventParticipant.GetUserIdST : String;
begin
  if FUserId = nil then
    result := ''
  else
    result := UserId.value;
end;

Procedure TFhirSecurityEventParticipant.SetUserIdST(value : String);
begin
  if value <> '' then
  begin
    if FUserId = nil then
      FUserId := TFhirString.create;
    FUserId.value := value
  end
  else if FUserId <> nil then
    FUserId.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetAuthId(value : TFhirString);
begin
  FAuthId.free;
  FAuthId := value;
end;

Function TFhirSecurityEventParticipant.GetAuthIdST : String;
begin
  if FAuthId = nil then
    result := ''
  else
    result := AuthId.value;
end;

Procedure TFhirSecurityEventParticipant.SetAuthIdST(value : String);
begin
  if value <> '' then
  begin
    if FAuthId = nil then
      FAuthId := TFhirString.create;
    FAuthId.value := value
  end
  else if FAuthId <> nil then
    FAuthId.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSecurityEventParticipant.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirSecurityEventParticipant.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

Function TFhirSecurityEventParticipant.GetRequestorST : String;
begin
  if FRequestor = nil then
    result := ''
  else
    result := Requestor.value;
end;

Procedure TFhirSecurityEventParticipant.SetRequestorST(value : String);
begin
  if value <> '' then
  begin
    if FRequestor = nil then
      FRequestor := TFhirBoolean.create;
    FRequestor.value := value
  end
  else if FRequestor <> nil then
    FRequestor.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetMedia(value : TFhirCoding);
begin
  FMedia.free;
  FMedia := value;
end;

Procedure TFhirSecurityEventParticipant.SetNetwork(value : TFhirSecurityEventParticipantNetwork);
begin
  FNetwork.free;
  FNetwork := value;
end;


{ TFhirSecurityEventParticipantList }
procedure TFhirSecurityEventParticipantList.AddItem(value: TFhirSecurityEventParticipant);
begin
  assert(value.ClassName = 'TFhirSecurityEventParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventParticipant');
  add(value);
end;


function TFhirSecurityEventParticipantList.Append: TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventParticipantList.Clone: TFhirSecurityEventParticipantList;
begin
  result := TFhirSecurityEventParticipantList(inherited Clone);
end;

function TFhirSecurityEventParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventParticipantList.GetItemN(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantList.IndexOf(value: TFhirSecurityEventParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventParticipantList.Insert(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantList.InsertItem(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventParticipantList.Item(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantList.Link: TFhirSecurityEventParticipantList;
begin
  result := TFhirSecurityEventParticipantList(inherited Link);
end;

procedure TFhirSecurityEventParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventParticipantList.SetItemByIndex(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  FhirSecurityEventParticipants[index] := value;
end;

procedure TFhirSecurityEventParticipantList.SetItemN(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventParticipantNetwork }

constructor TFhirSecurityEventParticipantNetwork.Create;
begin
  inherited;
end;

destructor TFhirSecurityEventParticipantNetwork.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  inherited;
end;

procedure TFhirSecurityEventParticipantNetwork.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSecurityEventParticipantNetwork(oSource).identifier.Clone;
  FType_ := TFhirSecurityEventParticipantNetwork(oSource).FType_.Link;
end;

procedure TFhirSecurityEventParticipantNetwork.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
end;

procedure TFhirSecurityEventParticipantNetwork.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'string', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
end;

function TFhirSecurityEventParticipantNetwork.Link : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(inherited Link);
end;

function TFhirSecurityEventParticipantNetwork.Clone : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(inherited Clone);
end;

{ TFhirSecurityEventParticipantNetwork }

Procedure TFhirSecurityEventParticipantNetwork.SetIdentifier(value : TFhirString);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirSecurityEventParticipantNetwork.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirSecurityEventParticipantNetwork.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirString.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirSecurityEventParticipantNetwork.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventParticipantNetwork.GetType_ST : TFhirNetworkType;
begin
  if FType_ = nil then
    result := TFhirNetworkType(0)
  else
    result := TFhirNetworkType(StringArrayIndexOf(CODES_TFhirNetworkType, Type_.value));
end;

Procedure TFhirSecurityEventParticipantNetwork.SetType_ST(value : TFhirNetworkType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirNetworkType[value]);
end;


{ TFhirSecurityEventParticipantNetworkList }
procedure TFhirSecurityEventParticipantNetworkList.AddItem(value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value.ClassName = 'TFhirSecurityEventParticipantNetwork', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventParticipantNetwork');
  add(value);
end;


function TFhirSecurityEventParticipantNetworkList.Append: TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantNetworkList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventParticipantNetworkList.Clone: TFhirSecurityEventParticipantNetworkList;
begin
  result := TFhirSecurityEventParticipantNetworkList(inherited Clone);
end;

function TFhirSecurityEventParticipantNetworkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventParticipantNetworkList.GetItemN(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantNetworkList.IndexOf(value: TFhirSecurityEventParticipantNetwork): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventParticipantNetworkList.Insert(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantNetworkList.InsertItem(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventParticipantNetworkList.Item(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantNetworkList.Link: TFhirSecurityEventParticipantNetworkList;
begin
  result := TFhirSecurityEventParticipantNetworkList(inherited Link);
end;

procedure TFhirSecurityEventParticipantNetworkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventParticipantNetworkList.SetItemByIndex(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  FhirSecurityEventParticipantNetworks[index] := value;
end;

procedure TFhirSecurityEventParticipantNetworkList.SetItemN(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventSource }

constructor TFhirSecurityEventSource.Create;
begin
  inherited;
  FType_List := TFhirCodingList.Create;
end;

destructor TFhirSecurityEventSource.Destroy;
begin
  FSite.free;
  FIdentifier.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirSecurityEventSource.Assign(oSource : TAdvObject);
begin
  inherited;
  site := TFhirSecurityEventSource(oSource).site.Clone;
  identifier := TFhirSecurityEventSource(oSource).identifier.Clone;
  FType_List.Assign(TFhirSecurityEventSource(oSource).FType_List);
end;

procedure TFhirSecurityEventSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'type_') Then
     list.addAll(FType_List);
end;

procedure TFhirSecurityEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'string', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'string', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_List.Link)){3};
end;

function TFhirSecurityEventSource.Link : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(inherited Link);
end;

function TFhirSecurityEventSource.Clone : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(inherited Clone);
end;

{ TFhirSecurityEventSource }

Procedure TFhirSecurityEventSource.SetSite(value : TFhirString);
begin
  FSite.free;
  FSite := value;
end;

Function TFhirSecurityEventSource.GetSiteST : String;
begin
  if FSite = nil then
    result := ''
  else
    result := Site.value;
end;

Procedure TFhirSecurityEventSource.SetSiteST(value : String);
begin
  if value <> '' then
  begin
    if FSite = nil then
      FSite := TFhirString.create;
    FSite.value := value
  end
  else if FSite <> nil then
    FSite.value := '';
end;

Procedure TFhirSecurityEventSource.SetIdentifier(value : TFhirString);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirSecurityEventSource.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirSecurityEventSource.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirString.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;


{ TFhirSecurityEventSourceList }
procedure TFhirSecurityEventSourceList.AddItem(value: TFhirSecurityEventSource);
begin
  assert(value.ClassName = 'TFhirSecurityEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventSource');
  add(value);
end;


function TFhirSecurityEventSourceList.Append: TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventSourceList.Clone: TFhirSecurityEventSourceList;
begin
  result := TFhirSecurityEventSourceList(inherited Clone);
end;

function TFhirSecurityEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventSourceList.GetItemN(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(ObjectByIndex[index]);
end;

function TFhirSecurityEventSourceList.IndexOf(value: TFhirSecurityEventSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventSourceList.Insert(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventSourceList.InsertItem(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventSourceList.Item(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(ObjectByIndex[index]);
end;

function TFhirSecurityEventSourceList.Link: TFhirSecurityEventSourceList;
begin
  result := TFhirSecurityEventSourceList(inherited Link);
end;

procedure TFhirSecurityEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventSourceList.SetItemByIndex(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  FhirSecurityEventSources[index] := value;
end;

procedure TFhirSecurityEventSourceList.SetItemN(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventObject }

constructor TFhirSecurityEventObject.Create;
begin
  inherited;
  FDetailList := TFhirSecurityEventObjectDetailList.Create;
end;

destructor TFhirSecurityEventObject.Destroy;
begin
  FIdentifier.free;
  FReference.free;
  FType_.free;
  FRole.free;
  FLifecycle.free;
  FSensitivity.free;
  FName.free;
  FQuery.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirSecurityEventObject.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSecurityEventObject(oSource).identifier.Clone;
  reference := TFhirSecurityEventObject(oSource).reference.Clone;
  FType_ := TFhirSecurityEventObject(oSource).FType_.Link;
  FRole := TFhirSecurityEventObject(oSource).FRole.Link;
  FLifecycle := TFhirSecurityEventObject(oSource).FLifecycle.Link;
  sensitivity := TFhirSecurityEventObject(oSource).sensitivity.Clone;
  name := TFhirSecurityEventObject(oSource).name.Clone;
  query := TFhirSecurityEventObject(oSource).query.Clone;
  FDetailList.Assign(TFhirSecurityEventObject(oSource).FDetailList);
end;

procedure TFhirSecurityEventObject.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'lifecycle') Then
     list.add(FLifecycle.Link);
  if (child_name = 'sensitivity') Then
     list.add(Sensitivity.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'query') Then
     list.add(Query.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirSecurityEventObject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Any)', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'role', 'code', FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'lifecycle', 'code', FLifecycle.Link));{1}
  oList.add(TFHIRProperty.create(self, 'sensitivity', 'CodeableConcept', FSensitivity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', FQuery.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', FDetailList.Link)){3};
end;

function TFhirSecurityEventObject.Link : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(inherited Link);
end;

function TFhirSecurityEventObject.Clone : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(inherited Clone);
end;

{ TFhirSecurityEventObject }

Procedure TFhirSecurityEventObject.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSecurityEventObject.SetReference(value : TFhirResourceReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirSecurityEventObject.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventObject.GetType_ST : TFhirObjectType;
begin
  if FType_ = nil then
    result := TFhirObjectType(0)
  else
    result := TFhirObjectType(StringArrayIndexOf(CODES_TFhirObjectType, Type_.value));
end;

Procedure TFhirSecurityEventObject.SetType_ST(value : TFhirObjectType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirObjectType[value]);
end;

Procedure TFhirSecurityEventObject.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirSecurityEventObject.GetRoleST : TFhirObjectRole;
begin
  if FRole = nil then
    result := TFhirObjectRole(0)
  else
    result := TFhirObjectRole(StringArrayIndexOf(CODES_TFhirObjectRole, Role.value));
end;

Procedure TFhirSecurityEventObject.SetRoleST(value : TFhirObjectRole);
begin
  if ord(value) = 0 then
    Role := nil
  else
    Role := TFhirEnum.create(CODES_TFhirObjectRole[value]);
end;

Procedure TFhirSecurityEventObject.SetLifecycle(value : TFhirEnum);
begin
  FLifecycle.free;
  FLifecycle := value;
end;

Function TFhirSecurityEventObject.GetLifecycleST : TFhirObjectLifecycle;
begin
  if FLifecycle = nil then
    result := TFhirObjectLifecycle(0)
  else
    result := TFhirObjectLifecycle(StringArrayIndexOf(CODES_TFhirObjectLifecycle, Lifecycle.value));
end;

Procedure TFhirSecurityEventObject.SetLifecycleST(value : TFhirObjectLifecycle);
begin
  if ord(value) = 0 then
    Lifecycle := nil
  else
    Lifecycle := TFhirEnum.create(CODES_TFhirObjectLifecycle[value]);
end;

Procedure TFhirSecurityEventObject.SetSensitivity(value : TFhirCodeableConcept);
begin
  FSensitivity.free;
  FSensitivity := value;
end;

Procedure TFhirSecurityEventObject.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSecurityEventObject.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirSecurityEventObject.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSecurityEventObject.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

Function TFhirSecurityEventObject.GetQueryST : String;
begin
  if FQuery = nil then
    result := ''
  else
    result := Query.value;
end;

Procedure TFhirSecurityEventObject.SetQueryST(value : String);
begin
  if value <> '' then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := '';
end;


{ TFhirSecurityEventObjectList }
procedure TFhirSecurityEventObjectList.AddItem(value: TFhirSecurityEventObject);
begin
  assert(value.ClassName = 'TFhirSecurityEventObject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventObject');
  add(value);
end;


function TFhirSecurityEventObjectList.Append: TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventObjectList.Clone: TFhirSecurityEventObjectList;
begin
  result := TFhirSecurityEventObjectList(inherited Clone);
end;

function TFhirSecurityEventObjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventObjectList.GetItemN(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectList.IndexOf(value: TFhirSecurityEventObject): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventObjectList.Insert(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectList.InsertItem(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventObjectList.Item(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectList.Link: TFhirSecurityEventObjectList;
begin
  result := TFhirSecurityEventObjectList(inherited Link);
end;

procedure TFhirSecurityEventObjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventObjectList.SetItemByIndex(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  FhirSecurityEventObjects[index] := value;
end;

procedure TFhirSecurityEventObjectList.SetItemN(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventObjectDetail }

constructor TFhirSecurityEventObjectDetail.Create;
begin
  inherited;
end;

destructor TFhirSecurityEventObjectDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirSecurityEventObjectDetail.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirSecurityEventObjectDetail(oSource).type_.Clone;
  value := TFhirSecurityEventObjectDetail(oSource).value.Clone;
end;

procedure TFhirSecurityEventObjectDetail.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirSecurityEventObjectDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'string', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'base64Binary', FValue.Link.Link));{2}
end;

function TFhirSecurityEventObjectDetail.Link : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(inherited Link);
end;

function TFhirSecurityEventObjectDetail.Clone : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(inherited Clone);
end;

{ TFhirSecurityEventObjectDetail }

Procedure TFhirSecurityEventObjectDetail.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventObjectDetail.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirSecurityEventObjectDetail.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirSecurityEventObjectDetail.SetValue(value : TFhirBase64Binary);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirSecurityEventObjectDetail.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := Value.value;
end;

Procedure TFhirSecurityEventObjectDetail.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirBase64Binary.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirSecurityEventObjectDetailList }
procedure TFhirSecurityEventObjectDetailList.AddItem(value: TFhirSecurityEventObjectDetail);
begin
  assert(value.ClassName = 'TFhirSecurityEventObjectDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventObjectDetail');
  add(value);
end;


function TFhirSecurityEventObjectDetailList.Append: TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectDetailList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventObjectDetailList.Clone: TFhirSecurityEventObjectDetailList;
begin
  result := TFhirSecurityEventObjectDetailList(inherited Clone);
end;

function TFhirSecurityEventObjectDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventObjectDetailList.GetItemN(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectDetailList.IndexOf(value: TFhirSecurityEventObjectDetail): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventObjectDetailList.Insert(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectDetailList.InsertItem(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventObjectDetailList.Item(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectDetailList.Link: TFhirSecurityEventObjectDetailList;
begin
  result := TFhirSecurityEventObjectDetailList(inherited Link);
end;

procedure TFhirSecurityEventObjectDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventObjectDetailList.SetItemByIndex(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  FhirSecurityEventObjectDetails[index] := value;
end;

procedure TFhirSecurityEventObjectDetailList.SetItemN(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenSource }

constructor TFhirSpecimenSource.Create;
begin
  inherited;
  FTargetList := TFhirResourceReferenceList{TFhirSpecimen}.Create;
end;

destructor TFhirSpecimenSource.Destroy;
begin
  FRelationship.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirSpecimenSource.Assign(oSource : TAdvObject);
begin
  inherited;
  FRelationship := TFhirSpecimenSource(oSource).FRelationship.Link;
  FTargetList.Assign(TFhirSpecimenSource(oSource).FTargetList);
end;

procedure TFhirSpecimenSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'relationship') Then
     list.add(FRelationship.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
end;

procedure TFhirSpecimenSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', FRelationship.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Specimen)', FTargetList.Link)){3};
end;

function TFhirSpecimenSource.Link : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(inherited Link);
end;

function TFhirSpecimenSource.Clone : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(inherited Clone);
end;

{ TFhirSpecimenSource }

Procedure TFhirSpecimenSource.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirSpecimenSource.GetRelationshipST : TFhirHierarchicalRelationshipType;
begin
  if FRelationship = nil then
    result := TFhirHierarchicalRelationshipType(0)
  else
    result := TFhirHierarchicalRelationshipType(StringArrayIndexOf(CODES_TFhirHierarchicalRelationshipType, Relationship.value));
end;

Procedure TFhirSpecimenSource.SetRelationshipST(value : TFhirHierarchicalRelationshipType);
begin
  if ord(value) = 0 then
    Relationship := nil
  else
    Relationship := TFhirEnum.create(CODES_TFhirHierarchicalRelationshipType[value]);
end;


{ TFhirSpecimenSourceList }
procedure TFhirSpecimenSourceList.AddItem(value: TFhirSpecimenSource);
begin
  assert(value.ClassName = 'TFhirSpecimenSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenSource');
  add(value);
end;


function TFhirSpecimenSourceList.Append: TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenSourceList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenSourceList.Clone: TFhirSpecimenSourceList;
begin
  result := TFhirSpecimenSourceList(inherited Clone);
end;

function TFhirSpecimenSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenSourceList.GetItemN(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(ObjectByIndex[index]);
end;

function TFhirSpecimenSourceList.IndexOf(value: TFhirSpecimenSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenSourceList.Insert(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenSourceList.InsertItem(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  Inherited Insert(index, value);
end;

function TFhirSpecimenSourceList.Item(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(ObjectByIndex[index]);
end;

function TFhirSpecimenSourceList.Link: TFhirSpecimenSourceList;
begin
  result := TFhirSpecimenSourceList(inherited Link);
end;

procedure TFhirSpecimenSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenSourceList.SetItemByIndex(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  FhirSpecimenSources[index] := value;
end;

procedure TFhirSpecimenSourceList.SetItemN(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenCollection }

constructor TFhirSpecimenCollection.Create;
begin
  inherited;
  FCommentList := TFhirStringList.Create;
end;

destructor TFhirSpecimenCollection.Destroy;
begin
  FCollector.free;
  FCommentList.Free;
  FCollectedTime.free;
  FQuantity.free;
  FMethod.free;
  FSourceSite.free;
  inherited;
end;

procedure TFhirSpecimenCollection.Assign(oSource : TAdvObject);
begin
  inherited;
  collector := TFhirSpecimenCollection(oSource).collector.Clone;
  FCommentList.Assign(TFhirSpecimenCollection(oSource).FCommentList);
  collectedTime := TFhirSpecimenCollection(oSource).collectedTime.Clone;
  quantity := TFhirSpecimenCollection(oSource).quantity.Clone;
  method := TFhirSpecimenCollection(oSource).method.Clone;
  sourceSite := TFhirSpecimenCollection(oSource).sourceSite.Clone;
end;

procedure TFhirSpecimenCollection.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(Collector.Link);
  if (child_name = 'comment') Then
     list.addAll(FCommentList);
  if (child_name = 'collectedTime') Then
     list.add(CollectedTime.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'sourceSite') Then
     list.add(SourceSite.Link);
end;

procedure TFhirSpecimenCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Resource(Practitioner)', FCollector.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', FCommentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'collectedTime', 'dateTime', FCollectedTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceSite', 'CodeableConcept', FSourceSite.Link.Link));{2}
end;

function TFhirSpecimenCollection.Link : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Link);
end;

function TFhirSpecimenCollection.Clone : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Clone);
end;

{ TFhirSpecimenCollection }

Procedure TFhirSpecimenCollection.SetCollector(value : TFhirResourceReference{TFhirPractitioner});
begin
  FCollector.free;
  FCollector := value;
end;

Procedure TFhirSpecimenCollection.SetCollectedTime(value : TFhirDateTime);
begin
  FCollectedTime.free;
  FCollectedTime := value;
end;

Function TFhirSpecimenCollection.GetCollectedTimeST : TDateAndTime;
begin
  if FCollectedTime = nil then
    result := nil
  else
    result := CollectedTime.value;
end;

Procedure TFhirSpecimenCollection.SetCollectedTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FCollectedTime = nil then
      FCollectedTime := TFhirDateTime.create;
    FCollectedTime.value := value
  end
  else if FCollectedTime <> nil then
    FCollectedTime.value := nil;
end;

Procedure TFhirSpecimenCollection.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSpecimenCollection.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirSpecimenCollection.SetSourceSite(value : TFhirCodeableConcept);
begin
  FSourceSite.free;
  FSourceSite := value;
end;


{ TFhirSpecimenCollectionList }
procedure TFhirSpecimenCollectionList.AddItem(value: TFhirSpecimenCollection);
begin
  assert(value.ClassName = 'TFhirSpecimenCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenCollection');
  add(value);
end;


function TFhirSpecimenCollectionList.Append: TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenCollectionList.Clone: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Clone);
end;

function TFhirSpecimenCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenCollectionList.GetItemN(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.IndexOf(value: TFhirSpecimenCollection): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenCollectionList.Insert(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenCollectionList.InsertItem(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  Inherited Insert(index, value);
end;

function TFhirSpecimenCollectionList.Item(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.Link: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Link);
end;

procedure TFhirSpecimenCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenCollectionList.SetItemByIndex(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  FhirSpecimenCollections[index] := value;
end;

procedure TFhirSpecimenCollectionList.SetItemN(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenTreatment }

constructor TFhirSpecimenTreatment.Create;
begin
  inherited;
  FAdditiveList := TFhirResourceReferenceList{TFhirSubstance}.Create;
end;

destructor TFhirSpecimenTreatment.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditiveList.Free;
  inherited;
end;

procedure TFhirSpecimenTreatment.Assign(oSource : TAdvObject);
begin
  inherited;
  description := TFhirSpecimenTreatment(oSource).description.Clone;
  procedure_ := TFhirSpecimenTreatment(oSource).procedure_.Clone;
  FAdditiveList.Assign(TFhirSpecimenTreatment(oSource).FAdditiveList);
end;

procedure TFhirSpecimenTreatment.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'procedure_') Then
     list.add(Procedure_.Link);
  if (child_name = 'additive') Then
     list.addAll(FAdditiveList);
end;

procedure TFhirSpecimenTreatment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', FProcedure_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Resource(Substance)', FAdditiveList.Link)){3};
end;

function TFhirSpecimenTreatment.Link : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Link);
end;

function TFhirSpecimenTreatment.Clone : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Clone);
end;

{ TFhirSpecimenTreatment }

Procedure TFhirSpecimenTreatment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenTreatment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirSpecimenTreatment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenTreatment.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;


{ TFhirSpecimenTreatmentList }
procedure TFhirSpecimenTreatmentList.AddItem(value: TFhirSpecimenTreatment);
begin
  assert(value.ClassName = 'TFhirSpecimenTreatment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenTreatment');
  add(value);
end;


function TFhirSpecimenTreatmentList.Append: TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenTreatmentList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenTreatmentList.Clone: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Clone);
end;

function TFhirSpecimenTreatmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenTreatmentList.GetItemN(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.IndexOf(value: TFhirSpecimenTreatment): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenTreatmentList.Insert(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenTreatmentList.InsertItem(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  Inherited Insert(index, value);
end;

function TFhirSpecimenTreatmentList.Item(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.Link: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Link);
end;

procedure TFhirSpecimenTreatmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenTreatmentList.SetItemByIndex(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  FhirSpecimenTreatments[index] := value;
end;

procedure TFhirSpecimenTreatmentList.SetItemN(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenContainer }

constructor TFhirSpecimenContainer.Create;
begin
  inherited;
  FIdentifierList := TFhirIdentifierList.Create;
end;

destructor TFhirSpecimenContainer.Destroy;
begin
  FIdentifierList.Free;
  FDescription.free;
  FType_.free;
  FCapacity.free;
  FSpecimenQuantity.free;
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenContainer.Assign(oSource : TAdvObject);
begin
  inherited;
  FIdentifierList.Assign(TFhirSpecimenContainer(oSource).FIdentifierList);
  description := TFhirSpecimenContainer(oSource).description.Clone;
  type_ := TFhirSpecimenContainer(oSource).type_.Clone;
  capacity := TFhirSpecimenContainer(oSource).capacity.Clone;
  specimenQuantity := TFhirSpecimenContainer(oSource).specimenQuantity.Clone;
  additive := TFhirSpecimenContainer(oSource).additive.Clone;
end;

procedure TFhirSpecimenContainer.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.addAll(FIdentifierList);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'capacity') Then
     list.add(Capacity.Link);
  if (child_name = 'specimenQuantity') Then
     list.add(SpecimenQuantity.Link);
  if (child_name = 'additive') Then
     list.add(Additive.Link);
end;

procedure TFhirSpecimenContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', FCapacity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimenQuantity', 'Quantity', FSpecimenQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Resource(Substance)', FAdditive.Link.Link));{2}
end;

function TFhirSpecimenContainer.Link : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Link);
end;

function TFhirSpecimenContainer.Clone : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Clone);
end;

{ TFhirSpecimenContainer }

Procedure TFhirSpecimenContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirSpecimenContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSpecimenContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value;
end;

Procedure TFhirSpecimenContainer.SetSpecimenQuantity(value : TFhirQuantity);
begin
  FSpecimenQuantity.free;
  FSpecimenQuantity := value;
end;

Procedure TFhirSpecimenContainer.SetAdditive(value : TFhirResourceReference{TFhirSubstance});
begin
  FAdditive.free;
  FAdditive := value;
end;


{ TFhirSpecimenContainerList }
procedure TFhirSpecimenContainerList.AddItem(value: TFhirSpecimenContainer);
begin
  assert(value.ClassName = 'TFhirSpecimenContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenContainer');
  add(value);
end;


function TFhirSpecimenContainerList.Append: TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenContainerList.Clone: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Clone);
end;

function TFhirSpecimenContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenContainerList.GetItemN(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.IndexOf(value: TFhirSpecimenContainer): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenContainerList.Insert(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenContainerList.InsertItem(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenContainerList.Item(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.Link: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Link);
end;

procedure TFhirSpecimenContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  FhirSpecimenContainers[index] := value;
end;

procedure TFhirSpecimenContainerList.SetItemN(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyDispense }

constructor TFhirSupplyDispense.Create;
begin
  inherited;
  FReceiverList := TFhirResourceReferenceList{TFhirPractitioner}.Create;
end;

destructor TFhirSupplyDispense.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FQuantity.free;
  FSuppliedItem.free;
  FSupplier.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  inherited;
end;

procedure TFhirSupplyDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSupplyDispense(oSource).identifier.Clone;
  status := TFhirSupplyDispense(oSource).status.Clone;
  type_ := TFhirSupplyDispense(oSource).type_.Clone;
  quantity := TFhirSupplyDispense(oSource).quantity.Clone;
  suppliedItem := TFhirSupplyDispense(oSource).suppliedItem.Clone;
  supplier := TFhirSupplyDispense(oSource).supplier.Clone;
  whenPrepared := TFhirSupplyDispense(oSource).whenPrepared.Clone;
  whenHandedOver := TFhirSupplyDispense(oSource).whenHandedOver.Clone;
  destination := TFhirSupplyDispense(oSource).destination.Clone;
  FReceiverList.Assign(TFhirSupplyDispense(oSource).FReceiverList);
end;

procedure TFhirSupplyDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'status') Then
     list.add(Status.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'suppliedItem') Then
     list.add(SuppliedItem.Link);
  if (child_name = 'supplier') Then
     list.add(Supplier.Link);
  if (child_name = 'whenPrepared') Then
     list.add(WhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(WhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(Destination.Link);
  if (child_name = 'receiver') Then
     list.addAll(FReceiverList);
end;

procedure TFhirSupplyDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'suppliedItem', 'Resource(Medication|Substance|Device)', FSuppliedItem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Resource(Practitioner)', FSupplier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'Period', FWhenPrepared.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'Period', FWhenHandedOver.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Resource(Practitioner)', FReceiverList.Link)){3};
end;

function TFhirSupplyDispense.Link : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(inherited Link);
end;

function TFhirSupplyDispense.Clone : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(inherited Clone);
end;

{ TFhirSupplyDispense }

Procedure TFhirSupplyDispense.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSupplyDispense.SetStatus(value : TFhirCode);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSupplyDispense.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := Status.value;
end;

Procedure TFhirSupplyDispense.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirCode.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

Procedure TFhirSupplyDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSupplyDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSupplyDispense.SetSuppliedItem(value : TFhirResourceReference{Resource});
begin
  FSuppliedItem.free;
  FSuppliedItem := value;
end;

Procedure TFhirSupplyDispense.SetSupplier(value : TFhirResourceReference{TFhirPractitioner});
begin
  FSupplier.free;
  FSupplier := value;
end;

Procedure TFhirSupplyDispense.SetWhenPrepared(value : TFhirPeriod);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Procedure TFhirSupplyDispense.SetWhenHandedOver(value : TFhirPeriod);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Procedure TFhirSupplyDispense.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;


{ TFhirSupplyDispenseList }
procedure TFhirSupplyDispenseList.AddItem(value: TFhirSupplyDispense);
begin
  assert(value.ClassName = 'TFhirSupplyDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDispense');
  add(value);
end;


function TFhirSupplyDispenseList.Append: TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSupplyDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDispenseList.Clone: TFhirSupplyDispenseList;
begin
  result := TFhirSupplyDispenseList(inherited Clone);
end;

function TFhirSupplyDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDispenseList.GetItemN(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(ObjectByIndex[index]);
end;

function TFhirSupplyDispenseList.IndexOf(value: TFhirSupplyDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSupplyDispenseList.Insert(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSupplyDispenseList.InsertItem(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  Inherited Insert(index, value);
end;

function TFhirSupplyDispenseList.Item(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(ObjectByIndex[index]);
end;

function TFhirSupplyDispenseList.Link: TFhirSupplyDispenseList;
begin
  result := TFhirSupplyDispenseList(inherited Link);
end;

procedure TFhirSupplyDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDispenseList.SetItemByIndex(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  FhirSupplyDispenses[index] := value;
end;

procedure TFhirSupplyDispenseList.SetItemN(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetDefine }

constructor TFhirValueSetDefine.Create;
begin
  inherited;
  FConceptList := TFhirValueSetDefineConceptList.Create;
end;

destructor TFhirValueSetDefine.Destroy;
begin
  FSystem.free;
  FCaseSensitive.free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetDefine.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirValueSetDefine(oSource).system.Clone;
  caseSensitive := TFhirValueSetDefine(oSource).caseSensitive.Clone;
  FConceptList.Assign(TFhirValueSetDefine(oSource).FConceptList);
end;

procedure TFhirValueSetDefine.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'caseSensitive') Then
     list.add(CaseSensitive.Link);
  if (child_name = 'concept') Then
     list.addAll(FConceptList);
end;

procedure TFhirValueSetDefine.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'caseSensitive', 'boolean', FCaseSensitive.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '', FConceptList.Link)){3};
end;

function TFhirValueSetDefine.Link : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(inherited Link);
end;

function TFhirValueSetDefine.Clone : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(inherited Clone);
end;

{ TFhirValueSetDefine }

Procedure TFhirValueSetDefine.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetDefine.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirValueSetDefine.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetDefine.SetCaseSensitive(value : TFhirBoolean);
begin
  FCaseSensitive.free;
  FCaseSensitive := value;
end;

Function TFhirValueSetDefine.GetCaseSensitiveST : String;
begin
  if FCaseSensitive = nil then
    result := ''
  else
    result := CaseSensitive.value;
end;

Procedure TFhirValueSetDefine.SetCaseSensitiveST(value : String);
begin
  if value <> '' then
  begin
    if FCaseSensitive = nil then
      FCaseSensitive := TFhirBoolean.create;
    FCaseSensitive.value := value
  end
  else if FCaseSensitive <> nil then
    FCaseSensitive.value := '';
end;


{ TFhirValueSetDefineList }
procedure TFhirValueSetDefineList.AddItem(value: TFhirValueSetDefine);
begin
  assert(value.ClassName = 'TFhirValueSetDefine', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetDefine');
  add(value);
end;


function TFhirValueSetDefineList.Append: TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetDefineList.Clone: TFhirValueSetDefineList;
begin
  result := TFhirValueSetDefineList(inherited Clone);
end;

function TFhirValueSetDefineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetDefineList.GetItemN(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(ObjectByIndex[index]);
end;

function TFhirValueSetDefineList.IndexOf(value: TFhirValueSetDefine): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetDefineList.Insert(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineList.InsertItem(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  Inherited Insert(index, value);
end;

function TFhirValueSetDefineList.Item(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(ObjectByIndex[index]);
end;

function TFhirValueSetDefineList.Link: TFhirValueSetDefineList;
begin
  result := TFhirValueSetDefineList(inherited Link);
end;

procedure TFhirValueSetDefineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetDefineList.SetItemByIndex(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  FhirValueSetDefines[index] := value;
end;

procedure TFhirValueSetDefineList.SetItemN(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetDefineConcept }

constructor TFhirValueSetDefineConcept.Create;
begin
  inherited;
  FConceptList := TFhirValueSetDefineConceptList.Create;
end;

destructor TFhirValueSetDefineConcept.Destroy;
begin
  FCode.free;
  FAbstract.free;
  FDisplay.free;
  FDefinition.free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetDefineConcept.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirValueSetDefineConcept(oSource).code.Clone;
  abstract := TFhirValueSetDefineConcept(oSource).abstract.Clone;
  display := TFhirValueSetDefineConcept(oSource).display.Clone;
  definition := TFhirValueSetDefineConcept(oSource).definition.Clone;
  FConceptList.Assign(TFhirValueSetDefineConcept(oSource).FConceptList);
end;

procedure TFhirValueSetDefineConcept.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'abstract') Then
     list.add(Abstract.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
  if (child_name = 'concept') Then
     list.addAll(FConceptList);
end;

procedure TFhirValueSetDefineConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', FAbstract.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'string', FDefinition.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '@ValueSet.define.concept', FConceptList.Link)){3};
end;

function TFhirValueSetDefineConcept.Link : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(inherited Link);
end;

function TFhirValueSetDefineConcept.Clone : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(inherited Clone);
end;

{ TFhirValueSetDefineConcept }

Procedure TFhirValueSetDefineConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetDefineConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirValueSetDefineConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetDefineConcept.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirValueSetDefineConcept.GetAbstractST : String;
begin
  if FAbstract = nil then
    result := ''
  else
    result := Abstract.value;
end;

Procedure TFhirValueSetDefineConcept.SetAbstractST(value : String);
begin
  if value <> '' then
  begin
    if FAbstract = nil then
      FAbstract := TFhirBoolean.create;
    FAbstract.value := value
  end
  else if FAbstract <> nil then
    FAbstract.value := '';
end;

Procedure TFhirValueSetDefineConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetDefineConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirValueSetDefineConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirValueSetDefineConcept.SetDefinition(value : TFhirString);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirValueSetDefineConcept.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := Definition.value;
end;

Procedure TFhirValueSetDefineConcept.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirString.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;


{ TFhirValueSetDefineConceptList }
procedure TFhirValueSetDefineConceptList.AddItem(value: TFhirValueSetDefineConcept);
begin
  assert(value.ClassName = 'TFhirValueSetDefineConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetDefineConcept');
  add(value);
end;


function TFhirValueSetDefineConceptList.Append: TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineConceptList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetDefineConceptList.Clone: TFhirValueSetDefineConceptList;
begin
  result := TFhirValueSetDefineConceptList(inherited Clone);
end;

function TFhirValueSetDefineConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetDefineConceptList.GetItemN(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(ObjectByIndex[index]);
end;

function TFhirValueSetDefineConceptList.IndexOf(value: TFhirValueSetDefineConcept): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetDefineConceptList.Insert(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineConceptList.InsertItem(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  Inherited Insert(index, value);
end;

function TFhirValueSetDefineConceptList.Item(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(ObjectByIndex[index]);
end;

function TFhirValueSetDefineConceptList.Link: TFhirValueSetDefineConceptList;
begin
  result := TFhirValueSetDefineConceptList(inherited Link);
end;

procedure TFhirValueSetDefineConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetDefineConceptList.SetItemByIndex(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  FhirValueSetDefineConcepts[index] := value;
end;

procedure TFhirValueSetDefineConceptList.SetItemN(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetCompose }

constructor TFhirValueSetCompose.Create;
begin
  inherited;
  FImportList := TFhirUriList.Create;
  FIncludeList := TFhirValueSetComposeIncludeList.Create;
  FExcludeList := TFhirValueSetComposeIncludeList.Create;
end;

destructor TFhirValueSetCompose.Destroy;
begin
  FImportList.Free;
  FIncludeList.Free;
  FExcludeList.Free;
  inherited;
end;

procedure TFhirValueSetCompose.Assign(oSource : TAdvObject);
begin
  inherited;
  FImportList.Assign(TFhirValueSetCompose(oSource).FImportList);
  FIncludeList.Assign(TFhirValueSetCompose(oSource).FIncludeList);
  FExcludeList.Assign(TFhirValueSetCompose(oSource).FExcludeList);
end;

procedure TFhirValueSetCompose.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'import') Then
     list.addAll(FImportList);
  if (child_name = 'include') Then
     list.addAll(FIncludeList);
  if (child_name = 'exclude') Then
     list.addAll(FExcludeList);
end;

procedure TFhirValueSetCompose.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'import', 'uri', FImportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'include', '', FIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', '@ValueSet.compose.include', FExcludeList.Link)){3};
end;

function TFhirValueSetCompose.Link : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Link);
end;

function TFhirValueSetCompose.Clone : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Clone);
end;

{ TFhirValueSetCompose }


{ TFhirValueSetComposeList }
procedure TFhirValueSetComposeList.AddItem(value: TFhirValueSetCompose);
begin
  assert(value.ClassName = 'TFhirValueSetCompose', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCompose');
  add(value);
end;


function TFhirValueSetComposeList.Append: TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeList.Clone: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Clone);
end;

function TFhirValueSetComposeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeList.GetItemN(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.IndexOf(value: TFhirValueSetCompose): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeList.Insert(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeList.InsertItem(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeList.Item(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.Link: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Link);
end;

procedure TFhirValueSetComposeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeList.SetItemByIndex(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  FhirValueSetComposes[index] := value;
end;

procedure TFhirValueSetComposeList.SetItemN(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeInclude }

constructor TFhirValueSetComposeInclude.Create;
begin
  inherited;
  FCodeList := TFhirCodeList.Create;
  FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
end;

destructor TFhirValueSetComposeInclude.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FCodeList.Free;
  FFilterList.Free;
  inherited;
end;

procedure TFhirValueSetComposeInclude.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirValueSetComposeInclude(oSource).system.Clone;
  version := TFhirValueSetComposeInclude(oSource).version.Clone;
  FCodeList.Assign(TFhirValueSetComposeInclude(oSource).FCodeList);
  FFilterList.Assign(TFhirValueSetComposeInclude(oSource).FFilterList);
end;

procedure TFhirValueSetComposeInclude.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'version') Then
     list.add(Version.Link);
  if (child_name = 'code') Then
     list.addAll(FCodeList);
  if (child_name = 'filter') Then
     list.addAll(FFilterList);
end;

procedure TFhirValueSetComposeInclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'filter', '', FFilterList.Link)){3};
end;

function TFhirValueSetComposeInclude.Link : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Link);
end;

function TFhirValueSetComposeInclude.Clone : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Clone);
end;

{ TFhirValueSetComposeInclude }

Procedure TFhirValueSetComposeInclude.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetComposeInclude.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirValueSetComposeInclude.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetComposeInclude.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetComposeInclude.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := Version.value;
end;

Procedure TFhirValueSetComposeInclude.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;


{ TFhirValueSetComposeIncludeList }
procedure TFhirValueSetComposeIncludeList.AddItem(value: TFhirValueSetComposeInclude);
begin
  assert(value.ClassName = 'TFhirValueSetComposeInclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeInclude');
  add(value);
end;


function TFhirValueSetComposeIncludeList.Append: TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeList.Clone: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Clone);
end;

function TFhirValueSetComposeIncludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeList.GetItemN(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.IndexOf(value: TFhirValueSetComposeInclude): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeIncludeList.Insert(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeList.InsertItem(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeList.Item(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.Link: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  FhirValueSetComposeIncludes[index] := value;
end;

procedure TFhirValueSetComposeIncludeList.SetItemN(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeFilter }

constructor TFhirValueSetComposeIncludeFilter.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeFilter.Destroy;
begin
  FProperty_.free;
  FOp.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeFilter.Assign(oSource : TAdvObject);
begin
  inherited;
  property_ := TFhirValueSetComposeIncludeFilter(oSource).property_.Clone;
  FOp := TFhirValueSetComposeIncludeFilter(oSource).FOp.Link;
  value := TFhirValueSetComposeIncludeFilter(oSource).value.Clone;
end;

procedure TFhirValueSetComposeIncludeFilter.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'property_') Then
     list.add(Property_.Link);
  if (child_name = 'op') Then
     list.add(FOp.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirValueSetComposeIncludeFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'code', FProperty_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'op', 'code', FOp.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'code', FValue.Link.Link));{2}
end;

function TFhirValueSetComposeIncludeFilter.Link : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Link);
end;

function TFhirValueSetComposeIncludeFilter.Clone : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Clone);
end;

{ TFhirValueSetComposeIncludeFilter }

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_(value : TFhirCode);
begin
  FProperty_.free;
  FProperty_ := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := Property_.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirCode.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOp(value : TFhirEnum);
begin
  FOp.free;
  FOp := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetOpST : TFhirFilterOperator;
begin
  if FOp = nil then
    result := TFhirFilterOperator(0)
  else
    result := TFhirFilterOperator(StringArrayIndexOf(CODES_TFhirFilterOperator, Op.value));
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOpST(value : TFhirFilterOperator);
begin
  if ord(value) = 0 then
    Op := nil
  else
    Op := TFhirEnum.create(CODES_TFhirFilterOperator[value]);
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValue(value : TFhirCode);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := Value.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirCode.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirValueSetComposeIncludeFilterList }
procedure TFhirValueSetComposeIncludeFilterList.AddItem(value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeFilter');
  add(value);
end;


function TFhirValueSetComposeIncludeFilterList.Append: TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeFilterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeFilterList.Clone: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeFilterList.GetItemN(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.IndexOf(value: TFhirValueSetComposeIncludeFilter): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeIncludeFilterList.Insert(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeFilterList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeFilterList.Item(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.Link: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  FhirValueSetComposeIncludeFilters[index] := value;
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansion }

constructor TFhirValueSetExpansion.Create;
begin
  inherited;
  FContainsList := TFhirValueSetExpansionContainsList.Create;
end;

destructor TFhirValueSetExpansion.Destroy;
begin
  FTimestamp.free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansion.Assign(oSource : TAdvObject);
begin
  inherited;
  timestamp := TFhirValueSetExpansion(oSource).timestamp.Clone;
  FContainsList.Assign(TFhirValueSetExpansion(oSource).FContainsList);
end;

procedure TFhirValueSetExpansion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'timestamp') Then
     list.add(Timestamp.Link);
  if (child_name = 'contains') Then
     list.addAll(FContainsList);
end;

procedure TFhirValueSetExpansion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', FTimestamp.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contains', '', FContainsList.Link)){3};
end;

function TFhirValueSetExpansion.Link : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Link);
end;

function TFhirValueSetExpansion.Clone : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Clone);
end;

{ TFhirValueSetExpansion }

Procedure TFhirValueSetExpansion.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirValueSetExpansion.GetTimestampST : TDateAndTime;
begin
  if FTimestamp = nil then
    result := nil
  else
    result := Timestamp.value;
end;

Procedure TFhirValueSetExpansion.SetTimestampST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FTimestamp = nil then
      FTimestamp := TFhirInstant.create;
    FTimestamp.value := value
  end
  else if FTimestamp <> nil then
    FTimestamp.value := nil;
end;


{ TFhirValueSetExpansionList }
procedure TFhirValueSetExpansionList.AddItem(value: TFhirValueSetExpansion);
begin
  assert(value.ClassName = 'TFhirValueSetExpansion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansion');
  add(value);
end;


function TFhirValueSetExpansionList.Append: TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionList.Clone: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Clone);
end;

function TFhirValueSetExpansionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionList.GetItemN(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.IndexOf(value: TFhirValueSetExpansion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetExpansionList.Insert(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionList.InsertItem(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionList.Item(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.Link: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Link);
end;

procedure TFhirValueSetExpansionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  FhirValueSetExpansions[index] := value;
end;

procedure TFhirValueSetExpansionList.SetItemN(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionContains }

constructor TFhirValueSetExpansionContains.Create;
begin
  inherited;
  FContainsList := TFhirValueSetExpansionContainsList.Create;
end;

destructor TFhirValueSetExpansionContains.Destroy;
begin
  FSystem.free;
  FCode.free;
  FDisplay.free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansionContains.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirValueSetExpansionContains(oSource).system.Clone;
  code := TFhirValueSetExpansionContains(oSource).code.Clone;
  display := TFhirValueSetExpansionContains(oSource).display.Clone;
  FContainsList.Assign(TFhirValueSetExpansionContains(oSource).FContainsList);
end;

procedure TFhirValueSetExpansionContains.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
  if (child_name = 'contains') Then
     list.addAll(FContainsList);
end;

procedure TFhirValueSetExpansionContains.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contains', '@ValueSet.expansion.contains', FContainsList.Link)){3};
end;

function TFhirValueSetExpansionContains.Link : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Link);
end;

function TFhirValueSetExpansionContains.Clone : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Clone);
end;

{ TFhirValueSetExpansionContains }

Procedure TFhirValueSetExpansionContains.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetExpansionContains.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirValueSetExpansionContains.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetExpansionContains.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirValueSetExpansionContains.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetExpansionContains.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirValueSetExpansionContains.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;


{ TFhirValueSetExpansionContainsList }
procedure TFhirValueSetExpansionContainsList.AddItem(value: TFhirValueSetExpansionContains);
begin
  assert(value.ClassName = 'TFhirValueSetExpansionContains', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionContains');
  add(value);
end;


function TFhirValueSetExpansionContainsList.Append: TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionContainsList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionContainsList.Clone: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Clone);
end;

function TFhirValueSetExpansionContainsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionContainsList.GetItemN(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.IndexOf(value: TFhirValueSetExpansionContains): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetExpansionContainsList.Insert(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionContainsList.InsertItem(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionContainsList.Item(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.Link: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Link);
end;

procedure TFhirValueSetExpansionContainsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionContainsList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  FhirValueSetExpansionContains[index] := value;
end;

procedure TFhirValueSetExpansionContainsList.SetItemN(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  ObjectByIndex[index] := value;
end;

end.

